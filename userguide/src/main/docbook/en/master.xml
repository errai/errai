<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V4.2//EN"
"docbookV4.2/docbookx.dtd" [
<!ENTITY ch01-Introduction SYSTEM "modules/ch01-Introduction.xml">
<!ENTITY ch02-Installation SYSTEM "modules/ch02-Installation.xml">
<!ENTITY ch03-ErraiBus SYSTEM "modules/ch03-errai-bus.xml">
<!ENTITY appendix-A-Quickstart SYSTEM "modules/appendix-A-Quickstart.xml">
]>
<book lang="en">
  <bookinfo>
    <title>Errai User Guide</title>
  </bookinfo>

  <toc></toc>

  <chapter id="introduction">
    <title>Introduction</title>

    <section>
      <title>What is it</title>

      <para>Errai is a GWT-based framework for building rich web applications
      using next-generation web technologies. Built on-top of ErraiBus, the
      framework provides a unified federation and RPC infrastructure with
      true, uniform, asynchronous messaging across the client and
      server.</para>
    </section>

    <section>
      <title>License and EULA</title>

      <para>Errai is distributed under the terms of the the Apache License,
      Version 2.0. See<ulink url="http://www.apache.org/licenses/LICENSE-2.0">
      the full Apache license text</ulink>.</para>
    </section>

    <section>
      <title>Downloads</title>

      <para>The distribution packages can be downloaded from jboss.org <ulink
      url="http://jboss.org/errai/Downloads.html">http://jboss.org/errai/Downloads.html</ulink></para>
    </section>

    <section>
      <title>Sources</title>

      <para>The source code for this component can be found in the Errai SVN
      repository: <ulink
      url="http://anonsvn.jboss.org/repos/errai/trunk/">https://anonsvn.jboss.org/repos/errai/trunk/</ulink></para>
    </section>

    <section>
      <title>Reporting problems</title>

      <para>If you run into trouble don't hesitate to get in touch with us:
      <itemizedlist>
          <listitem>
            <para>JIRA Issue Tracking: <ulink
            url="https://jira.jboss.org/jira/browse/ERRAI">https://jira.jboss.org/jira/browse/ERRAI
            </ulink></para>
          </listitem>

          <listitem>
            <para>User Forum: <ulink
            url="http://www.jboss.org/index.html?module=bb&amp;op=viewforum&amp;f=295">http://www.jboss.org/index.html?module=bb&amp;op=viewforum&amp;f=295</ulink></para>
          </listitem>

          <listitem>
            <para>Mailing List: <ulink
            url="http://jboss.org/errai/MailingLists.html">http://jboss.org/errai/MailingLists.html</ulink></para>
          </listitem>

          <listitem>
            <para>IRC: irc://irc.freenode.net/errai</para>
          </listitem>
        </itemizedlist></para>
    </section>
  </chapter>

  <chapter id="installation">
    <title>Installation</title>

    <section>
      <title>Required software</title>

      <para>Errai requires a JDK version 5 or higher and depends on Apache
      Maven to build and run the examples, and for leverging the quickstart
      utilities. <itemizedlist>
          <listitem>
            <para>JDK 5: <ulink
            url="http://java.sun.com/javase/downloads/index.jsp">http://java.sun.com/javase/downloads/index.jsp</ulink></para>
          </listitem>

          <listitem>
            <para>Apache Maven: <ulink
            url="http://maven.apache.org/download.html">http://maven.apache.org/download.html</ulink></para>
          </listitem>
        </itemizedlist> <note>
          <title>Launching maven the first time</title>

          <para>Please note, that when launching maven the first time on your
          machine, it will fetch all dependecies from a central repository.
          This may take a while, because it includes downloading large
          binaries like GWT SDK. However subsequent builds are not required to
          go through this step and will be much faster.</para>
        </note></para>
    </section>

    <section id="thedistribution">
      <title>Distribution Package</title>

      <para>Unzip the Errai download (<literal>Errai-X.Y.zip</literal>) to
      some location on your hard drive. You'll see following
      subdirectories:</para>

      <itemizedlist>
        <listitem>
          <para><filename>doc</filename>: User guide and javadocs</para>
        </listitem>

        <listitem>
          <para><filename>examples</filename>: Examples that are used in the
          user guide</para>
        </listitem>

        <listitem>
          <para><filename>lib</filename>: Required libraries</para>
        </listitem>
      </itemizedlist>
    </section>
  </chapter>

  <chapter id="bus">
    <title>Errai Bus</title>

    <sect1 id="bus-intro">
      <title>What is Errai Bus?</title>

      <para>ErraiBus forms the backbone of the Errai framework's approach to
      application design. Most importantly, it provides a straight-forward
      approach to a complex problem space. Providing common APIs across the
      client and server, developers will have no trouble working with complex
      messaging scenarios from building instant messaging clients, stock
      tickers, to monitoring instruments. There's no more messing with RPC
      APIs, or unweildy AJAX or COMET frameworks. We've built it all in to
      one, consice messaging framework. It's single-paradigm, and it's fun to
      work with.</para>
    </sect1>

    <sect1>
      <title>Messaging</title>

      <para>This section covers the core messaging concepts of the ErraiBus
      messaging framework.</para>

      <sect2>
        <title>Messaging Overview</title>

        <para>It's important to understand the concept of how messaging works
        in ErraiBus. Service endpoints are given string-based names that are
        referenced by message senders. There is no difference between sending
        a message to a client-based service, or sending a message to a
        server-based service. In fact, a service of the same name may co-exist
        on both the client and the server and both will receive all messages
        bound for that service name, whether they are sent from the client or
        from the server.</para>

        <para>Services are lightweight in ErraiBus, and can be declared
        liberally and extensively within your application to provide a
        message-based infrastructure for your web application. It can be
        tempting to think of ErraiBus simply as a client-server communication
        platform, but there is a plethora of possibilities for using ErraiBus
        purely with the GWT client context, such as a way to advertise and
        expose components dynamically, to get around the lack of reflection in
        GWT.</para>

        <para>In fact, ErraiBus was originally designed to run completely
        within the client but quickly evolved into having the capabilities it
        now has today. So keep that in mind when you run up against problems
        in the client space that could benefit from runtime federation.</para>
      </sect2>

      <sect2>
        <title>MessageBuilder API</title>

        <para>The MessageBuilder is the heart of the messaging API in
        ErraiBus. It provides a fluent / builder API, that is used for
        constructing messages. All three major message patterns can be
        constructed from the <varname>MessageBuilder</varname>.</para>

        <para>Components that want to receive messages need to implement the
        <varname>MessageCallback</varname> interface.</para>

        <para>But before we dive into the details, let look at some use cases
        first.</para>
      </sect2>

      <sect2>
        <title>Sending Messages with the Client Bus</title>

        <para>In order to send a message from a client you need to create a
        <emphasis><emphasis><filename>Message</filename></emphasis></emphasis>
        and send it through an instance of <filename>MessageBus</filename>. In
        this simple example we send it to the subject
        'HelloWorldService'.</para>

        <programlisting>    public class HelloWorld implements EntryPoint {

        // Get an instance of the RequestDispatcher
        private RequestDispatcher dispatcher = ErraiBus.getDispatcher();

        public void onModuleLoad() {
            Button button = new Button("Send message");

            button.addClickHandler(new ClickHandler() {

            public void onClick(ClickEvent event) {
                // Send a message to the 'HelloWorldService'.
                MessageBuilder.createMessage()
                    .toSubject("HelloWorldService")             // (1)
                    .signalling()                               // (2)
                    .noErrorHandling()                          // (3)
                    .sendNowWith(dispatcher);                   // (4)
            });

            [...]
         }
    }</programlisting>

        <para>In the above example we build and send a message every time the
        button is clicked. Here's an explanation of what's going on as
        annotated above:</para>

        <orderedlist>
          <listitem>
            <para>We specify the subject we wish to send a message to. In this
            case, "<varname>HelloWorldService</varname>".</para>
          </listitem>

          <listitem>
            <para>We indicate that we wish to only signal the service,
            meaning, that we're not sending a qualifying command to the
            service. For information on this, read the section on
            <emphasis>Protocols</emphasis>.</para>
          </listitem>

          <listitem>
            <para>We indicate that we do not want to provide an
            <varname>ErrorCallback</varname> to deal with errors for this
            message.</para>
          </listitem>

          <listitem>
            <para>We transmit the message by providing an instance to the
            EquestDispatcher</para>
          </listitem>
        </orderedlist>

        <note>
          <para>An astute observer will note that access to the
          <literal>RequestDispatcher</literal> differs within client code and
          server code. Because the client code does not run within a
          container, access to the <literal>RequestDispatcher</literal> and
          <varname>MessageBus</varname> is statically accessed using the
          <literal>ErraiBus.get()</literal> and
          <varname>ErraiBus.getDispatcher() </varname>methods. The server-side
          code, conversely, runs inside a dependency container for managing
          components. It currently uses Guice as the default container, but
          will more generically support the JSR-330 specification in the
          future.</para>
        </note>
      </sect2>

      <sect2>
        <title>Recieving Messages on the Server Bus / Server Services</title>

        <para>Every message has a sender and at least one receiver. A receiver
        is as it sounds--it receives the message and does something with it.
        Implementing a receiver (also referred to as a service) is as simple
        as implementing our standard MessageCallback interface, which is used
        pervasively across, both client and server code. Let's begin with
        server side component that receives messages:</para>

        <programlisting>   @Service
    public class HelloWorldService implements MessageCallback {
        public void callback(Message message) {
            System.out.println("Hello, World!");
        }
    }</programlisting>

        <para>He we declare an extremely simple service. The
        <varname>@Service</varname> annotation provides a convenient,
        meta-data based way of having the bus auto-discover and deploy the
        service.</para>
      </sect2>

      <sect2>
        <title>Sending Messages with the Server Bus</title>

        <para>In the following example we extend our server side component to
        reply with a message when the callback method is invoked. It will
        create a message and address it to the subject
        '<varname>HelloWorldClient</varname>':</para>

        <programlisting>    @Service
    public class HelloWorldService implements MessageCallback {

        private RequestDispatcher dispatcher;

        @Inject                                         
        public HelloWorldService(RequestDispatcher disaptcher) {
            dispatcher = dispatcher;
        }

        public void callback(CommandMessage message) {
                // Send a message to the 'HelloWorldClient'.
                MessageBuilder.createMessage()
                    .toSubject("HelloWorldClient")              // (1)
                    .signalling()                               // (2)
                    .with("text", "Hi There")                   // (3)
                    .noErrorHandling()                          // (4)
                    .sendNowWith(dispatcher);                   // (5)
            });
        }
    }   </programlisting>

        <para>The above example shows a service which sends a message in
        response to receiving a message. Here's what's going on:</para>

        <orderedlist>
          <listitem>
            <para>We specify the subject we wish to send a message to. In this
            case, "<varname>HelloWorldClient</varname>". We are sending this
            message to all clients which are listening in on this subject. For
            information on how to communicate with a single client, see
            Section 2.6.</para>
          </listitem>

          <listitem>
            <para>We indicate that we wish to only signal the service, meaning
            that we're not sending a qualifying command to the service. For
            information on this, read the section on Protocols.</para>
          </listitem>

          <listitem>
            <para>We add a message part called "text" which contains the value
            "Hi there".</para>
          </listitem>

          <listitem>
            <para>We indicate that we do not want to provide an
            <varname>ErrorCallback</varname> to deal with errors for this
            message.</para>
          </listitem>

          <listitem>
            <para>We transmit the message by providing an instance of the
            <varname>RequestDispatcher</varname>.</para>
          </listitem>
        </orderedlist>
      </sect2>

      <sect2>
        <title>Receiving Messages on the Client Bus/ Client Services</title>

        <para>Messages can be received asynchronously and arbitriraily by
        declaring callback services within the client bus. As ErraiBus
        maintains an open COMET channel at all times, these messages are
        delivered in real time to the client as they are sent. This provides
        built-in push messaging for all client services.</para>

        <programlisting>
    public class HelloWorld implements EntryPoint {
        private MessageBus bus = ErraiBus.get();

        public void onModuleLoad() {
        [...]

        /**
        * Declare a local service to receive messages on the subject
        * "BroadcastReceiver".
        */
        bus.subscribe("BroadcastReceiver", new MessageCallback() {
            public void callback(CommandMessage message) {
                /**
                * When a message arrives, extract the "text" field and
                * do something with it
                */
                String messageText = message.get(String.class, "text");
            }
        });

        [...]
    }</programlisting>

        <para>In the above example, we declare a new client service called
        <literal>"BroadcastReceiver"</literal> which can now accept both local
        messages and remote messages from the server bus. The service will be
        available in the client to receive messages as long the client bus is
        connected and the service is not explicitly de-registered.</para>
      </sect2>

      <sect2>
        <title>Conversations</title>

        <para>Conversations are message exchanges which are between a single
        client and a service. They are a fundmentally important concept in
        ErraiBus, since by default, a message will be broadcast to all client
        services listening on a particular channel.</para>

        <para>When you create a conversation with an incoming message, you
        ensure that the message you are sending back is received by the same
        client which sent the incoming message. A simple example:</para>

        <programlisting>   @Service
    public class HelloWorldService implements MessageCallback {
        public void callback(CommandMessage message) {
                // Send a message to the 'HelloWorldClient' on the client that sent us the
                // the message.
                MessageBuilder.createConversation(message)
                    .toSubject("HelloWorldClient")
                    .signalling()
                    .with("text", "Hi There! We're having a conversation!")
                    .noErrorHandling().reply();
            });
        }
    }</programlisting>

        <para>Note that the only difference between the example in the
        previous section (2.4) and this is the use of the
        <filename>createConversation() </filename>method with
        <filename>MessageBuilder</filename>.</para>

        <sect3>
          <title>Single-Response Conversations / Psuedo-Synchronous
          Messaging</title>

          <para>It is possible to contruct a message and a default response
          handler as part of the <varname>MessageBuilder</varname> API. It
          should be noted, that multiple replies will not be possible and will
          result an exception if attempted. Using this aspect of the API is
          very useful for doing simple psuedo-synchronous conversive
          things.</para>

          <para>You can do this by specifying a
          <literal>MessageCallback</literal> using the
          <literal>repliesTo()</literal> method in the
          <literal>MessageBuilder</literal> API after specifying the error
          handling of the message.</para>

          <programlisting>MessageBuilder.createMessage()
      .toSubject("ConversationalService").signalling()
      .with("SomeField", someValue)
      .noErrorHandling()
      .repliesTo(new MessageCallback() {
           public void callback(Message message) {
               System.out.println("I received a response");
           }
      })</programlisting>

          <para>See the next section on how to build conversational services
          that can respond to such messages.</para>
        </sect3>

        <sect3>
          <title>Sender Inferred Subjects</title>

          <para>It is possible for the sender to infer, to whatever
          conversational service it is calling, what subject it would like the
          reply to go to. This is accomplished by utilizing the standard
          <filename>MessageParts.ReplyTo</filename> message part. Using this
          methodology for building conversations is generally
          encouraged.</para>

          <para>Consider the following client side code:</para>

          <programlisting>MessageBuilder.createMessage()
       .toSubject("ObjectService").signalling()
       .with(MessageParts.ReplyTo, "ClientEndpoint")
       .noErrorHandling().sendNowWith(dispatcher);</programlisting>

          <para>And the conversational code on the server (for service
          <emphasis>ObjectService</emphasis>):</para>

          <programlisting>MessageBuilder.createConversation(message)
                .subjectProvided().signalling()
                .with("Records", records)
                .noErrorHandling().reply();</programlisting>

          <para>In the above examples, assuming that the latter example is
          inside a service called "<varname>ObjectService</varname>" and is
          referencing the incoming message that was sent in the former
          example, the message created will automatically reference the
          <filename>ReplyTo</filename> subject that was provided by the
          sender, and send the message back to the subject desired by the
          client on the client that sent the message.</para>
        </sect3>
      </sect2>

      <sect2>
        <title>Broadcasting</title>

        <para>Broadcasting messages to all clients listening on a specific
        subject is quite simple and involves nothing more than forgoing use of
        the conversation API. For instance:</para>

        <programlisting>MessageBuilder.createMessage().
                 .toSubject("MessageListener")
                 .with("Text", "Hello, from your overlords in the cloud")
                 .noErrorHandling().sendGlobalWith(dispatcher);</programlisting>

        <para>If sent from the server, all clients currently connected, who
        are listening to the subject <filename>"MessageListener"</filename>
        will receive the message. It's as simple as that.</para>
      </sect2>

      <sect2>
        <title>Client-to-Client Communication</title>

        <para>Communication from one client to another client is not directly
        possible within the bus federation, by design. This isn't to say that
        it's not possible. But one client cannot see a service within the
        federation of another client. We institute this limitation as a matter
        of basic security. But many software engineers will likely find the
        prospects of such communication appealing, so this section will
        provide some basic pointers on how to go about accomplishing
        it.</para>

        <sect3>
          <title>Relay Services</title>

          <para>The essential architectural thing you'll need to do is create
          a relay service that runs on the server. Since a service advertised
          on the server is visible to all clients and all clients are visible
          to the server, you might already see where we're going with
          this.</para>

          <para>By creating a service on the server which accepts messages
          from clients, you can create a simple protocol on-top of the bus to
          enable quasi peer-to-peer communication. (We say quasi, because it
          still needs to be routed through the server)</para>

          <para>While you can probably imagine simply creating a
          broadcast-like service which accepts a message from one client and
          broadcasts it to the rest of the world, it may be less clear how to
          go about routing from one particular client to another particualr
          client, so we'll focus on that problem.</para>

          <para><emphasis role="bold">Message Routing
          Information</emphasis></para>

          <para>Every message that is sent between a local and remote (or
          server and client) buses contain session routing information. This
          information is used by the bus to determine what outbound queues to
          use to deliver the message to, so they will reach their intended
          recipients. It is possible to manually specify this information to
          indicate to the bus, where you want a specific message to go.</para>

          <para>The utility class
          <filename>org.jboss.errai.bus.server.util.ServerBusUtils</filename>
          contains a utility method for extracting the String-based SessionID
          which is used to identify the message queue associated with any
          particular client. You may use this method to extract the
          <varname>SessionID</varname> from a message so that you may use it
          for routing. For example:</para>

          <programlisting>...
public void callback(Message message) {
    String sessionId = ServerBusUtils.getSessionId(message);

    // Record this sessionId somewhere.
    ...
}
...

</programlisting>

          <para>The <varname>SessionID</varname> can then be stored in a
          medium, say a Map, to cross-reference specific users or whatever
          identifier you wish to allow one client to obtain a reference to the
          specific <varname>SessionID</varname> of another client. In which
          case, you can then provide the <varname>SessionID</varname> as a
          MessagePart to indicate to the bus where you want the message to
          go.</para>

          <programlisting>MessageBuilder.createMessage()
    .toSubject("ClientMessageListener")
    .signalling()
    .with(MessageParts.SessionID, sessionId)
    .with("Message", "We're relaying a message!")
    .noErrorHandling().sendNowWith(dispatcher);
</programlisting>

          <para>By providing the <varname>SessionID</varname> part in the
          message, the bus will see this and use it for routing the message to
          the relevant queue.</para>

          <para>Now you're routing from client-to-client!</para>

          <para>It may be tempting however, to try and include destination
          <varname>SessionID</varname>s at the client level, assuming that
          this will make the infrastructure simpler. But this will not achieve
          the desired results, as the bus treates
          <varname>SessionID</varname>s as transient. Meaning, the
          <varname>SessionID</varname> information is not ever transmitted
          from bus-to-bus, and therefore is only directly relevant to the
          proximate bus.</para>
        </sect3>
      </sect2>

      <sect2>
        <title>Handling Errors</title>

        <para>Asynchronous messaging necessitates the need for asynchronous
        error handling. Luckily, support for handling errors is built directly
        into the <varname>MessageBuilder</varname> API, utilizing the
        <varname>ErrorCallback</varname> interface. In the examples shown in
        previous exceptions, error-handing has been glossed over with a
        ubiquitous usage of the <varname>noErrorHandling()</varname> method
        while building messaging. We chose to require the explicit use of such
        a method to remind developers of the fact that they are responsible
        for their own error handling, requiring you to explicitly make the
        decision to forego handling potential errors.</para>

        <para>As a general rule, you should<emphasis role="bold"> always
        handle your errors</emphasis>. It will lead to faster and quicker
        identification of problems with your applications if you have error
        handlers, and generally help you build more robust code.</para>

        <programlisting>MessageBuilder.createMessage()                                                   
        .toSubject("HelloWorldService")                                          
        .signalling()                                                            
        .with("msg", "Hi there!")                                                
        .errorsHandledBy(new ErrorCallback() {                                   
            public boolean error(Message message, Throwable throwable) {         
                throwable.printStackTrace();                                     
                return true;                                                    
            }                                                                    
        })                                                                       
        .sendNowWith(dispatcher);                                                       </programlisting>

        <para>The addition of error-handling at first may put off developers
        as it makes code more verbose and less-readable. This is nothing that
        some good practice can't fix. In fact, you may find cases where the
        same error-handler can appropriately be shared between multiple
        different calls.</para>

        <programlisting>ErrorCallback error = new ErrorCallback() {
    public boolean error(Message message, Throwable throwable) {         
        throwable.printStackTrace();                                     
        return true;                                                    
    } 
}

MessageBuilder.createMessage()                                                   
        .toSubject("HelloWorldService")                                          
        .signalling()                                                            
        .with("msg", "Hi there!")                                                
        .errorsHandledBy(error)                                                                       
        .sendNowWith(dispatcher);   </programlisting>

        <para>A little nicer.</para>

        <para>The error handler requires that return a
        <varname>boolean</varname> value. This is to indicate whether or not
        Errai should perform the defautl error handling actions it would
        normally take during a failure. You will almost always want to return
        <varname>true</varname> here, unless you are trying to expicitly
        supress some undesirably activity by Errai, such as automatic
        subject-termination in conversations. But this is almost never the
        case.</para>
      </sect2>

      <sect2>
        <title>Asynchronous Message Tasks</title>

        <para>In some applications, it may be necessary or desirable to delay
        transmission of, or continually stream data to a remote client or
        group of clients (or from a client to the server). In cases like this,
        you can utilize the <varname>replyRepeating()</varname>,
        <varname>replyDelayed()</varname>, <varname>sendRepeating()</varname>
        and <varname>sendDelayed()</varname> methods in the
        <varname>MessageBuilder</varname>.</para>

        <sect3>
          <title>Delayed Tasks</title>

          <para>Sending a task with a delay is straight forward. Simply
          utilize the appropriate method (either
          <varname>replyDelayed()</varname> or
          <varname>sendDelayed()</varname>). </para>

          <programlisting>MessageBuilder.createConversation(msg)
   .toSubject("FunSubject")
   .signalling()
   .noErrorHandling()
   .replyDelayed(TimeUnit.SECONDS, 5); // sends the message after 5 seconds.

</programlisting>

          <para>or </para>

          <programlisting>MessageBuilder.createMessage()
   .toSubject("FunSubject")
   .signalling()
   .noErrorHandling()
   .sendDelayed(requestDispatcher, TimeUnit.SECONDS, 5); // sends the message after 5 seconds.</programlisting>
        </sect3>

        <sect3>
          <title>Repeating Tasks</title>

          <para>A repeating task is sent using one of the MessageBuilder's
          <varname>repeatXXX() </varname>methods. The task will repeat
          indefinitely until cancelled (see next section). </para>

          <programlisting>MessageBuilder.createMessage()
   .toSubject("FunSubject")
   .signalling()
   .withProvided("time", new ResourceProvider&lt;String&gt;() {
          SimpleDateFormat fmt = new SimpleDateFormat("hh:mm:ss");
          public String get() {
               return fmt.format(new Date(System.currentTimeMillis());
          }
    }
   .noErrorHandling()
   .sendRepeatingWith(requestDispatcher, TimeUnit.SECONDS, 1); //sends a message every 1 second</programlisting>

          <para>The above example sends a message very 1 second with a message
          part called <varname>"time"</varname>, containing a formatted time
          string. Note the use of the <varname>withProvided()
          </varname>method; a provided message part is calculated at the time
          of transmission as opposed to when the message is
          constructed.</para>
        </sect3>

        <sect3>
          <title>Cancelling an Asynchronous Task</title>

          <para>A delayed or repeating task can be cancelled by calledin the
          <varname>cancel() </varname>method of the
          <varname>AsyncTask</varname> instance which is returned when
          creating a task. Reference to the AsyncTask object can be retained
          and cancelled by any other thread.</para>

          <programlisting>AsyncTask task = MessageBuilder.createConversation(message)                        
        .toSubject("TimeChannel").signalling()                                     
        .withProvided(TimeServerParts.TimeString, new ResourceProvider&lt;String&gt;() { 
            public String get() {                                                  
                return String.valueOf(System.currentTimeMillis());                 
            }                                                                      
        }).defaultErrorHandling().replyRepeating(TimeUnit.MILLISECONDS, 100);      

...

// cancel the task and interrupt it's thread if necessary.
task.cancel(true);

</programlisting>
        </sect3>
      </sect2>
    </sect1>

    <sect1>
      <title>Remote Procedure Calls (RPC)</title>

      <para>ErraiBus supports a high-level RPC layer to make typical
      client-server RPC communication easy on top of the bus. While it is
      possible to use ErraiBus without ever using this API, you may find it to
      be a more useful and concise approach to exposing services to the
      clients.</para>

      <remark>Please Note that this API has changed since version 1.0</remark>

      <sect2>
        <title>Creating RPC services</title>

        <para>RPC services provide a way of creating type-safe mechanisms to
        make client-to-server calls. Currently, this mechanism only support
        client-to-server calls, and not vice-versa.</para>

        <para>Creating a service is straight forward. It requires the
        definition of a remote interface, and a service class which implements
        it. See the following:</para>

        <programlisting>@Remote
public interface MyRemoteService {
    public boolean isEveryoneHappy();
}
</programlisting>

        <para>The <varname>@Remote</varname> annotation tells Errai that we'd
        like to use this interface as a remote interface. The remote interface
        must be part of of the GWT client code. It cannot be part of the
        server-side code, since the interface will need to be referenced from
        both the client and server side code. That said, the implementation of
        a service is relatively to the point:</para>

        <programlisting>@Service
public class MyRemoteServiceImpl implements MyRemoteService {
 
    public boolean isEveryoneHappy() {
       // blatently lie and say everyone's happy.
       return true;
    }
}
</programlisting>

        <para>That's all there is to it. You use the same
        <varname>@Service</varname> annotation as described in Section 2.4.
        The presence of the remote interface tips Errai off as to what you
        want to do with the class.</para>
      </sect2>

      <sect2>
        <title>Making calls</title>

        <para>Calling a remote service involves use of the
        <varname>MessageBuilder</varname> API. Since all messages are
        asynchronous, the actual code for calling the remote service involves
        the use of a callback, which we use to receive the response from the
        remote method. Let's see how it works:</para>

        <programlisting>MessageBuilder.createCall(new RemoteCallback&lt;Boolean&gt;() {      
    public void callback(Boolean isHappy) {                   
         if (isHappy) Window.alert("Everyone is happy!");         
    }                                                           
}, MyRemoteService.class).isEveryoneHappy();        </programlisting>

        <para>In the above example, we declare a remote callback that receives
        a Boolean, to correpond to the return value of the method on the
        server. We also reference the remote interface we are calling, and
        directly call the method. However, <emphasis role="bold">don't be
        tempted to write code like this</emphasis>:</para>

        <programlisting>boolean bool = MessageBuilder.createCall(..., MyRemoteService.class).isEveryoneHappy();</programlisting>

        <para>The above code will never return a valid result. In fact, it
        will always return null, false, or 0 depending on the type. This is
        due to the fact that the method is dispatched asynchronously, as in,
        it does not wait for a server response before returning control. The
        reason we chose to do this, as opposed to emulate the native
        GWT-approach, which requires the implementation of remote and async
        interfaces, was purely a function of a tradeoff for simplicity.</para>
      </sect2>
    </sect1>

    <sect1>
      <title>Queue Sessions</title>

      <para>The ErraiBus maintains it's own seperate session management on-top
      of the regular HTTP session management. While the queue sessions are
      tied to, and dependant on HTTP sessions for the most part (meaning they
      die when HTTP sessions die), they provide extra layers of session
      tracking to make dealing with complex applications built on Errai
      easier. </para>

      <sect2>
        <title>Session Scopes</title>

        <para>One of the things Errai offers is the concept of session and
        local scopes. </para>

        <sect3>
          <title>Local Scope</title>

          <para>A local scope is scoped to a single browser instance. But not
          to a single session. </para>

          <para>In a browser a local scope would be confined to a tab or a
          window within a browser. You can store parameters inside a local
          scope just like with a session by using the
          <varname>LocalContext</varname> helper class.</para>

          <programlisting>public class TestService implements MessageCallback {           
    public void callback(final Message message) { 
        // obtain a reference to the local context by referencing the incoming message.
        LocalContext ctx = LocalContext.get(message); 

        // set an attribute.
        ctx.setAttribute("MyAttribute", "Foo");
    }
}              </programlisting>
        </sect3>

        <sect3>
          <title>Session Scope</title>

          <para>A session scope is scoped across all instances of the same
          session. When a session scope is used, any parameters stored will be
          accessible and visible by all browser instances and tabs. </para>

          <para>The SessionContext helper class is used for accessing the
          session scope.</para>

          <programlisting>public class TestService implements MessageCallback {           
    public void callback(final Message message) { 
        // obtain a reference to the session context by referencing the incoming message.
        SessionContext ctx = SessionContext.get(message); 

        // set an attribute.
        ctx.setAttribute("MyAttribute", "Foo");
    }
}   </programlisting>
        </sect3>
      </sect2>

      <sect2>
        <title>Lifecycle</title>

        <para>The lifescyle of a session is bound by the underlying HTTP
        session. It is also bound by activity thresholds. Clients are required
        to send heartbeat messages every once in a while to maintain their
        sessions with the server. If a heartbeat message is not received after
        a certain period of time, the session is terminated and any resources
        are deallocated.</para>
      </sect2>
    </sect1>

    <sect1>
      <title>Serialization</title>

      <para>Serialization on the ErraiBus supports serialization within the
      same scope and limitations as the default GWT RPC serialization rules.
      In order to expose your domain objects to the bus so they can be
      exported across the bus, you must annotate them with the
      <filename>org.jboss.errai.bus.server.annotations.ExposeEntity</filename>
      annotation. The presence of this annotation will cause Errai's GWT
      compiler extensions to generate marshall/demarshall stubs for the
      annotated objects at compile-time.</para>

      <para>For example:</para>

      <programlisting>

@ExposeEntity
public class User implements java.io.Serializable {
    private int userId;

    public int getUserId() {
        return userId;
    }

    public void setUserId(int userId) {
        this.userId = userId;
    }
 [...]
}
      </programlisting>

      <note>
        <para>All exposed entities must follow Java Bean convensions, and must
        be in the classpath both at compile-time and at runtime. Compile-time
        access to the entities is required since the creation of the
        marshalling/demarshalling proxies involves code generation.</para>
      </note>

      <para>.</para>

      <sect2>
        <title>Serialization of external types</title>

        <para>It may not be possible to annotate certain types you wish to
        expose to the bus for serialization if the entities are located in a
        third-party library that you do not maintain. As such, you can
        explicitly indicate in the configuration that you would like to have
        this entities made available by declaring them in the
        <varname>ErraiApp.properties</varname> of any module.</para>

        <programlisting>errai.bus.serializableTypes=org.foo.Foo \
                            org.bar.Bar \
                            org.foobie.Foobie</programlisting>
      </sect2>
    </sect1>

    <sect1 id="wiring">
      <title>Wiring server side components</title>

      <para>Currently, ErraiBus uses Google Guice to wire components. However,
      we plan on falling back on the <emphasis>JSR-330 Dependency
      Injection</emphasis> specification in the near future. When deploying
      services on the server-side, it is currently possible to obtain
      references to the <filename>MessageBus</filename>,
      <filename>RequestDispatcher</filename>, the
      <filename>ErraiServiceConfigurator</filename>, and
      <filename>ErraiService</filename> by declaring them as injection
      dependencies in Service classes, extension components, and session
      providers.</para>
    </sect1>

    <sect1>
      <title>Bus configuration</title>

      <para>This section contains information on configuring the server-side
      bus.</para>

      <sect2>
        <title>web.xml and app server configuration</title>

        <para>Depending on what application server you are deploying on, you
        must provide an appropriate servlet implementation if you wish to use
        true, asynchronous I/O. See <emphasis role="bold">section
        6.5</emphasis> for information on the available servlet
        implementations.</para>

        <para>Here's a sample web.xml file:</para>

        <programlisting>&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
		  http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
         version="2.5"&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;ErraiServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.jboss.errai.bus.server.servlet.DefaultBlockingServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;ErraiServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.erraiBus&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;errai.properties&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/errai.properties&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;login.config&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/login.config&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;users.properties&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/users.properties&lt;/param-value&gt;
    &lt;/context-param&gt;

&lt;/web-app&gt;</programlisting>
      </sect2>

      <sect2 id="bus-config">
        <title>ErraiService.properties</title>

        <para>The ErraiService.properties file contains basic configuration
        for the bus itself.</para>

        <para>Example Configuration:</para>

        <programlisting>
##
## Request dispatcher implementation (default is SimpleDispatcher)
##
#errai.dispatcher_implementation=org.jboss.errai.bus.server.SimpleDispatcher
errai.dispatcher_implementation=org.jboss.errai.bus.server.AsyncDispatcher


#
## Worker pool size.  This is the number of threads the asynchronous worker pool should provide for processing
## incoming messages. This option is only valid when using the AsyncDispatcher implementation.
##
errai.async.thread_pool_size=5

##
## Worker timeout (in seconds).  This defines the time that a single asychronous process may run, before the worker pool
## terminates it and reclaims the thread.   This option is only valid when using the AsyncDispatcher implementation.
##
errai.async.worker.timeout=5

##
## Specify the Authentication/Authorization Adapter to use
##
#errai.authentication_adapter=org.jboss.errai.persistence.server.security.HibernateAuthenticationAdapter
#errai.authentication_adapter=org.jboss.errai.bus.server.security.auth.JAASAdapter

##
## This property indicates whether or not authentication is required for all communication with the bus.  Set this
## to 'true' if all access to your application should be secure.
##
#errai.require_authentication_for_all=true



</programlisting>

        <sect3>
          <title>errai.dispatcher_implementation</title>

          <para>The <filename>errai.dispatcher_implementation</filename>
          defines, as it's name quite succinctly implies, the dispatcher
          implementation to be used by the bus. There are two implementations
          which come with Errai out of the box: the
          <filename>SimpleDispatcher</filename> and the
          <filename>AsyncDispatcher</filename>. See section on Dispatchers for
          more information about the differences between the two.</para>
        </sect3>

        <sect3>
          <title>errai.async_thread_pool_size</title>

          <para>Specifies the total number of worker threads in the worker
          pool for handling and delivering messages. Adjusting this value does
          not have any effect if you are using the SimpleDispatcher.</para>
        </sect3>

        <sect3>
          <title>errai.async_worker.timeout</title>

          <para>Specifies the total amount of a time (in seconds) a service
          has to finish processing an incoming message before the pool
          interrupts the thread and returns an error. Adjusting this value
          does not have an effect if you are using the
          SimpleDispatcher.</para>
        </sect3>

        <sect3>
          <title>errai.authentication_adapter</title>

          <para>Specifies the authentication adapter the bus should use for
          determining whether calls should be serviced based on authentication
          and security principles.</para>
        </sect3>

        <sect3>
          <title>errai.require_authentication_for_all</title>

          <para>Indicates whether or not the bus should always require the use
          of authentication for all requests inbound for the bus. If this is
          turned on, an authentication adapter must be defined, and any user
          must be authenticated before the bus will deliver any messages from
          the client to any service.</para>
        </sect3>

        <sect3>
          <title>errai.auto_scan_modules</title>

          <para>A boolean indicating whether or not the Errai bootstrapper
          should automatically scan for modules.</para>
        </sect3>
      </sect2>

      <sect2>
        <title>ErraiApp.properties</title>

        <para>The ErraiApp.properties acts as a marker file. When it is
        detected inside a JAR or at the top of any classpath, the
        subdirectories are scanned for deployable components. As such, all
        Errai application modules in a project should contain an
        ErraiApp.properties at the root of all classpaths that you wish to be
        scanned.</para>

        <para>The file can also include explicitly declared serializable types
        (such as those from third-party code) that cannot be annotated for
        serialization. (See the section on serialization for more
        details)</para>

        <sect3>
          <title>errai.bus.serializableTypes</title>

          <para>Defines a list of serializable types to expose to the
          bus.</para>

          <programlisting>errai.bus.serializableTypes=org.foo.Foo \
                            org.bar.Bar \
                            org.foobie.Foobie

</programlisting>
        </sect3>
      </sect2>

      <sect2>
        <title>Dispatchers</title>

        <para>Dispatchers encapsulate the strategy for taking messages that
        need to be delivered somewhere and seeing that they are delivered to
        where they need to go. There are two primary implementations that are
        provided with Errai, depending on your needs.</para>

        <sect3>
          <title>SimpleDispatcher</title>

          <para>SimpleDispatcher is basic implementation that provides no
          asychronous delivery mechanism. Rather, when you configure the Errai
          to use this implementation, messages are delivered to their
          endpoints synchronously. The incoming HTTP thread will be held open
          until the messages are delivered.</para>

          <para>While this sounds like it has almost no advantages, especially
          in terms of scalablity. Using the SimpleDispatcher can be far
          preferable when you're developing your application, as any errors
          and stack traces will be far more easily traced and some cloud
          services may not permit the use of threads in any case.</para>
        </sect3>

        <sect3>
          <title>AsyncDispatcher</title>

          <para>The AsyncDispatcher provides full asynchronous delivery of
          messages. When this dispatcher is used, HTTP threads will have
          control immediately returned upon dispatch of the message. This
          dispatcher provides far more efficient use of resources in high-load
          applications, and will significantly decrease memory and thread
          usage overall.</para>
        </sect3>
      </sect2>

      <sect2>
        <title>Servlet Implementations</title>

        <para>Errai has many several different implementations for HTTP
        traffic to and from the bus. We provide a universally-compatible
        blocking implementation that provides fully synchronous communication
        to/from the server-side bus. Where this introduces scalability
        problems, we have implemented many webserver-specific implementations
        that take advantage of the various proprietary APIs to provide true
        asynchrony.</para>

        <para>These inlcuded implementations are packaged at:
        <varname>org.jboss.errai.bus.server.servlet</varname></para>

        <sect3>
          <title>DefaultBlockingServlet</title>

          <para>This is a universal, completely servlet spec compliant,
          Servlet implementation. It provides purely synchronous request
          handling and should work in virtually any servlet container, unless
          there are restrictions on putting threads into sleep states.</para>
        </sect3>

        <sect3>
          <title>TomcatCometServlet</title>

          <para>The Tomcat AIO implementation of our servlet allows Errai to
          take advantage of Tomcat's event-based AIO APIs to improve
          scalability and reduce thread usage. The use of this implementation
          is dependant on the Tomcat container being configured to support AIO
          using either it's NIO or APR connectors. This servlet will NOT work
          with the regular HTTP and AJP connectors.</para>
        </sect3>

        <sect3>
          <title>JettyContinuationsServlet</title>

          <para>The Jetty implementation leverages Jetty's continuations
          support, which allows for threadless pausing of port connections.
          This servlet implementation should work without any special
          configuration of Jetty.</para>
        </sect3>

        <sect3>
          <title>JBossCometServlet</title>

          <para>The JBoss Comet support utilizes the JBoss Web AIO APIs to
          improve scalability and reduce thread usage. The HTTP, NIO, and AJP
          connectors are not supported. Use of this implementation requires
          use of the APR (Apache Portable Runtime).</para>
        </sect3>

        <sect3>
          <title>GrizzlyCometServlet</title>

          <para>Support for the comet API in the Grizzy HTTP server (used in
          Glassfish).</para>
        </sect3>

        <sect3>
          <title>WeblogicAsyncServlet</title>

          <para>Support for the Weblogic asynchronous APIs.</para>
        </sect3>
      </sect2>
    </sect1>

    <sect1>
      <title>Debugging Errai Applications</title>

      <para>Errai includes a bus monitoring application, which allows you to
      monitor all of the message exchange activity on the bus in order to help
      track down any potential problems It allows you to inspect individual
      messages to examine their state and structure.</para>

      <para>To utilize the bus monitor, you'll need to include the <emphasis
      role="bold">errai-tools</emphasis> package as part of your application's
      dependencies. When you run your application in development mode, you
      will simply need to add the following JVM options to your run
      configuration in order to launch the monitor:
      <varname>-Derrai.tools.bus_monitor_attach=true </varname></para>

      <figure>
        <title>Bus Monitor</title>

        <screenshot>
          <screeninfo>The main monitor application window</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/MonitorOverview.png" />
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The monitor provides you a real-time perspective on what's going
      on inside the bus. The left side of the main screen lists the services
      that are currently available, and the right side is the
      service-explorer, which will show details about the service.</para>

      <para>To see what's going on with a specific service, simply
      double-click on the service or highlight the service, then click
      "Monitor Service...". This will bring up the service activity
      monitor.</para>

      <para></para>

      <figure>
        <title>Service Activity Monitor</title>

        <screenshot>
          <screeninfo></screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/MonitorOverview2.png" />
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The service activity monitor will display a list of all the
      messages that were transmitted on the bus since the monitor became
      active. You do not need to actually have each specific monitor window
      open in order to actively monitor the bus activity. All activity on the
      bus is recorded.</para>

      <para>The monitor allows you select individual messages, an view their
      individual parts. Clicking on a message part will bring up the object
      inspector, which will allow you to explore the state of any objects
      contained within the message, not unlike the object inspectors provided
      by debuggers in your favorite IDE. This can be a powerful tool for
      looking under the covers of your application.</para>
    </sect1>
  </chapter>

  <chapter id="workspaces">
    <title>Errai Workspaces</title>

    <sect1>
      <title>What is workspaces?</title>

      <para>ErraiWorkspaces provides a fully managed working UI enviroment for
      which to deploy your console and tooling. Put more succinctly: we
      provide you the places. All you need to do is put stuff there.</para>

      <sect2>
        <title>Basic concepts</title>

        <para>It's good to start with an explanation of the basic workspace
        concepts and terminlogy that we chose for it.</para>

        <para>A workspace, in our term, is basically a collection of tools.
        Each tool serves a distinct purpose and can represent anything you
        like. The workspace manages the tools (or tool sets) and access to
        them. This includes loading and initialization, history, preferences
        and authorization amongst other things. Usually tools rely on the
        message bus for inter component communication as well as backend
        integration. But they are not tight to that. Workspaces makes no
        assumption about the implementation of your tool, it merely provides
        the glue to keep everything together.</para>
      </sect2>

      <sect2>
        <title>Sandbox</title>

        <para>Workspaces goes beyond simple API. It's not just another GWT
        module. It was designed to get you started quickly, without getting in
        your way. This includes the environment to build, deploy and test your
        tools. We've decided to use maven to provide these capabilities. It
        allows you to quickly get started (see <link
        linkend="quickstart">Maven archetype</link>), but more importantly,
        maven repositories are used to share tool implementations across
        workspace assemblies. This way you can easily combine your own and 3rd
        party tools as part of a custom workspace compilation. <note>
            <para>The GWT SDK is already part of the sandbox bootstrap. You
            get everything to get going within minutes: GWT, Errai and 3rd
            party libraries.</para>
          </note></para>
      </sect2>
    </sect1>

    <sect1 id="workspace-api">
      <title>Workspace API</title>

      <para>To begin with, we'll look at some examples how to declare tool
      sets and launch them in a workspace.</para>

      <sect2>
        <title>Declaring and implementing tools</title>

        <para>Tools are declared through the @LoadToolSet annotation. This
        instructs the workspace to generate all the boiler plate to wire your
        tools with the workspace. A tool needs to implement the WidgetProvider
        interface. It's used by the workspace to instruct the tool to create
        it's UI widget when needed. This widget will then be embedded in the
        workspace. <programlisting>
@LoadTool(name = "Users", group = "Administration")                          (1)
public class UserManagement implements WidgetProvider
{

  public void provideWidget(final ProvisioningCallback callback) {           (2)
    callback.onSuccess(new UserManagementWidget());
  }

  class UserManagementWidget extends LayoutPanel                             (3)
  {
      [...]
  }
}
  </programlisting> <orderedlist>
            <listitem>
              <para>Toolset declaration including the name and group this tool
              belongs to</para>
            </listitem>

            <listitem>
              <para>The WidgetProvider implementation is manadatory.</para>
            </listitem>

            <listitem>
              <para>In this example our widget is LayoutPanel with unknown
              contents. The implementation is up to you.</para>
            </listitem>
          </orderedlist></para>
      </sect2>

      <sect2 id="rolebased">
        <title>Authorization and access to tools</title>

        <para>Workspaces relies on a authentication scheme similiar to JAAS.
        It ships with different authentication modules (i.e. Hibernate, JAAS)
        that enable role based access to tools on the client side and services
        on the server side. <programlisting>
@LoadTool(name = "Inventory", group = "Administration")                (1)
@RequireRoles({"admin"})                                               (2)
public class Inventory implements WidgetProvider
{

    public void provideWidget(final ProvisioningCallback callback)     (3)
    {
        [...]
    }

}

</programlisting> <orderedlist>
            <listitem>
              <para>A tool declaration</para>
            </listitem>

            <listitem>
              <para>It restricts access to the role 'admin'</para>
            </listitem>

            <listitem>
              <para>Implements the default WidgetProvider interface which will
              only be invoked when the principal is authorized to access this
              tool.</para>
            </listitem>
          </orderedlist></para>
      </sect2>

      <sect2>
        <title>Common coding pattern</title>

        <para>It's common to use the WidgetProvider API in a way that <ulink
        url="http://code.google.com/p/google-web-toolkit/wiki/CodeSplitting">GWT
        2.0 code splitting</ulink> can kick in. This allows true lazy loading
        of tools upon demand, including all .js and resources necessary to run
        your tools: <programlisting>
@LoadTool(name = "Group Tasks", group = "Tasks")
public class OpenTasksModule implements WidgetProvider
{
    static OpenTasksView instance = null;

    public void provideWidget(final ProvisioningCallback callback)
    {
        GWT.runAsync(
            new RunAsyncCallback()
            {
              public void onFailure(Throwable err)
              {
                GWT.log("Failed to load tool", err);
              }

              public void onSuccess()
              {
                if (instance == null) {
                  instance = new OpenTasksView();  // your tool here
                }
                callback.onSuccess(instance);
              }
            }

        );
    }
}

</programlisting></para>
      </sect2>
    </sect1>

    <sect1>
      <title>Core features</title>

      <para>The workspace itself doesn't require any attention apart from the
      common API that is decribed in the chapter <link
      linkend="workspace-api">"Workspace API"</link>. Still, in some cases you
      may need to go beyond the out-of-the-box functionlity. In this chapter
      we are going to explain the building blocks used in the workspace
      implementation and how they can be used to replace or extend the default
      workspace behaviour.</para>

      <sect2 id="workspace-registry">
        <title>Workspace Registry</title>

        <para>The workspace registry
        (org.jboss.errai.workspaces.client.framework.Registry) is a simple all
        purpose lookup for common workspace API that is available to any
        workspace component: <programlisting>
AuthenticationContext authenticationContext =
    Registry.get(SecurityService.class).getAuthenticationContext();    
</programlisting></para>
      </sect2>

      <sect2>
        <title>Authentication and Authorization</title>

        <para>The workspace itself doesn't provide an authentication
        component. Instead it relies on the Authentication provided by errai
        bus. When the workspace is loaded two thing happen: The workspace
        checks if authentication is required and, after authentication if
        needed, loads the tool sets.</para>

        <para>The bus component in charge is the SecurityService
        (org.jboss.errai.bus.client.security.SecurityService). It is available
        through <link linkend="workspace-registry">workspace Registry</link>.
        For people extending the workspace functionality it offers two
        intersting options: <itemizedlist>
            <listitem>
              <para>Obtain access to the authentication context (username,
              roles, etc)</para>
            </listitem>

            <listitem>
              <para>Deferred workspace assembly</para>
            </listitem>
          </itemizedlist> The later is important of you want to provide your
        own way of authenticating users, but still use the <link
        linkend="rolebased">role based authorization</link> build into
        workspaces. <note>
            <para>Don't mess with the authentication unless you now what you
            are doing. In many cases it might be better to extend the server
            side authentication adapters instead of overriding the client
            behaviour. However for the sake of completeness, this mechanism
            should be mentioned here.</para>
          </note></para>
      </sect2>

      <sect2>
        <title>LoginClient</title>

        <para>The LoginClient is the counter part of the SecurityService. It
        is instructed by the SecurityService to request the credentials upon
        demand. This typically happens when the workspace is initialized, but
        might also occur later on, when a particular service requires a
        different role set, then the one assigned initially. We call this
        elevation. Similiar to the operating system of your choice that
        demands administrator priviledges for certain operations.</para>

        <para>After the initial authentication (or lack of) the LoginClient
        instructs the actual workspace to assemble the tool sets.</para>
      </sect2>

      <sect2>
        <title>History management and perma links</title>

        <para>History is build into the workspace. It's wired to the main
        navigation and allows to use the browser navigation to switch between
        previously selected tools. In addition to that, the same mechanism can
        be used to perma link tools from external applications. I.e. when
        notifying users, using an email that contains a link back to a
        particular tool.</para>
      </sect2>

      <sect2>
        <title>Preferences</title>

        <para>The workspace allows you to store simple key-value pairs as
        preferences. Like with other common API, you obtain the Preferences
        through the <link linkend="workspace-registry">workspace
        Registry</link>. The default implementation uses a cookie based
        approach, but it's easy to replace that one with a custom
        implementation in the module decriptor: <programlisting>
    
   &lt;module&gt;
    [...]
    &lt;replace-with class="org.jboss.errai.workspaces.client.framework.CookiePreferences"&gt;
           &lt;when-type-is class="org.jboss.errai.workspaces.client.framework.Preferences"/&gt;
       &lt;/replace-with&gt;
    &lt;/module&gt;
    
</programlisting></para>
      </sect2>
    </sect1>

    <sect1 id="using-workspaces">
      <title>Building a workspaces application</title>

      <para>In this section we go through the steps necessary to create a
      workspace application. As mentioned before, workspaces is more then just
      another GWT library. It's intended to get you started quickly. This
      includes GWT installation, creating a build environment and prepapring
      your IDE.</para>

      <sect2>
        <title>Check the prerequisites</title>

        <para>You need <ulink url="http://maven.apache.org">Apache
        Maven</ulink> and a <ulink
        url="http://java.sun.com/javase/downloads/index.jsp">JDK</ulink> to
        get started.</para>
      </sect2>

      <sect2>
        <title>Setup a build environent</title>

        <para>The most simple (and least error prone) way to get started is
        using the maven archetype that we ship as part of errai. Simply follow
        the instructions in the <link linkend="quickstart">quickstart</link>
        section and return here when you are done.</para>

        <para>Once you've created a project using the maven archetype, make
        yourself familiar with the directory structure: <programlisting>
Laika:gwt-app hbraun$ lstree
| pom.xml    
|-src
|---main
|-----java
|-------foo
|---------bar
|-----------client
|-----------server
|-war
|---WEB-INF
</programlisting> It basically follows the default GWT guidelines for breaking
        up code between client and server. Simply put tools (@LoadToolSet)
        into the client subpackage and services (@Service) into the server
        subpackages. Make sure you are familiar with the <link
        linkend="workspace-api">Workspace API</link> before you
        continue.</para>
      </sect2>

      <sect2>
        <title>Verify the application configuration</title>

        <para>Several configuration files drive a workspace build and the
        final application. Make sure to include all of them when porting the
        archetype example to a different GWT application: <programlisting>
 ./src/main/java/ErraiApp.properties
 ./src/main/java/ErraiService.properties
 ./src/main/java/my/app/App.gwt.xml   
</programlisting> <orderedlist>
            <listitem>
              <para>ErraiApp.properties is a simple marker, that is required
              for the annotation processing to discover your modules. This is
              especially important when you declare maven dependencies on tool
              or service implementations. Make sure that any classpath entry
              (i.e. dependency jar) contains an ErraiApp.properties file.
              Otherwise errai might not be able to discover your
              components.</para>
            </listitem>

            <listitem>
              <para>ErraiService.properties is the primary bus configuration.
              Details can be found in the chapter <link
              linkend="bus-config">bus configuration.</link></para>
            </listitem>

            <listitem>
              <para>App.gwt.xml is your applications <ulink
              url="http://code.google.com/webtoolkit/doc/latest/DevGuideOrganizingProjects.html#DevGuideModules">module
              descriptor</ulink>. <programlisting>
 
&lt;module rename-to="app"&gt;
 &lt;inherits name='com.google.gwt.user.User'/&gt;
 &lt;inherits name="com.google.gwt.uibinder.UiBinder"/&gt;
 &lt;inherits name="com.google.gwt.resources.Resources" /&gt;

 &lt;inherits name="org.jboss.errai.common.ErraiCommon"/&gt;
 &lt;inherits name="org.jboss.errai.bus.ErraiBus"/&gt;
 &lt;inherits name="org.jboss.errai.workspaces.ErraiWorkspaces" /&gt;
 
 &lt;entry-point class='my.app.client.HelloWorldClient'/&gt;

&lt;/module&gt;
    
</programlisting> If you are building on workspaces make sure to include it's
              dependencies common and bus as well.</para>
            </listitem>
          </orderedlist></para>
      </sect2>

      <sect2>
        <title>Launch the hosted mode and start developing</title>

        <para>If you followed the steps above, and did build your application
        stub using the maven archetype, then you should be launch the <ulink
        url="http://code.google.com/webtoolkit/doc/latest/DevGuideCompilingAndDebugging.html#DevGuideDevMode">GWT
        hosted mode</ulink> with the following commands: <programlisting>
  mvn gwt:run

 (alternatively)   
  mvn gwt:debug
</programlisting> <note>
            <title>Launching maven the first time</title>

            <para>Please note, that when launching maven the first time on
            your machine, it will fetch all dependecies from a central
            repository. This may take a while, because it includes downloading
            large binaries like GWT SDK. However subsequent builds are not
            required to go through this step and will be much faster.</para>
          </note></para>
      </sect2>
    </sect1>
  </chapter>

  <chapter id="quickstart">
    <title>Appendix A: Quickstart</title>

    <section id="quickstart-intro">
      <title>Using the maven archetype</title>

      <para>If you have taken a look at the examples that ship with the
      distribution, you realized that we use maven to build them. The way it
      is setup, the maven build has several benefits: <itemizedlist>
          <listitem>
            <para>It pulls the GWT from a central repository. No need for
            manual installation of the SDK</para>
          </listitem>

          <listitem>
            <para>It provides us with the proper dependencies in order to run
            the examples</para>
          </listitem>

          <listitem>
            <para>IDE setup is greatly simplfied, since most modern IDE's can
            directly import the maven structure</para>
          </listitem>
        </itemizedlist> In order to get you going quickly, we've provided a
      project archetype, that allows you to create a project skeleton similiar
      to the one we use for building the examples. It's based on the maven
      archetype plugin <footnote>
          <para>http://maven.apache.org/plugins/maven-archetype-plugin/</para>
        </footnote> and needs to be invoked from the command line:
      <programlisting>
    mvn archetype:generate \
        -DarchetypeGroupId=org.jboss.errai \
        -DarchetypeArtifactId=sandbox-archetype \
        -DarchetypeVersion=1.1-SNAPSHOT \
        -DarchetypeRepository=https://repository.jboss.org/nexus/content/groups/public/
            </programlisting> When invoking the archetype build it ask you
      about the maven groupId, artifactId and package name your GWT
      application should use: <programlisting>
    Define value for groupId: : <emphasis>foo.bar</emphasis>
    Define value for artifactId: : <emphasis>gwt-app</emphasis>
    Define value for version:  1.0-SNAPSHOT: :
    Define value for package:  foo.bar: : <emphasis>foo.bar.ui</emphasis>
    Confirm properties configuration:
    groupId: foo.bar
    artifactId: gwt-app
    version: 1.0-SNAPSHOT
    package: foo.bar.ui
    Y: : <emphasis>Y</emphasis>
            </programlisting> What will be created for you, is a maven build
      structure, including references to the GWT SDK and the Errai
      dependencies necessary to launch a simple application: <programlisting>
    Laika:test hbraun$ cd gwt-app/
    Laika:gwt-app hbraun$ lstree
    |-src
    |---main
    |-----java
    |-------foo
    |---------bar
    |-----------client
    |-----------server
    |-war
    |---WEB-INF
            </programlisting> In order launch the GWT hosted mode, change into
      the project directory and type: <programlisting>
    mvn gwt:run
            </programlisting> The default project includes both a HelloWorld
      client (GWT), and a HelloWorld service.</para>
    </section>
  </chapter>
</book>
