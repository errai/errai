<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<?asciidoc-numbered?>

<book lang="en">
  <bookinfo>
    
    <title>Errai Reference Guide</title>
    
    
    <date>2021-08-12</date>
    
    
    
    

    
    

  </bookinfo>
<chapter id="sid-5833084">
<title>Introduction</title>
<section id="sid-5833083">
<title>What is it?</title>
<simpara>Errai is a GWT-based framework for building rich web applications using next-generation web technologies. Built on-top of ErraiBus, the framework provides a unified federation and RPC infrastructure with true, uniform, asynchronous messaging across the client and server.</simpara>
</section>
<section id="sid-5833091">
<title>Required software</title>
<simpara>Errai requires a JDK version 6 or higher and depends on Apache Maven to build and run the examples, and for leveraging the quickstart utilities.</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>JDK 6.0: <ulink url="http://java.sun.com/javase/downloads/index.jsp">http://java.sun.com/javase/downloads/index.jsp</ulink></simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Apache Maven: <ulink url="http://maven.apache.org/download.html">http://maven.apache.org/download.html</ulink></simpara>
      
    </listitem>
  
</itemizedlist>

</section>
<section id="sid-54493220">
<title>Getting Started with Errai</title>
<simpara>Errai is a framework which combines a constellation of web and server-side technologies to assist you in developing large, scaleable rich web applications using a consistent, standardized programming model for client and server development.</simpara>
<section id="sid-54493220_GettingStartedwithErrai-TechnologyPrimer">
<title>Technology Primer</title>
<simpara>Since Errai is an end-to-end framework, in that, parts of the framework run and operate within the client and parts run and operate within the server, there is a set of various technologies upon which Errai relies. This section will detail the basic core technologies which you&#8217;ll need to be familiar with.</simpara>
<section id="sid-54493220_GettingStartedwithErrai-GoogleWebToolkit%28GWT%29">
<title>Google Web Toolkit (GWT)</title>
<simpara>GWT is a toolkit built around a Java-to-JavaScript compiler. It provides a JRE emulation library, abstraction of browser quirks, a development mode runtime, and tools for native JavaScript integration.</simpara>
<simpara>Errai uses GWT to accomplish the translation of concepts such as CDI into the browser, which enables a consistent client and server programming experience.</simpara>
</section>
<section id="sid-54493220_GettingStartedwithErrai-ContextsandDependencyInjection%28CDI%29">
<title>Contexts and Dependency Injection (CDI)</title>
<simpara>CDI is a standard part of the Java EE 6.0 stack, and is defined in the <ulink url="https://jcp.org/en/jsr/detail?id=299">JSR-299</ulink> specification. CDI is the main programming model explored in this guide. As such, the basic concepts of CDI will be introduced in this guide, so pre-existing knowledge is not strictly necessary.</simpara>
<simpara>Errai&#8217;s support for CDI is two-fold. For the server-side, Errai has integration with Weld, which is the reference implementation (RI) of the JSR-299 specification. The client-side integration for CDI is provided by the Errai CDI extension. Errai CDI implements a subset of the JSR-299 specification to provide the CDI programming model within client code.</simpara>
</section>
<section id="sid-54493220_GettingStartedwithErrai-JavaAPIforRESTfulWebServices%28JAXRS%29">
<title>Java API for RESTful Web Services (JAX-RS)</title>
<simpara>JAX-RS is an API which provides a standardized programming model for specifying web services based around the concept of the Representational State Transfer (REST) architecture. REST has by and far become the preferred way of developing web services, and is used pervasively in modern web applications. Errai provides a set of tools to make working with JAX-RS easier.</simpara>
</section>
<section id="sid-54493220_GettingStartedwithErrai-ErraiBus">
<title>ErraiBus</title>
<simpara>ErraiBus is an underlying transport technology which provides true, bidirectional, asynchronous messaging between the client and the server. It powers a myriad of technologies throughout the Errai framework, from RPC to CDI Events.</simpara>
</section>
</section>
<section id="sid-54493220_GettingStartedwithErrai-Creatingyourfirstproject">
<title>Creating your first project</title>
<important>
<title>Maven Required</title>
<simpara>The first thing you&#8217;ll need to do if you have not already, is <ulink url="http://maven.apache.org/guides/getting-started/maven-in-five-minutes.html">install Maven</ulink>. If you have not already installed Maven, do so now.</simpara>
<simpara>Warning: If you use maven2, you will run into this problem: <ulink url="https://community.jboss.org/thread/177645">https://community.jboss.org/thread/177645</ulink></simpara>
</important>
<simpara>You have two options to set up an Errai application. You can start by copying an existing example application (i.e. the <ulink url="https://github.com/errai/errai-tutorial/archive/main.zip">errai tutorial demo</ulink>) or by building an app with the Errai Forge Addon:</simpara>
<section id="sid-54493220_GettingStartedwithErrai-Startfromaworkingexampleapplication">
<title>Start from a working example application</title>
<simpara>Simply download and unzip this <ulink url="https://github.com/errai/errai-tutorial/archive/main.zip">demo</ulink>. Check out the README file and continue with running the app in <link linkend="sid-54493220_GettingStartedwithErrai-RunningtheappinGWT">GWT&#8217;s development mode</link> and importing the project into <link linkend="sid-54493220_GettingStartedwithErrai-ConfiguringyourprojectforEclipse">Eclipse</link>.</simpara>
</section>
<section id="sid-54493220_GettingStartedwithErrai-ErraiForgeAddon">
<title>Starting with the Errai Forge Addon</title>
<warning>
<title>Deprecated</title>
<simpara>The Errai Forge Addon is deprecated. It is no longer being updated and will be removed in a future release.</simpara>
</warning>
<simpara>Another way to start a new project with Errai is to use Forge and the Errai Forge Addon. To use this method, follow the instructions <ulink url="https://github.com/errai/errai/blob/main/errai-forge-addon/README.asciidoc">here</ulink> to install the Errai Forge Addon and create a new project.</simpara>
<simpara>In the upcomming sections, we will demonstrate how to run your app in GWT Development Mode through the command line and eclipse, so it would be nice to have something to run so that you are able to verify that everything is working. Here is a sample class you can use that displays an alert when the app loads:</simpara>
<programlisting language="java" linenumbering="unnumbered">// Add the package declaration here

import javax.annotation.PostConstruct;
import org.jboss.errai.ioc.client.api.EntryPoint;
import com.google.gwt.user.client.Window;

@EntryPoint
public class App {

  @PostConstruct
  public void onLoad() {
    Window.alert("Hello World!");
  }
}</programlisting>
<simpara>For this code to run properly, you must use the Errai Forge Addon <emphasis>Add Errai Features</emphasis> command to install <emphasis>Errai IOC</emphasis>.</simpara>
<simpara>Create new subfolder, <emphasis>client/local</emphasis>, under the folder containing your GWT module file. Then create a file, <emphasis>App.java</emphasis>, in this new package and copy the above sample code (making sure to replace the top comment with the package declaration).</simpara>
</section>
</section>
<section id="sid-54493220_GettingStartedwithErrai-RunningtheappinGWT">
<title>Running and Debugging with GWT&#8217;s Super Dev mode</title>
<simpara>As of GWT 2.7, we use Super Dev Mode to run your app in hosted mode during development. <ulink url="http://www.gwtproject.org/doc/latest/DevGuideCompilingAndDebugging.html#DevGuideDevMode">GWT&#8217;s Super Dev Mode</ulink> allows for code-refresh development cycles. Simply change a client-side class and refresh the browser to see your changes. You can also debug client and server side code in your IDE of choice. These sections will describe how to use Super Dev Mode to develop and debug your web app.</simpara>
<section id="_running_the_app_in_gwt">
<title>Running the app in GWT</title>
<simpara>Change into your web app&#8217;s project directory and type the following:</simpara>
<screen>mvn clean gwt:run</screen>
<simpara>This will begin the download of all the dependencies required to develop with and run Errai. It may take a few minutes to complete the download.</simpara>
<simpara>When it is finished, you should see the GWT Development Mode runtime window appear as shown in <emphasis>Figure 1</emphasis>.</simpara>
<figure id="img-gwt-dev">
<title>GWT Development Mode</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/DevModeWindows.png"/>
    </imageobject>
    <textobject><phrase>DevModeWindows</phrase></textobject>
  </mediaobject>
</figure>
<simpara>Next, click the <emphasis>Launch Default Browser</emphasis> button. You should now see the application load.</simpara>
<simpara>If you are using errai-tutorial, you should see a page with a complaint form.</simpara>
<simpara>If you followed the instructions for using the Errai Forge plugin, there should be a blank page with an alert saying "Hello World!".</simpara>
<simpara>That&#8217;s it! You&#8217;ve got your first Errai Application up and running. The next sections will describe how to set up your app with your IDE.</simpara>
</section>
<section id="sid-54493220_GettingStartedwithErrai-ConfiguringyourprojectforEclipse">
<title>Debugging the app in GWT</title>
<simpara>To debug your app using GWT&#8217;s development mode, you will need to start a remote debugger separately and run the following command in your project directory:</simpara>
<screen>mvn clean gwt:debug</screen>
</section>
</section>
<section id="_running_and_debugging_in_eclipse_using_maven_tooling">
<title>Running and Debugging in Eclipse using Maven tooling</title>
<simpara>There are two ways to configure your project in your IDE. One option is to use the built-in Maven tooling to set up Maven run and debug configurations within your IDE. The other option is to download and use GWT tooling that is available for your IDE, and create custom run/debug configurations with that. Note that for Intellij IDEA, the GWT tooling is only available for users of the Ultimate Edition.</simpara>
<note>
<title>Read the previous section!</title>
<simpara>This next section assumes you have followed the instructions in the previous section. As such, we assume you have created an Errai project using the Errai Forge plugin or a copy of the errai-tutorial project, which we&#8217;ll be importing into your IDE.</simpara>
</note>
<section id="sid-54493220_GettingStartedwithErrai-Prerequisites">
<title>Prerequisites</title>

</section>
<section id="sid-54493220_GettingStartedwithErrai-MavenIntegrationforEclipse%28m2e%29">
<title>Maven Integration for Eclipse (m2e)</title>
<simpara>This section will walk you through using Maven tooling for running and debugging your app within Eclipse. If you have not already installed m2e in Eclipse, you will want to do so now.</simpara>
<simpara>To install the Maven tooling, use the following steps:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>Go to the <emphasis>Eclipse Marketplace</emphasis> under the <emphasis>Help</emphasis> menu in Eclipse.</simpara>
      
<figure>
<title>Eclipse Marketplace</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/EclipseM2eStep1.PNG"/>
    </imageobject>
    <textobject><phrase>EclipseM2eStep1</phrase></textobject>
  </mediaobject>
</figure>

      
    </listitem>
  
    <listitem>
      <simpara>In the <emphasis>Find</emphasis> dialog enter the phrase <emphasis>Maven</emphasis> and hit enter.</simpara>
      
<figure>
<title>Find Dialog</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/EclipseM2eStep2.PNG"/>
    </imageobject>
    <textobject><phrase>EclipseM2eStep2</phrase></textobject>
  </mediaobject>
</figure>

      
    </listitem>
  
    <listitem>
      <simpara>Find the <emphasis>Maven Integration for Eclipse</emphasis> plugin and click the <emphasis>Install</emphasis> button for that entry.</simpara>
      
<figure>
<title>Maven Integration for Eclipse in Marketplace</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/EclipseM2eStep3.PNG"/>
    </imageobject>
    <textobject><phrase>EclipseM2eStep3</phrase></textobject>
  </mediaobject>
</figure>

      
    </listitem>
  
    <listitem>
      <simpara>Accept the defaults by clicking <emphasis>Next</emphasis>, and then accept the User License Agreement to begin the installation.</simpara>
      
    </listitem>
  
</orderedlist>
</section>
<section id="sid-54493220_GettingStartedwithErrai-Importingyourproject">
<title>Importing your project</title>
<simpara>Once you have completed the installation of the prerequisites from the previous section, you will now be able to go ahead and import the Maven project you created in the first section of this guide. We will use the errai-tutorial project as an example.</simpara>
<simpara>Follow these steps to get the project setup:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>From the <emphasis>File</emphasis> menu, select <emphasis>Import&#8230;</emphasis></simpara>
      
<figure>
<title>Import File in Eclipse</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/Import1.PNG" contentwidth="650"/>
    </imageobject>
    <textobject><phrase>Import1</phrase></textobject>
  </mediaobject>
</figure>

      
    </listitem>
  
    <listitem>
      <simpara>You will be presented with the Import dialog box. From here you want to select <emphasis>Maven</emphasis> &#8594; <emphasis>Existing Maven Projects</emphasis></simpara>
      
<figure>
<title>Import Existing Maven Project</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/Import2.PNG" contentwidth="650"/>
    </imageobject>
    <textobject><phrase>Import2</phrase></textobject>
  </mediaobject>
</figure>

      
    </listitem>
  
    <listitem>
      <simpara>From the <emphasis>Import Maven Projects</emphasis> dialog, you will need to select the directory location of the project you created in the first section of this guide. In the <emphasis>Root Directory</emphasis> field of the dialog, enter the path to the project, or click <emphasis>Browse&#8230;</emphasis> to select it from the file chooser dialog.</simpara>
      
<figure>
<title>Select Folder</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/Import3.PNG" contentwidth="650"/>
    </imageobject>
    <textobject><phrase>Import3</phrase></textobject>
  </mediaobject>
</figure>

      
    </listitem>
  
    <listitem>
      <simpara>Click <emphasis>Finish</emphasis> to begin the import process.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>When the import process has finished, you should see your project imported within the Eclipse <emphasis>Project Explorer</emphasis>. If you are using errai-tutorial, the <literal><phrase role="code">App</phrase></literal> class should be visible within the <literal><phrase role="code">client</phrase></literal> package.</simpara>
      
<figure>
<title>App.java</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/Import4.PNG" contentwidth="650"/>
    </imageobject>
    <textobject><phrase>Import4</phrase></textobject>
  </mediaobject>
</figure>

      
    </listitem>
  
</orderedlist>
</section>
<section id="_running_development_mode_with_eclipse">
<title>Running Development Mode with Eclipse</title>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>Next you will need to setup a Maven Run Profile for Development Mode. To do so select <emphasis>Run As&#8230;</emphasis> &gt; <emphasis>Run Configurations&#8230;</emphasis> from the toolbar.</simpara>
      
<figure>
<title>Run Configurations</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/RunConfigurations.PNG" contentwidth="650"/>
    </imageobject>
    <textobject><phrase>RunConfigurations</phrase></textobject>
  </mediaobject>
</figure>

      
    </listitem>
  
    <listitem>
      <simpara>Select <emphasis>Maven Build</emphasis> from the sidebar and create a new launch configuration by pressing the <emphasis>New</emphasis> button in the top left corner.</simpara>
      
<figure>
<title>New Configuration</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/NewLaunchConfiguration.PNG" contentwidth="650"/>
    </imageobject>
    <textobject><phrase>NewLaunchConfiguration</phrase></textobject>
  </mediaobject>
</figure>

      
    </listitem>
  
    <listitem>
      <simpara>Give the configuration a name, then click <emphasis>Browse Workspace</emphasis> and select the root directory of your new project.</simpara>
      
<figure>
<title>Select Project Root Directory</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/LaunchRootDir.PNG" contentwidth="650"/>
    </imageobject>
    <textobject><phrase>LaunchRootDir</phrase></textobject>
  </mediaobject>
</figure>

      
    </listitem>
  
    <listitem>
      <simpara>In the <emphasis>Goals</emphasis> text box, type "clean gwt:run". Click <emphasis>Apply</emphasis> to save the configuration and then <emphasis>Close</emphasis>.</simpara>
      
<figure>
<title>Run Configurations Goals</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/GwtRunGoals.PNG" contentwidth="650"/>
    </imageobject>
    <textobject><phrase>GwtRunGoals</phrase></textobject>
  </mediaobject>
</figure>

      
    </listitem>
  
    <listitem>
      <simpara>You can add this new configuration under the <emphasis>Run As</emphasis> button in your toolbar by selecting <emphasis>Run As</emphasis> &gt; <emphasis>Organize Favorites</emphasis>, then clicking <emphasis>Add</emphasis> and selecting the run configuration.</simpara>
      
<figure>
<title>Add Configuration to Favourites</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/OrganizeFavourites.PNG" contentwidth="650"/>
    </imageobject>
    <textobject><phrase>OrganizeFavourites</phrase></textobject>
  </mediaobject>
</figure>

      
    </listitem>
  
    <listitem>
      <simpara>At this point, you should try running your new configuration to make sure everything is in working order. To run your app, find the run configuration under the <emphasis>Run As</emphasis> menu in the toolbar.</simpara>
      
<figure>
<title>Run GWT Development Mode from Eclipse</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/UseGwtRunConfiguration.PNG" contentwidth="650"/>
    </imageobject>
    <textobject><phrase>UseGwtRunConfiguration</phrase></textobject>
  </mediaobject>
</figure>

      
    </listitem>
  
</orderedlist>
<simpara>This will start the GWT Development Mode exactly as running <literal>mvn clean gwt:run</literal> from the command line.</simpara>
</section>
<section id="_debugging_in_development_mode_with_eclipse">
<title>Debugging in Development Mode with Eclipse</title>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>To setup a debug run configuration for GWT Development Mode, repeate steps (2) and (3) from the section above, but this time use the <emphasis>Goals</emphasis> "clean gwt:debug".</simpara>
      
<figure>
<title>Configure Maven Debug Configuration</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/ConfigureGwtDebug.PNG" contentwidth="650"/>
    </imageobject>
    <textobject><phrase>ConfigureGwtDebug</phrase></textobject>
  </mediaobject>
</figure>

      
    </listitem>
  
    <listitem>
      <simpara>Next we will need to setup our remote debugger configurations in Eclipse. Because the client and server code run on separate JVMs, we will need to setup two such configurations. To create a debug configuration, select <emphasis>Debug As&#8230;</emphasis> &gt; <emphasis>Debug Configurations&#8230;</emphasis> from the toolbar.</simpara>
      
<figure>
<title>Create Debug Configuration</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/DebugConfigurations.PNG" contentwidth="650"/>
    </imageobject>
    <textobject><phrase>DebugConfigurations</phrase></textobject>
  </mediaobject>
</figure>

      
    </listitem>
  
    <listitem>
      <simpara>In the sidebar, select <emphasis>Remote Java Application</emphasis> and click the <emphasis>New</emphasis> button in the top right corner.</simpara>
      
<figure>
<title>Create Remote Debug Configuration</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/NewDebugConfig.PNG" contentwidth="650"/>
    </imageobject>
    <textobject><phrase>NewDebugConfig</phrase></textobject>
  </mediaobject>
</figure>

      
    </listitem>
  
    <listitem>
      <simpara>This new configuration will be for remote debugging your client-side code, so give it an appropriate name. If the name of your project is not already in the <emphasis>Project</emphasis> field, click <emphasis>Browse</emphasis> and select it. The <emphasis>Host</emphasis> and <emphasis>Port</emphasis> values should be <emphasis>localhost</emphasis> and <emphasis>8000</emphasis> respectively, such that your configuration looks like this:</simpara>
      
<figure>
<title>Client Debug Configuration</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/ClientDebugConfig.PNG" contentwidth="650"/>
    </imageobject>
    <textobject><phrase>ClientDebugConfig</phrase></textobject>
  </mediaobject>
</figure>
<simpara>If everything is correct, click <emphasis>Apply</emphasis>.</simpara>

      
    </listitem>
  
    <listitem>
      <simpara>Create another <emphasis>Remote Java Application</emphasis> run configuration with the steps just described for remote debugging server code. The only differences from the client configuration should be the name and the port, which is <emphasis>8001</emphasis>. Thus the server remote debug configuration should look like this:</simpara>
      
<figure>
<title>Server Debug Configuration</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/ServerDebugConfig.PNG" contentwidth="650"/>
    </imageobject>
    <textobject><phrase>ServerDebugConfig</phrase></textobject>
  </mediaobject>
</figure>

      
    </listitem>
  
    <listitem>
      <simpara>That&#8217;s it! You&#8217;ve successfully imported your Errai project into Eclipse. Now, on to <link linkend="sid-54493502">coding</link>!</simpara>
      
    </listitem>
  
</orderedlist>
</section>
</section>
<section id="_running_and_debugging_in_your_ide_using_gwt_tooling">
<title>Running and Debugging in your IDE using GWT tooling</title>
<simpara>Errai&#8217;s <emphasis>EmbeddedWildFlyLauncher</emphasis> provides an embedded WildFly instance within Dev Mode to allow users to debug server- and client-side code simultaneously in a single JVM. Here are the instructions for using it in Eclipse and Intellij IDEA Ultimate Edition:</simpara>
<section id="_configuring_your_app_to_use_the_google_plugin_for_eclipse">
<title>Configuring your app to use the Google Plugin for Eclipse</title>
<simpara>This method requires the Google Plugin for Eclipse (GPE). You can find the instructions to download and install it <ulink url="https://developers.google.com/eclipse/docs/download">here</ulink>.</simpara>
<simpara>Here are the steps to setup a run/debug configuration using the embedded WildFly launcher:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>Ensure that your app is using the Google Web Toolkit. Right-click on your project in Eclipse, and select Google &#8594; Web Toolkit Settings, and make sure that the "Use Google Web Toolkit" box is checked and the appropriate GWT SDK is selected.</simpara>
      
<figure>
<title>Google Web Toolkit Settings</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/gpe/EclipseProjectGWTSettings.png" contentwidth="650"/>
    </imageobject>
    <textobject><phrase>EclipseProjectGWTSettings</phrase></textobject>
  </mediaobject>
</figure>

      
    </listitem>
  
    <listitem>
      <simpara>Set up a Web Application run/debug configuration as follows:</simpara>
      
<simpara>Create a new Web Application run/debug configuration, select your Errai app in the Project field and set <literal>com.google.gwt.dev.DevMode</literal> as the main class:</simpara>
<figure>
<title>Dev Mode Configuration: Main tab</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/gpe/EclipseWebAppMain.png" contentwidth="650"/>
    </imageobject>
    <textobject><phrase>EclipseWebAppMain</phrase></textobject>
  </mediaobject>
</figure>

      
    </listitem>
  
    <listitem>
      <simpara>In the <emphasis>Server</emphasis> tab, check the <emphasis>Run built-in server</emphasis> checkbox, and enter the port number <literal>8888</literal>.</simpara>
      
<figure>
<title>Dev Mode Configuration: Server tab</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/gpe/EclipseWebAppServer.png" contentwidth="650"/>
    </imageobject>
    <textobject><phrase>EclipseWebAppServer</phrase></textobject>
  </mediaobject>
</figure>

      
    </listitem>
  
    <listitem>
      <simpara>Select <emphasis>Super Development Mode</emphasis> in the GWT tab, and add your GWT module under <emphasis>Available Modules</emphasis>.</simpara>
      
<figure>
<title>Dev Mode Configuration: GWT tab</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/gpe/EclipseWebAppGWT.png" contentwidth="650"/>
    </imageobject>
    <textobject><phrase>EclipseWebAppGWT</phrase></textobject>
  </mediaobject>
</figure>

      
    </listitem>
  
    <listitem>
      <simpara>Under the <emphasis>Arguments</emphasis> tab, there are two fields, <emphasis>Program arguments</emphasis> and <emphasis>VM arguments</emphasis>. In the <emphasis>Program arguments</emphasis> field, amend the <literal>server</literal> flag as follows:</simpara>
      
<formalpara>
<title>Program Arguments</title>
<para>
<screen>-server org.jboss.errai.cdi.server.gwt.EmbeddedWildFlyLauncher</screen>
</para>
</formalpara>
<simpara>Make sure the following VM arguments are set:</simpara>
<formalpara>
<title>VM arguments</title>
<para>
<screen>-Xmx2048m -XX:MaxPermSize=512M -Derrai.jboss.home=/home/ddadlani/errai-tutorial/target/wildfly-8.2.0.Final/</screen>
</para>
</formalpara>
<simpara>where <literal>errai.jboss.home</literal> points to your own WildFly installation. This can either be your local WildFly installation directory, or in the <emphasis>target/</emphasis> directory of your app. For the Errai Tutorial app, <literal>errai.jboss.home</literal> points to the WildFly installation within the <emphasis>target/</emphasis> directory, which is redownloaded and installed as part of the build. See <link linkend="wildfly-install-eclipse">below</link> for information on how to automatically download WildFly into the <emphasis>target/</emphasis> directory prior to running Super Dev Mode.</simpara>
<figure>
<title>Dev Mode Configuration: Arguments tab</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/gpe/EclipseWebAppArguments.png" contentwidth="650"/>
    </imageobject>
    <textobject><phrase>EclipseWebAppArguments</phrase></textobject>
  </mediaobject>
</figure>

      
    </listitem>
  
</orderedlist>
<important id="wildfly-install-eclipse">
<title>Copy of WildFly in the target/ directory</title>
<simpara>If you wish to automatically download and install WildFly as part of your build into the <emphasis>target/</emphasis> directory of your web app, you will need to run <literal>mvn process-resources</literal> prior to running or debugging your app. To do this, you can set up a Maven build configuration in Eclipse and specify <emphasis>Goals</emphasis>: "process-resources". You can then run the Maven configuration prior to running GWT&#8217;s Super Dev Mode.</simpara>
</important>
<simpara>That&#8217;s it! To debug your application within Eclipse, simply select your debug configuration and hit <emphasis>Debug</emphasis>. This will start GWT&#8217;s dev mode as well as the debugger within Eclipse.</simpara>
<section id="_debugging_client_side_javascript_from_within_eclipse">
<title>Debugging client-side JavaScript from within Eclipse</title>
<simpara>If you wish to debug your client-side JavaScript as Java code from within Eclipse, you will need to use the SDBG plugin for GWT Super Dev Mode. More information can be found <ulink url="http://sdbg.github.io/">here</ulink>.</simpara>
</section>
</section>
<section id="_configuring_your_app_to_use_intellij_idea_s_gwt_tooling">
<title>Configuring your app to use Intellij IDEA&#8217;s GWT tooling</title>
<note>
<title>Intellij IDEA Community Edition users</title>
<simpara>The inbuilt GWT tooling for Intellij IDEA is only available in the Ultimate Edition. If you are using the Community Edition, you will not have access to the GWT plugin.</simpara>
</note>
<simpara>The Ultimate Edition for Intellij IDEA comes with a built-in GWT plugin that allows you to run and debug GWT apps specifically. We can configure the plugin to use the embedded WildFly launcher for debugging ease, in order to debug both server and client-side code in one debug session. This section describes how to set up a GWT run/debug configuration within Intellij IDEA:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>If you have not already done so, add a GWT facet to your main module. Instructions to add a GWT facet to an existing module can be found <ulink url="https://www.jetbrains.com/idea/help/adding-a-gwt-facet-to-a-module.html">here</ulink>.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>On the top right hand corner of your Intellij IDEA session, select the dropdown box labeled <emphasis>Edit Configurations</emphasis> to create a new run/debug configuration.</simpara>
      
<figure>
<title>Edit Run/Debug Configuration</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/intellij/IntellijEditConfig.png" contentwidth="450"/>
    </imageobject>
    <textobject><phrase>IntellijEditConfig</phrase></textobject>
  </mediaobject>
</figure>

      
    </listitem>
  
    <listitem>
      <simpara>Press the <literal>+</literal> button under GWT Configurations to create a new GWT configuration. Check the <emphasis>Super Dev Mode</emphasis> checkbox and select the name of your module. Fill out the following parameters in the corresponding boxes:</simpara>
      
<formalpara>
<title>VM Options</title>
<para>
<screen>-Xmx2048m -XX:MaxPermSize=512M -Derrai.jboss.home=/home/ddadlani/errai-tutorial/target/wildfly-8.2.0.Final/</screen>
</para>
</formalpara>
<simpara>where <literal>errai.jboss.home</literal> points to your WildFly installation directory. This can either be your local WildFly installation directory, or in the <emphasis>target/</emphasis> directory of your app. For the Errai Tutorial app, <literal>errai.jboss.home</literal> points to the WildFly installation within the <emphasis>target/</emphasis> directory, which is redownloaded and installed as part of the build. See <link linkend="wildfly-install-intellij">below</link> for information on how to automatically download WildFly into the <emphasis>target/</emphasis> directory prior to running Super Dev Mode.</simpara>
<formalpara>
<title>Dev Mode Parameters</title>
<para>
<screen>-server org.jboss.errai.cdi.server.gwt.EmbeddedWildFlyLauncher</screen>
</para>
</formalpara>
<figure>
<title>GWT Run/Debug Configuration for Intellij IDEA</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/intellij/IntellijGWTConfig.png" contentwidth="650"/>
    </imageobject>
    <textobject><phrase>IntellijGWTConfig</phrase></textobject>
  </mediaobject>
</figure>

      
    </listitem>
  
    <listitem>
      <simpara>Select the <emphasis>Default</emphasis> server and make sure the start page is <emphasis>index.html</emphasis>. Select your browser and check the <emphasis>with JavaScript debugger</emphasis> box to take advantage of Intellij IDEA&#8217;s built-in JavaScript tooling.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Click on the <literal>+</literal> button under <emphasis>Before Launch</emphasis> and select the <emphasis>Make</emphasis> option. This will tell Intellij to compile your project before launching Dev Mode.</simpara>
      
    </listitem>
  
</orderedlist>
<important id="wildfly-install-intellij">
<title>Copy of WildFly in the target/ directory</title>
<simpara>If you wish to automatically download and install WildFly as part of your build into the <emphasis>target/</emphasis> directory of your web app, you will need to run <literal>mvn process-resources</literal> prior to running or debugging your app. To do this, you can add a Maven goal to the <emphasis>Before Launch</emphasis> task list. Click the <literal>+</literal> button as before, select <emphasis>Run Maven Goal</emphasis> and in the <emphasis>Command Line</emphasis> field, enter "process-resources". Ensure that the working directory is the same as your project directory before clicking "OK". Intellij IDEA will then run the Maven goal prior to starting Super Dev Mode.</simpara>
</important>
<simpara>To run or debug your app, select this configuration in the top right corner of Intellij IDEA and click the <emphasis>Run</emphasis> or <emphasis>Debug</emphasis> buttons next to it. Your app should start up in Dev Mode within Intellij automatically and you should be able to use Intellij&#8217;s own debugger to debug your code.</simpara>
<simpara>Now that you have everything set up, it&#8217;s time to move on to coding!</simpara>
</section>
</section>
<section id="sid-54493502">
<title>A Gentle Introduction to CDI</title>
<important>
<title>This section is based on the previous guide sections</title>
<simpara>The project you created and setup in the previous two sections (ERRAI:Create your Project and ERRAI:Configuring your project for Eclipse) will be used as the basis for this section. So if you have not read them, do so now.</simpara>
</important>
<simpara>Errai CDI as its namesake implies is based on, and is in fact, a partial implementation of the CDI (Contexts and Dependency Injection) specification. Errai CDI covers <emphasis>most</emphasis> of the programming model but omits the CDI SPI, instead replacing it with it a custom set of APIs which are more appropriate for the client programming model of Errai.</simpara>
<simpara>These differences aside, using Errai CDI in conjunction with CDI on the server will provide you with a uniform programming model across the client and server code of your application.</simpara>
<simpara>This guide does not assume any past experience with CDI. However, you may wish to consider reading the <ulink url="http://docs.jboss.org/weld/reference/1.1.5.Final/en-US/html/">Weld Documentation</ulink> in addition to this guide.</simpara>
<section id="sid-54493502_AGentleIntroductiontoCDI-YourFirstBean">
<title>Your First Bean</title>
<simpara>A bean in CDI is merely a POJO (Plain Old Java Object), for the most part. In the context of CDI, any plain, default constructable class is a member of the <emphasis>dependent scope</emphasis>. Don&#8217;t worry too much about what that means for now. Let&#8217;s just go ahead and make one:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Foo {
  public String getName() {
    return "Mr. Foo";
  }
}</programlisting>
<simpara>That was an easy, if uninteresting, exercise. But despite this class' worthy distinction as a dependent-scoped bean, it&#8217;s actually quite a useless dependent scope beaned. Well, maybe not so much useless as it is unused.</simpara>
<simpara>Well, how would we use this bean? To answer that question we&#8217;re going to need to introduce the concept of scopes in more detail.</simpara>
</section>
<section id="sid-54493502_AGentleIntroductiontoCDI-Scopes">
<title>Scopes</title>
<simpara>Scopes, put simply, are the context within which beans live. Some scopes are short-lived and some are long-lived. For instance, there are beans which you may only want to create during a request, and beans which you want to live for as long as the application is running.</simpara>
<simpara>It turns out that CDI includes a set of default scopes which represent these very things.</simpara>
<simpara>We&#8217;ll start by taking a look at the <emphasis>application scope</emphasis>, which is conveniently represented by the annotation <literal><phrase role="code">@ApplicationScoped</phrase></literal>. An application-scoped bean is a lazily-instantiated bean which will live for the entire duration of the application. In this sense, it is essentially like a singleton. And it&#8217;s generally okay to think of it in that way.</simpara>
<simpara>So let&#8217;s declare an application-scoped bean:</simpara>
<programlisting language="java" linenumbering="unnumbered">@ApplicationScoped
public class Bar {
  public String getName() {
    return "Mr. Bar";
  }
}</programlisting>
<simpara>So what can we do with <literal><phrase role="code">Foo</phrase></literal>? Well, let&#8217;s go ahead and get familiar with dependency injection, shall we?</simpara>
<programlisting language="java" linenumbering="unnumbered">@ApplicationScoped
public class Bar {
  @Inject Foo foo;

  public String getName() {
    return "Mr. Bar";
  }
}</programlisting>
<simpara>We have added a field of the type <literal><phrase role="code">Foo</phrase></literal> which we declared earlier, and we have annotated it with <literal><phrase role="code">javax.inject.Inject</phrase></literal>. This tells the container to inject an instance of <literal><phrase role="code">Foo</phrase></literal> into our bean. Since our <literal><phrase role="code">Foo</phrase></literal> bean is of the dependent scope, the bean manager will actually create a <emphasis>new</emphasis> instance of <literal><phrase role="code">Foo</phrase></literal> and pass it in.</simpara>
<simpara>This scope of the newly instantiated <literal><phrase role="code">Foo</phrase></literal> is <emphasis>dependent</emphasis> on the scope that it was injected into. In this case, the application scope. On the other hand, if we were to turn around an inject <literal><phrase role="code">Bar</phrase></literal> into <literal><phrase role="code">Foo</phrase></literal>, the behaviour is quite different.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Foo {
  @Inject Bar bar;

  public String getName() {
    return "Mr. Foo";
  }
}</programlisting>
<simpara>Here, every time a new instance of <literal><phrase role="code">Foo</phrase></literal> is created, the <emphasis>same</emphasis> instance of <literal><phrase role="code">Bar</phrase></literal> will be injected. That is to say: this pseudo-code assertion is now always true:</simpara>
<screen>assert fooInstance.bar.foo == fooInstance</screen>
<important>
<title>Note</title>
<simpara>This identity check will not <emphasis>actually</emphasis> be true at runtime due to the need to proxy the class in this scenario. But it is true, that <literal><phrase role="code">fooInstance</phrase></literal> and <literal><phrase role="code">fooInstance.bar.foo</phrase></literal> both point to the same <emphasis>underlying</emphasis> bean instance.</simpara>
</important>
<simpara>In the case of an Errai application, there are a bunch of application scoped beans which come built-in for common services like <emphasis>ErraiBus</emphasis>. Thus, in an Errai application which uses the message bus, we can inject a handle to the <literal><phrase role="code">MessageBus</phrase></literal> service into any of our beans. Let&#8217;s go ahead and do that in our <literal><phrase role="code">Bar</phrase></literal> class:</simpara>
<programlisting language="java" linenumbering="unnumbered">@ApplicationScoped
public class Bar {
  @Inject Foo foo;
  @Inject MessageBus bus;

  public String getName() {
    return "Mr. Bar";
  }
}</programlisting>
<simpara>If working with dependency injection is new to you, then this is where you&#8217;ll start seeing some practical benefit. When you need a common service in your client code, you ask the container for it by <emphasis>injecting</emphasis> it. This frees you from worrying about the proper APIs to use in order to access a service; we need to use the message bus in our <literal><phrase role="code">Bar</phrase></literal> bean, and so we inject it.</simpara>
</section>
<section id="_entrypoints">
<title>EntryPoints</title>
<simpara>Now that we&#8217;re getting the gist of how dependency injection works, let&#8217;s go back to our sample project.</simpara>
<simpara>In the <literal><phrase role="code">App</phrase></literal> class that was created you may have noticed that the bean&#8217;s scope is <literal><phrase role="code">@EntryPoint</phrase></literal>.</simpara>
<simpara>The <literal><phrase role="code">@EntryPoint</phrase></literal> annotation is an annotation which provides a an analogue to the GWT EntryPoint concept within the context of CDI in Errai. Basically you want to think of <literal><phrase role="code">@EntryPoint</phrase></literal> beans as the Errai CDI-equalivalent of <literal><phrase role="code">main()</phrase></literal> methods. But as of Errai 2.2., that might actually be going a little far. In fact, you might be asking what is the real difference between <literal><phrase role="code">@ApplicationScoped</phrase></literal> and <literal><phrase role="code">@EntryPoint</phrase></literal> in practice. The answer is that beans annotated with <literal><phrase role="code">@EntryPoint</phrase></literal> are eagerly instantiated while those annotated with <literal><phrase role="code">@ApplicationScoped</phrase></literal> are created when accessed. This makes <literal><phrase role="code">@EntryPoint</phrase></literal> useful for bootstrapping your application and <literal><phrase role="code">@ApplicationScoped</phrase></literal> useful for creating client-side services.</simpara>
<simpara>If you&#8217;re not convinced, try running this example with the <literal>mvn clean gwt:run</literal> command (described <link linkend="sid-54493220_GettingStartedwithErrai-RunningtheappinGWT">above</link>).</simpara>
<note>
<title>Launching maven the first time</title>
<simpara>Please note, that when launching maven the first time on your machine, it will fetch all dependencies from a central repository. This may take a while, because it includes downloading large binaries like GWT SDK. However, subsequent builds are not required to go through this step and will be much faster.</simpara>
</note>
</section>
</section>
</section>
</chapter>
<chapter id="sid-5931263">
<title>Messaging</title>
<simpara>This section covers the core messaging concepts of the ErraiBus messaging framework.</simpara>
<simpara>ErraiBus provides a straight-forward approach to a complex problem space. Providing common APIs across the client and server, developers will have no trouble working with complex messaging scenarios such as building instant messaging clients, stock tickers, to monitoring instruments. There&#8217;s no more messing with RPC APIs, or unwieldy AJAX or COMET frameworks. We&#8217;ve built it all in to one concise messaging framework. It&#8217;s single-paradigm, and it&#8217;s fun to work with.</simpara>
<section id="sid-5931265">
<title>Messaging Overview</title>
<simpara>It&#8217;s important to understand the concept of how messaging works in ErraiBus. Here are some important facts you&#8217;ll need to know:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>Service endpoints are given string-based names that are referenced by message senders.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>There is no difference between sending a message to a client-based service, or sending a message to a server-based service.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Furthermore, a service of the same name may co-exist on both the client and the server and both will receive all messages bound for that service name, whether they are sent from the client or from the server.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Services are lightweight in ErraiBus, and can be declared liberally and extensively within your application to provide a message-based infrastructure for your web application.</simpara>
      
    </listitem>
  
</itemizedlist>

<simpara>It can be tempting to think of ErraiBus simply as a client-server communication platform, but there is a plethora of possibilities for using ErraiBus purely within the GWT client context, such as a way to advertise and expose components dynamically, to get around the lack of reflection in GWT.</simpara>
<simpara>So keep that in mind when you run up against problems in the client space that could benefit from runtime federation.</simpara>
<note>
<title>Manual Setup</title>
<simpara>Checkout the <link linkend="Manual-Setup-Section">Manual Setup Section</link> for instructions on how to manually add messaging to your project.</simpara>
</note>
</section>
<section id="sid-5931280">
<title>Messaging API Basics</title>
<simpara>The MessageBuilder is the heart of the messaging API in ErraiBus. It provides a fluent / builder API, that is used for constructing messages. All three major message patterns can be constructed from the <literal><phrase role="code">MessageBuilder</phrase></literal>.</simpara>
<simpara>Components that want to receive messages need to implement the <literal><phrase role="code">MessageCallback</phrase></literal> interface.</simpara>
<simpara>But before we dive into the details, let&#8217;s look at some use cases.</simpara>
<section id="sid-5931280_MessagingAPIBasics-SendingMessageswiththeClientBus">
<title>Sending Messages with the Client Bus</title>
<simpara>In order to send a message from a client you need to create a <literal><phrase role="code">Message</phrase></literal> and send it through an instance of <literal><phrase role="code">MessageBus</phrase></literal>. In this simple example we send it to the subject <emphasis>HelloWorldService</emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class HelloWorld implements EntryPoint {

  // Get an instance of the RequestDispatcher
  private RequestDispatcher dispatcher = ErraiBus.getDispatcher();

  public void onModuleLoad() {
    Button button = new Button("Send message");

    button.addClickHandler(new ClickHandler() {
      public void onClick(ClickEvent event) {
        // Send a message to the 'HelloWorldService'.
        MessageBuilder.createMessage()
          .toSubject("HelloWorldService") // (1)
          .signalling() // (2)
          .noErrorHandling() // (3)
          .sendNowWith(dispatcher); // (4)
        });

        [...]
      }
   }
}
</programlisting>
<simpara>In the above example we build and send a message every time the button is clicked. Here&#8217;s an explanation of what&#8217;s going on as annotated above:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>We specify the subject we wish to send a message to. In this case, " <literal><phrase role="code">HelloWorldService</phrase></literal> ".</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>We indicate that we wish to only signal the service, meaning, that we&#8217;re not sending a qualifying command to the service. For information on this, read the section on <link linkend="sid-23036473_WireProtocol%28J.REP%29-BusManagementandHandshakingProtocols">Protocols</link>.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>We indicate that we do not want to provide an <literal><phrase role="code">ErrorCallback</phrase></literal> to deal with errors for this message.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>We transmit the message by providing an instance to the <literal><phrase role="code">RequestDispatcher</phrase></literal></simpara>
      
    </listitem>
  
</orderedlist>
<important>
<simpara>An astute observer will note that access to the <literal><phrase role="code">RequestDispatcher</phrase></literal> differs within client code and server code. Because this client code does not run within a container, access to the <literal><phrase role="code">RequestDispatcher</phrase></literal> and <literal><phrase role="code">MessageBus</phrase></literal> is provided statically using the <literal><phrase role="code">ErraiBus.get()</phrase></literal> and <literal><phrase role="code">ErraiBus.getDispatcher()</phrase></literal> methods. See the section on Errai IOC and Errai CDI for using ErraiBus from a client-side container.</simpara>
<simpara>When using Errai IOC or CDI, you can also use the Sender&lt;T&gt; interface to send messages.</simpara>
</important>
</section>
<section id="sid-5931280_MessagingAPIBasics-ReceivingMessagesontheServerBus%2FServerServices">
<title>Receiving Messages on the Server Bus / Server Services</title>
<simpara>Every message has a sender and at least one receiver. A receiver is as it sounds&#8212;it receives the message and does something with it. Implementing a receiver (also referred to as a service) is as simple as implementing our standard MessageCallback interface, which is used pervasively across, both client and server code. Let&#8217;s begin with server side component that receives messages:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Service
  public class HelloWorldService implements MessageCallback {
    public void callback(Message message) {
      System.out.println("Hello, World!");
    }
  }
</programlisting>
<simpara>Here we declare an extremely simple service. The <literal><phrase role="code">@Service</phrase></literal> annotation provides a convenient, meta-data based way of having the bus auto-discover and deploy the service.</simpara>
</section>
<section id="sid-5931280_MessagingAPIBasics-SendingMessageswiththeServerBus">
<title>Sending Messages with the Server Bus</title>
<simpara>In the following example we extend our server side component to reply with a message when the callback method is invoked. It will create a message and address it to the subject ' <literal><phrase role="code">HelloWorldClient</phrase></literal> ':</simpara>
<programlisting language="java" linenumbering="unnumbered">@Service
public class HelloWorldService implements MessageCallback {

  private RequestDispatcher dispatcher;

  @Inject
  public HelloWorldService(RequestDispatcher dispatcher) {
    dispatcher = dispatcher;
  }

  public void callback(CommandMessage message) {
    // Send a message to the 'HelloWorldClient'.
    MessageBuilder.createMessage()
      .toSubject("HelloWorldClient") // (1)
      .signalling()                  // (2)
      .with("text", "Hi There")      // (3)
      .noErrorHandling()             // (4)
      .sendNowWith(dispatcher);      // (5)
    });
  }
}</programlisting>
<simpara>The above example shows a service which sends a message in response to receiving a message. Here&#8217;s what&#8217;s going on:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>We specify the subject we wish to send a message to. In this case, " <literal><phrase role="code">HelloWorldClient</phrase></literal> ". We are sending this message to all clients which are listening in on this subject. For information on how to communicate with a single client, see Section 2.6.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>We indicate that we wish to only signal the service, meaning that we&#8217;re not sending a qualifying command to the service. For information on this, read the section on Protocols.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>We add a message part called "text" which contains the value "Hi there".</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>We indicate that we do not want to provide an <literal><phrase role="code">ErrorCallback</phrase></literal> to deal with errors for this message.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>We transmit the message by providing an instance of the <literal><phrase role="code">RequestDispatcher</phrase></literal>.</simpara>
      
    </listitem>
  
</orderedlist>
</section>
<section id="sid-5931280_MessagingAPIBasics-ReceivingMessagesontheClientBus%2FClientServices">
<title>Receiving Messages on the Client Bus/ Client Services</title>
<simpara>Messages can be received asynchronously and arbitriraily by declaring callback services within the client bus. As ErraiBus maintains an open COMET channel at all times, these messages are delivered in real time to the client as they are sent. This provides built-in push messaging for all client services.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class HelloWorld implements EntryPoint {

  private MessageBus bus = ErraiBus.get();

  public void onModuleLoad() {
     [...]

     /*
      * Declare a service to receive messages on the subject
      * "BroadcastReceiver".
      */
     bus.subscribe("BroadcastReceiver", new MessageCallback() {
       public void callback(CommandMessage message) {
         /*
          * When a message arrives, extract the "text" field and
          * do something with it
          */
          String messageText = message.get(String.class, "text");
        }
     });

     [...]
  }
}
</programlisting>
<simpara>In the above example, we declare a new client service called <literal><phrase role="code">"BroadcastReceiver"</phrase></literal> which can now accept both local messages and remote messages from the server bus. The service will be available in the client to receive messages as long the client bus is and the service is not explicitly de-registered.</simpara>
</section>
<section id="sid-5931280_MessagingAPIBasics-LocalServices">
<title>Local Services</title>
<simpara>On the client or the server, you can create a local receiver which only receives messages that originated on the local bus. A local server-side service only receives messages that originate on that server, and a local client-side service only receives messages that originated on that client.</simpara>
<simpara>To create a local receiver using the declarative API, use the <literal><phrase role="code">@Local</phrase></literal> annotation in conjunction with <literal><phrase role="code">@Service</phrase></literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Local
@Service
  public class HelloIntrovertService implements MessageCallback {
    public void callback(Message message) {
      System.out.println("Hello, me!");
    }
  }</programlisting>
<simpara>To create a local receiver using through programmatic service registration, use the <literal><phrase role="code">subscribeLocal()</phrase></literal> method in place of <literal><phrase role="code">subscribe()</phrase></literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">public void registerLocalService(MessageBus bus) {
  bus.subscribeLocal("LocalBroadcastReceiver", new MessageCallback() {
    public void callback(Message message) {
       String messageText = message.get(String.class, "text");
     }
  });
}</programlisting>
<simpara>Both examples above work in client- and server-side code.</simpara>
</section>
</section>
<section id="sid-5931284">
<title>Single-Response Conversations &amp; Pseudo-Synchronous Messaging</title>
<simpara>It is possible to contruct a message and a default response handler as part of the <literal><phrase role="code">MessageBuilder</phrase></literal> API. It should be noted, that multiple replies will not be possible and will result an exception if attempted. Using this aspect of the API is very useful for doing simple psuedo-synchronous conversive things.</simpara>
<simpara>You can do this by specifying a <literal><phrase role="code">MessageCallback</phrase></literal> using the <literal><phrase role="code">repliesTo()</phrase></literal> method in the <literal><phrase role="code">MessageBuilder</phrase></literal> API after specifying the error handling of the message.</simpara>
<programlisting language="java" linenumbering="unnumbered">MessageBuilder.createMessage()
  .toSubject("ConversationalService").signalling()
  .with("SomeField", someValue)
  .noErrorHandling()
  .repliesTo(new MessageCallback() {
    public void callback(Message message) {
      System.out.println("I received a response");
    }
   })</programlisting>
<simpara>See the next section on how to build conversational services that can respond to such messages.</simpara>
</section>
<section id="sid-5931289">
<title>Sender Inferred Subjects</title>
<simpara>It is possible for the sender to infer, to whatever conversational service it is calling, what subject it would like the reply to go to. This is accomplished by utilizing the standard <literal><phrase role="code">MessageParts.ReplyTo</phrase></literal> message part. Using this methodology for building conversations is generally encouraged.</simpara>
<simpara>Consider the following client side code:</simpara>
<programlisting language="java" linenumbering="unnumbered">  MessageBuilder.createMessage()
    .toSubject("ObjectService").signalling()
    .with(MessageParts.ReplyTo, "ClientEndpoint")
    .noErrorHandling().sendNowWith(dispatcher);</programlisting>
<simpara>And the conversational code on the server (for service <emphasis>ObjectService</emphasis>):</simpara>
<programlisting language="java" linenumbering="unnumbered">  MessageBuilder.createConversation(message)
    .subjectProvided().signalling()
    .with("Records", records)
    .noErrorHandling().reply();</programlisting>
<simpara>In the above examples, assuming that the latter example is inside a service called "<literal><phrase role="code">ObjectService</phrase></literal>" and is referencing the incoming message that was sent in the former example, the message created will automatically reference the <literal><phrase role="code">ReplyTo</phrase></literal> subject that was provided by the sender, and send the message back to the subject desired by the client on the client that sent the message.</simpara>
</section>
<section id="sid-5931291">
<title>Broadcasting</title>
<simpara>Broadcasting messages to all clients listening on a specific subject is quite simple and involves nothing more than forgoing use of the reply API. For instance:</simpara>
<programlisting language="java" linenumbering="unnumbered">MessageBuilder.createMessage().
    .toSubject("MessageListener")
    .with("Text", "Hello, from your overlords in the cloud")
    .noErrorHandling().sendGlobalWith(dispatcher);</programlisting>
<simpara>If sent from the server, all clients currently connected, who are listening to the subject <literal><phrase role="code">"MessageListener"</phrase></literal> will receive the message. It&#8217;s as simple as that.</simpara>
</section>
<section id="sid-5931293">
<title>Client-to-Client Communication</title>
<simpara>Communication from one client to another client is not directly possible within the bus federation, by design. This isn&#8217;t to say that it&#8217;s not possible. But one client cannot see a service within the federation of another client. We institute this limitation as a matter of basic security. But many software engineers will likely find the prospects of such communication appealing, so this section will provide some basic pointers on how to go about accomplishing it.</simpara>
<section id="sid-5931293_Client-to-ClientCommunication-RelayServices">
<title>Relay Services</title>
<simpara>The essential architectural thing you&#8217;ll need to do is create a relay service that runs on the server. Since a service advertised on the server is visible to all clients and all clients are visible to the server, you might already see where we&#8217;re going with this.</simpara>
<simpara>By creating a service on the server which accepts messages from clients, you can create a simple protocol on-top of the bus to enable quasi peer-to-peer communication. (We say quasi, because it still needs to be routed through the server)</simpara>
<simpara>While you can probably imagine simply creating a broadcast-like service which accepts a message from one client and broadcasts it to the rest of the world, it may be less clear how to go about routing from one particular client to another particular client, so we&#8217;ll focus on that problem. This is covered in <link linkend="sid-5931301">the next chapter</link>.</simpara>
</section>
</section>
<section id="sid-5931301">
<title>Message Routing Information</title>
<simpara>Every message that is sent between a local and remote (or server and client) buses contain session routing information. This information is used by the bus to determine what outbound queues to use to deliver the message to, so they will reach their intended recipients. It is possible to manually specify this information to indicate to the bus, where you want a specific message to go.</simpara>
<simpara>You can obtain the <literal><phrase role="code">SessionID</phrase></literal> directly from a <literal><phrase role="code">Message</phrase></literal> by getting the <literal><phrase role="code">QueueSession</phrase></literal> resource:</simpara>
<programlisting language="java" linenumbering="unnumbered">   QueueSession sess = message.getResource(QueueSession.class, Resources.Session.name());
   String sessionId = sess.getSessionId();</programlisting>
<simpara>You can extract the <literal><phrase role="code">SessionID</phrase></literal> from a message so that you may use it for routing by obtaining the <literal><phrase role="code">QueueSession</phrase></literal> resource from the <literal><phrase role="code">Message</phrase></literal>. For example:</simpara>
<programlisting language="java" linenumbering="unnumbered">...
  public void callback(Message message) {
   QueueSession sess = message.getResource(QueueSession.class, Resources.Session.name());
   String sessionId = sess.getSessionId();

    // Record this sessionId somewhere.
    ...
  }</programlisting>
<simpara>The <literal><phrase role="code">SessionID</phrase></literal> can then be stored in a medium, say a Map, to cross-reference specific users or whatever identifier you wish to allow one client to obtain a reference to the specific <literal><phrase role="code">SessionID</phrase></literal> of another client. In which case, you can then provide the <literal><phrase role="code">SessionID</phrase></literal> as a MessagePart to indicate to the bus where you want the message to go.</simpara>
<programlisting language="java" linenumbering="unnumbered">  MessageBuilder.createMessage()
    .toSubject("ClientMessageListener")
    .signalling()
    .with(MessageParts.SessionID, sessionId)
    .with("Message", "We're relaying a message!")
    .noErrorHandling().sendNowWith(dispatcher);</programlisting>
<simpara>By providing the <literal><phrase role="code">SessionID</phrase></literal> part in the message, the bus will see this and use it for routing the message to the relevant queue.</simpara>
<simpara>It may be tempting however, to try and include destination <literal><phrase role="code">SessionIDs</phrase></literal> at the client level, assuming that this will make the infrastructure simpler. But this will not achieve the desired results, as the bus treats <literal><phrase role="code">SessionIDs</phrase></literal> as transient. Meaning, the <literal><phrase role="code">SessionID</phrase></literal> information is not ever transmitted from bus-to-bus, and therefore is only directly relevant to the proximate bus.</simpara>
</section>
<section id="sid-5931306">
<title>Handling Errors</title>
<simpara>Asynchronous messaging necessitates the need for asynchronous error handling. Luckily, support for handling errors is built directly into the <literal><phrase role="code">MessageBuilder</phrase></literal> API, utilizing the <literal><phrase role="code">ErrorCallback</phrase></literal> interface. In the examples shown in previous exceptions, error handing has been glossed over with aubiquitous usage of the <literal><phrase role="code">noErrorHandling()</phrase></literal> method while building messaging. We chose to require the explicit use of such a method to remind developers of the fact that they are responsible for their own error handling, requiring you to explicitly make the decision to forego handling potential errors.</simpara>
<simpara>As a general rule, you should <emphasis>always handle your errors</emphasis>. It will lead to faster and quicker identification of problems with your applications if you have error handlers, and generally help you build more robust code.</simpara>
<programlisting language="java" linenumbering="unnumbered">MessageBuilder.createMessage()
    .toSubject("HelloWorldService")
    .signalling()
    .with("msg", "Hi there!")
    .errorsHandledBy(new ErrorCallback() {
      public boolean error(Message message, Throwable throwable) {
        throwable.printStackTrace();
          return true;
      }
    })
    .sendNowWith(dispatcher);</programlisting>
<simpara>The addition of error handling at first may put off developers as it makes code more verbose and less-readable. This is nothing that some good practice can&#8217;t fix. In fact, you may find cases where the same error handler can appropriately be shared between multiple different calls.</simpara>
<programlisting language="java" linenumbering="unnumbered">ErrorCallback error = new ErrorCallback() {
  public boolean error(Message message, Throwable throwable) {
    throwable.printStackTrace();
    return true;
  }
}

MessageBuilder.createMessage()
  .toSubject("HelloWorldService")
  .signalling()
  .with("msg", "Hi there!")
  .errorsHandledBy(error)
  .sendNowWith(dispatcher);
</programlisting>
<simpara>The error handler is required to return a <literal><phrase role="code">boolean</phrase></literal> value. This is to indicate whether or not Errai should perform the default error handling actions it would normally take during a failure. You will almost always want to return <literal><phrase role="code">true</phrase></literal> here, unless you are trying to explicitly surpress some undesirably activity by Errai, such as automatic subject-termination in conversations. But this is almost never the case.</simpara>
<section id="sid-5931306_HandlingErrors-Handlingglobalmessagetransporterrors">
<title>Handling global message transport errors</title>
<simpara>You may need to detect problems which occur on the bus at runtime. The client bus API provides a facility for doing this in the <literal><phrase role="code">org.jboss.errai.bus.client.framework.ClientMessageBus</phrase></literal> using the <literal><phrase role="code">addTransportErrorHandler()</phrase></literal> method.</simpara>
<simpara>A <literal><phrase role="code">TransportErrorHandler</phrase></literal> is an interface which you can use to define error handling behavior in the event of a transport problem.</simpara>
<simpara>For example:</simpara>
<programlisting language="java" linenumbering="unnumbered">messageBus.addTransportErrorHandler(new TransportErrorHandler() {
  public void onError(TransportError error) {
    // error handling code.
  }
});
</programlisting>
<simpara>The <literal><phrase role="code">TransportError</phrase></literal> interface represents the details of an an error from the bus. It contains a set of methods which can be used for determining information on the initial request which triggered the error, if the error occurred over HTTP or WebSockets, status code information, etc. See the JavaDoc for more information.</simpara>
</section>
</section>
<section id="sid-5931309">
<title>Asynchronous Message Tasks</title>
<simpara>In some applications, it may be necessary or desirable to delay transmission of, or continually stream data to a remote client or group of clients (or from a client to the server). In cases like this, you can utilize the <literal><phrase role="code">replyRepeating()</phrase></literal>, <literal><phrase role="code">replyDelayed()</phrase></literal>, <literal><phrase role="code">sendRepeating()</phrase></literal> and <literal><phrase role="code">sendDelayed()</phrase></literal> methods in the <literal><phrase role="code">MessageBuilder</phrase></literal>.</simpara>
<simpara>Delayed TasksSending a task with a delay is straight forward. Simply utilize the appropriate method (either <literal><phrase role="code">replyDelayed()</phrase></literal> or <literal><phrase role="code">sendDelayed()</phrase></literal>).</simpara>
<programlisting language="java" linenumbering="unnumbered">  MessageBuilder.createConversation(msg)
    .toSubject("FunSubject")
    .signalling()
    .noErrorHandling()
    .replyDelayed(TimeUnit.SECONDS, 5); // sends the message after 5 seconds.</programlisting>
<simpara>or</simpara>
<programlisting language="java" linenumbering="unnumbered">   MessageBuilder.createMessage()
     .toSubject("FunSubject")
     .signalling()
     .noErrorHandling()
     .sendDelayed(requestDispatcher, TimeUnit.SECONDS, 5); // sends the message after 5 seconds.</programlisting>
</section>
<section id="sid-5931311">
<title>Repeating Tasks</title>
<simpara>A repeating task is sent using one of the MessageBuilder&#8217;s <literal><phrase role="code">repeatXXX()</phrase></literal> methods. The task will repeat indefinitely until cancelled (see next section).</simpara>
<programlisting language="java" linenumbering="unnumbered">  MessageBuilder.createMessage()
    .toSubject("FunSubject")
    .signalling()
    .withProvided("time", new ResourceProvider&lt;String&gt;() {
       SimpleDateFormat fmt = new SimpleDateFormat("hh:mm:ss");

       public String get() {
         return fmt.format(new Date(System.currentTimeMillis());
       }
     }
     .noErrorHandling()
     .sendRepeatingWith(requestDispatcher, TimeUnit.SECONDS, 1); //sends a message every 1 second</programlisting>
<simpara>The above example sends a message very 1 second with a message part called <literal><phrase role="code">"time"</phrase></literal>, containing a formatted time string. Note the use of the <literal><phrase role="code">withProvided()</phrase></literal> method; a provided message part is calculated at the time of transmission as opposed to when the message is constructed.</simpara>
<simpara>Cancelling an Asynchronous TaskA delayed or repeating task can be cancelled by calling the <literal><phrase role="code">cancel()</phrase></literal> method of the <literal><phrase role="code">AsyncTask</phrase></literal> instance which is returned when creating a task. Reference to the AsyncTask object can be retained and cancelled by any other thread.</simpara>
<programlisting language="java" linenumbering="unnumbered">AsyncTask task = MessageBuilder.createConversation(message)
  .toSubject("TimeChannel").signalling()
  .withProvided(TimeServerParts.TimeString, new ResourceProvider&lt;String&gt;() {
     public String get() {
       return String.valueOf(System.currentTimeMillis());
     }
   }).defaultErrorHandling().replyRepeating(TimeUnit.MILLISECONDS, 100);

    ...

  // cancel the task and interrupt it's thread if necessary.
  task.cancel(true);</programlisting>
</section>
<section id="sid-5931315">
<title>Queue Sessions</title>
<simpara>The ErraiBus maintains it&#8217;s own seperate session management on-top of the regular HTTP session management. While the queue sessions are tied to, and dependant on HTTP sessions for the most part (meaning they die when HTTP sessions die), they provide extra layers of session tracking to make dealing with complex applications built on Errai easier.</simpara>
<section id="sid-5931315_QueueSessions-Lifecycle">
<title>Lifecycle</title>
<simpara>The lifescyle of a session is bound by the underlying HTTP session. It is also bound by activity thresholds. Clients are required to send heartbeat messages every once in a while to maintain their sessions with the server. If a heartbeat message is not received after a certain period of time, the session is terminated and any resources are deallocated.</simpara>
</section>
<section id="sid-5931315_QueueSessions-Scopes">
<title>Scopes</title>
<simpara>One of the things Errai offers is the concept of session and local scopes.</simpara>
<section id="sid-5931315_QueueSessions-SessionScope">
<title>Session Scope</title>
<simpara>A session scope is scoped across all instances of the same session. When a session scope is used, any parameters stored will be accessible and visible by all browser instances and tabs.</simpara>
<simpara>The SessionContext helper class is used for accessing the session scope.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class TestService implements MessageCallback {
  public void callback(final Message message) {
    // obtain a reference to the session context by referencing the incoming message.
    SessionContext injectionContext = SessionContext.get(message);

    // set an attribute.
    injectionContext.setAttribute("MyAttribute", "Foo");
  }
}</programlisting>
</section>
<section id="sid-5931315_QueueSessions-LocalScope">
<title>Local Scope</title>
<simpara>A local scope is scoped to a single browser instance. But not to a single session.</simpara>
<simpara>In a browser a local scope would be confined to a tab or a window within a browser. You can store parameters inside a local scope just like with a session by using the <literal><phrase role="code">LocalContext</phrase></literal> helper class.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class TestService implements MessageCallback {
  public void callback(final Message message) {
    // obtain a reference to the local context by referencing the incoming message.
    LocalContext injectionContext = LocalContext.get(message);

   // set an attribute.
    injectionContext.setAttribute("MyAttribute", "Foo");
  }
}</programlisting>
</section>
</section>
</section>
<section id="sid-23036473">
<title>Wire Protocol (J.REP)</title>
<simpara>ErraiBus implements a JSON-based wire protocol which is used for the federated communication between different buses. The protocol specification encompasses a standard JSON payload structure, a set of verbs, and an object marshalling protocol. The protocol is named J.REP. Which stands for JSON Rich Event Protocol.</simpara>
<section id="sid-23036473_WireProtocol%28J.REP%29-PayloadStructure">
<title>Payload Structure</title>
<simpara>All wire messages sent across are assumed to be JSON arrays at the outermost element, contained in which, there are <emphasis>0..n</emphasis> messages. An empty array is considered a no-operation, but should be counted as activity against any idle timeout limit between federated buses.</simpara>
<example>
<title>Example J.REP Payload</title>
<programlisting language="java" linenumbering="unnumbered">[
  {"ToSubject" : "SomeEndpoint", "Value" : "SomeValue" },
  {"ToSubject" : "SomeOtherEndpoint", "Value" : "SomeOtherValue"}
]</programlisting>
</example>
<simpara>Here we see an example of a J.REP payload containing two messages. One bound for an endpoint named <literal><phrase role="code">"SomeEndpoint"</phrase></literal> and the other bound for the endpoint <literal><phrase role="code">"SomeOtherEndpoint"</phrase></literal>. They both include a payload element <literal><phrase role="code">"Value"</phrase></literal> which contain strings. Let&#8217;s take a look at the anatomy of an individual message.</simpara>
<example>
<title>An J.REP Message</title>
<programlisting language="java" linenumbering="unnumbered">{
  "ToSubject" : "TopicSubscriber",
  "CommandType" : "Subscribe",
  "Value " : "happyTopic",
  "ReplyTo" : "MyTopicSubscriberReplyTo"
}</programlisting>
</example>
<simpara>The message shows a very vanilla J.REP message. The keys of the JSON Object represent individual <emphasis>message parts</emphasis>, with the values representing their corresponding values. The standard J.REP protocol encompasses a set of standard message parts and values, which for the purposes of this specification we&#8217;ll collectively refer to as the protocol verbs.</simpara>
<simpara>The following table describes all of the message parts that a J.REP capable client is expected to understand:</simpara>
<informaltable frame="all"
    rowsep="1" colsep="1">
  
  <tgroup cols="4">
    
    <colspec colname="col_1" colwidth="25*"/>
    
    <colspec colname="col_2" colwidth="25*"/>
    
    <colspec colname="col_3" colwidth="25*"/>
    
    <colspec colname="col_4" colwidth="25*"/>
    
    
    <thead>
      
      <row>
        
        <entry align="left" valign="top">Part</entry>
        
        <entry align="left" valign="top">Required</entry>
        
        <entry align="left" valign="top">JSON Type</entry>
        
        <entry align="left" valign="top">Description</entry>
        
      </row>
      
    </thead>
    
    <tbody>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">ToSubject</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>Yes</simpara></entry>
        
        <entry align="left" valign="top"><simpara>String</simpara></entry>
        
        <entry align="left" valign="top"><simpara>Specifies the subject within the bus, and its federation, which the message should be routed to.</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">CommandType</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>No</simpara></entry>
        
        <entry align="left" valign="top"><simpara>String</simpara></entry>
        
        <entry align="left" valign="top"><simpara>Specifies a command verb to be transmitted to the receiving subject. This is an optional part of a message contract, but is required for using management services</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">ReplyTo</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>No</simpara></entry>
        
        <entry align="left" valign="top"><simpara>String</simpara></entry>
        
        <entry align="left" valign="top"><simpara>Specifies to the receiver what subject it should reply to in response to this message.</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">Value</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>No</simpara></entry>
        
        <entry align="left" valign="top"><simpara>Any</simpara></entry>
        
        <entry align="left" valign="top"><simpara>A recommended but not required standard payload part for sending data to services</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">PriorityProcessing</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>No</simpara></entry>
        
        <entry align="left" valign="top"><simpara>Number</simpara></entry>
        
        <entry align="left" valign="top"><simpara>A processing order salience attribute. Messages which specify priority processing will be processed first if they are competing for resources with other messages in flight. Note: the current version of ErraiBus only supports two salience levels (0 and &gt;1). Any non-zero salience in ErraiBus will be given the same priority relative to 0 salience messages</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">ErrorMessage</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>No</simpara></entry>
        
        <entry align="left" valign="top"><simpara>String</simpara></entry>
        
        <entry align="left" valign="top"><simpara>An accompanying error message with any serialized exception</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">Throwable</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>No</simpara></entry>
        
        <entry align="left" valign="top"><simpara>Object</simpara></entry>
        
        <entry align="left" valign="top"><simpara>If applicable, an encoded object representing any remote exception that was thrown while dispatching the specified service</simpara></entry>
        
      </row>
      
    </tbody>
    
  </tgroup>
</informaltable>
<section id="sid-23036473_WireProtocol%28J.REP%29-BuiltinSubjects">
<title>Built-in Subjects</title>
<simpara>The table contains a list of reserved subject names used for facilitating things like bus management and error handling. A bus should never allow clients to subscribe to these subjects directly.</simpara>
<informaltable frame="all"
    rowsep="1" colsep="1">
  
  <tgroup cols="2">
    
    <colspec colname="col_1" colwidth="50*"/>
    
    <colspec colname="col_2" colwidth="50*"/>
    
    
    <thead>
      
      <row>
        
        <entry align="left" valign="top">Subject</entry>
        
        <entry align="left" valign="top">Description</entry>
        
      </row>
      
    </thead>
    
    <tbody>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">ClientBus</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>The self-hosted message bus endpoint on the client</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">ServerBus</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>The self-hosted message bus endpoint on the server</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">ClientBusErrors</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>The standard error receiving service for clients</simpara></entry>
        
      </row>
      
    </tbody>
    
  </tgroup>
</informaltable>
<simpara>As this table indicates, the bus management protocols in J.REP are accomplished using self-hosted services. See the section on <emphasis>Bus Management and Handshaking Protocols</emphasis> for details.</simpara>
</section>
</section>
<section id="sid-23036473_WireProtocol%28J.REP%29-MessageRouting">
<title>Message Routing</title>
<simpara>There is no real distinction in the J.REP protocol between communication with the server, versus communication with the client. In fact, it assumed from an architectural standpoint that there is no real distinction between a client and a server. Each bus participates in a flat-namespaced federation. Therefore, it is possible that a subject may be observed on both the server and the client.</simpara>
<simpara>One in-built assumption of a J.REP-compliant bus however, is that messages are routed within the auspices of session isolation. Consider the following diagram:</simpara>
<figure>
<title>Topology of a J.REP Messaging Federation</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/23036473/FederationTopology.png"/>
    </imageobject>
    <textobject><phrase>FederationTopology</phrase></textobject>
  </mediaobject>
</figure>
<simpara>It is possible for <emphasis>Client A</emphasis> to send messages to the subjects <emphasis>ServiceA</emphasis> and <emphasis>ServiceB</emphasis>. But it is not possible to address messages to <emphasis>ServiceC</emphasis>. Conversely, <emphasis>Client B</emphasis> can address messages to <emphasis>ServiceC</emphasis> and <emphasis>ServiceB</emphasis>, but not <emphasis>ServiceA</emphasis>.</simpara>
</section>
<section id="sid-23036473_WireProtocol%28J.REP%29-BusManagementandHandshakingProtocols">
<title>Bus Management and Handshaking Protocols</title>
<simpara>Federation between buses requires management traffic to negotiate connections and manage visibility of services between buses. This is accomplished through services named <literal><phrase role="code">ClientBus</phrase></literal> and <literal><phrase role="code">ServerBus</phrase></literal> which both implement the same protocol contracts which are defined in this section.</simpara>
<section id="sid-23036473_WireProtocol%28J.REP%29-ServerBusandClientBuscommands">
<title>ServerBus and ClientBus commands</title>
<simpara>Both bus services share the same management protocols, by implementing verbs (or commands) that perform different actions. These are specified in the protocol with the <literal><phrase role="code">CommandType</phrase></literal> message part. The following table describes these commands:</simpara>
<table frame="all"
    rowsep="1" colsep="1">
<title>Message Parts for Bus Commands:</title>
  
  <tgroup cols="3">
    
    <colspec colname="col_1" colwidth="33*"/>
    
    <colspec colname="col_2" colwidth="33*"/>
    
    <colspec colname="col_3" colwidth="33*"/>
    
    
    <thead>
      
      <row>
        
        <entry align="left" valign="top">Command / Verb</entry>
        
        <entry align="left" valign="top">Message Parts</entry>
        
        <entry align="left" valign="top">Description</entry>
        
      </row>
      
    </thead>
    
    <tbody>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">ConnectToQueue</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>N/A</simpara></entry>
        
        <entry align="left" valign="top"><simpara>The first message sent by a connecting client to begin the handshaking process.</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">CapabilitiesNotice</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">CapabilitiesFlags</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>A message sent by one bus to another to notify it of its capabilities during handshake (for instance long polling or websockets)</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">FinishStateSync</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>N/A</simpara></entry>
        
        <entry align="left" valign="top"><simpara>A message sent from one bus to another to indicate that it has now provided all necessary information to the counter-party bus to establish the federation. When both buses have sent this message to each other, the federation is considered active.</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">RemoteSubscribe</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">Subject</phrase></literal><emphasis>or</emphasis> <literal><phrase role="code">SubjectsList</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>A message sent to the remote bus to notify it of a service or set of services which it is capable of routing to.</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">RemoteUnsubscribe</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">Subject</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>A message sent to the remote bus to notify it that a service is no longer available.</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">Disconnect</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">Reason</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>A message sent to a server bus from a client bus to indicate that it wishes to disconnect and defederate. Or, when sent from the client to server, indicates that the session has been terminated.</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">SessionExpired</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>N/A</simpara></entry>
        
        <entry align="left" valign="top"><simpara>A message sent to a client bus to indicate that its messages are no longer being routed because it no longer has an active session</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">Heartbeat</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>N/A</simpara></entry>
        
        <entry align="left" valign="top"><simpara>A message sent from one bus to another periodically to indicate it is still active.</simpara></entry>
        
      </row>
      
    </tbody>
    
  </tgroup>
</table>
<informaltable frame="all"
    rowsep="1" colsep="1">
  
  <tgroup cols="4">
    
    <colspec colname="col_1" colwidth="25*"/>
    
    <colspec colname="col_2" colwidth="25*"/>
    
    <colspec colname="col_3" colwidth="25*"/>
    
    <colspec colname="col_4" colwidth="25*"/>
    
    
    <thead>
      
      <row>
        
        <entry align="left" valign="top">Part</entry>
        
        <entry align="left" valign="top">Required</entry>
        
        <entry align="left" valign="top">JSON Type</entry>
        
        <entry align="left" valign="top">Description</entry>
        
      </row>
      
    </thead>
    
    <tbody>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">CapabilitiesFlags</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>Yes</simpara></entry>
        
        <entry align="left" valign="top"><simpara>String</simpara></entry>
        
        <entry align="left" valign="top"><simpara>A comma delimited string of capabilities the bus is capable of us</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">Subject</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>Yes</simpara></entry>
        
        <entry align="left" valign="top"><simpara>String</simpara></entry>
        
        <entry align="left" valign="top"><simpara>The subject to subscribe or unsubscribe from</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">SubjectsList</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>Yes</simpara></entry>
        
        <entry align="left" valign="top"><simpara>Array</simpara></entry>
        
        <entry align="left" valign="top"><simpara>An array of strings representing a list of subjects to subscribe to</simpara></entry>
        
      </row>
      
    </tbody>
    
  </tgroup>
</informaltable>
</section>
</section>
</section>
<section id="sid-24674472">
<title>Conversations</title>
<simpara>Conversations are message exchanges which are between a single client and a service. They are a fundmentally important concept in ErraiBus, since by default, a message will be broadcast to all client services listening on a particular channel.</simpara>
<simpara>When you create a reply with an incoming message, you ensure that the message you are sending back is received by the same client which sent the incoming message. A simple example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Service
public class HelloWorldService implements MessageCallback {
  public void callback(CommandMessage message) {
    // Send a message to the 'HelloWorldClient' on the client that sent us the
    // the message.
    MessageBuilder.createConversation(message)
      .toSubject("HelloWorldClient")
      .signalling()
      .with("text", "Hi There! We're having a reply!")
      .noErrorHandling().reply();
    });
  }
}</programlisting>
<simpara>Note that the only difference between the example in the previous section and this is the use of the <literal><phrase role="code">createConversation()</phrase></literal> method with <literal><phrase role="code">MessageBuilder</phrase></literal>.</simpara>
</section>
<section id="sid-53380177">
<title>WebSockets</title>
<simpara>ErraiBus has support for WebSocket-based communication. When WebSockets are enabled, capable web browsers will attempt to upgrade their COMET-based communication with the server-side bus to use a WebSocket channel.</simpara>
<simpara>There are three different ways the bus can enable WebSockets. The first uses a sideband server, which is a small, lightweight server which runs on a different port from the application server. The second is native JBoss AS 7-based integration and the third is to rely in JSR-356 support in WildFly. Of course, you only need to configure one of these three options!</simpara>
<section id="sid-53380177_WebSockets-Configuringthesidebandserver">
<title>Configuring the sideband server</title>
<simpara>Activating the sideband server is as simple as adding the following to the <literal><phrase role="code">ErraiService.properties</phrase></literal> file:</simpara>
<programlisting language="java" linenumbering="unnumbered">errai.bus.enable_web_socket_server=true</programlisting>
<simpara>The default port for the sideband server is <literal><phrase role="code">8085</phrase></literal>. You can change this by specifying a port with the <literal><phrase role="code">errai.bus.web_socket_port</phrase></literal> property in the <literal><phrase role="code">ErraiService.properties</phrase></literal> file.</simpara>
<important>
<title>Netty Dependencies</title>
<simpara>Make sure to deploy the required Netty dependencies to your server. If you started with one of our demos or our tutorial project it should be enough to <emphasis role="strong">NOT</emphasis> set <literal><phrase role="code">netty-codec-http</phrase></literal> to provided. All required transitive dependencies should then be part of your war file (WEB-INF/lib).</simpara>
</important>
</section>
<section id="sid-53380177_WebSockets-DeployingwithJBossAS7">
<title>Deploying with JBoss AS 7.1.2 (or higher)</title>
<simpara>This is an alternative approach to the sideband server described in the previous chapter. Make sure to <emphasis role="strong">NOT</emphasis> configure both! It is currently necessary to use the native connector in JBoss AS for WebSockets to work. So the first step is to configure your JBoss AS instance(s) to use the native connector by changing the <literal><phrase role="code">domain/configuration/standalone.xml</phrase></literal> or <literal><phrase role="code">domain/configuration/domain.xml</phrase></literal> file as follows:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;subsystem xmlns="urn:jboss:domain:web:1.1" default-virtual-server="default-host" native="false"&gt;</programlisting>
<simpara>to:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;subsystem xmlns="urn:jboss:domain:web:1.1" default-virtual-server="default-host" native="true"&gt;</programlisting>
<important>
<title>Verify that the native APR connector is being used</title>
<simpara>To verify that the native connectors are being used check your console for the following log message:
<literal><phrase role="code">INFO [org.apache.coyote.http11.Http11AprProtocol] (MSC service thread 1-6) Starting Coyote HTTP/1.1 on http-/127.0.0.1:8080</phrase></literal></simpara>
<simpara>The important part is <literal><phrase role="code">org.apache.coyote.http11.Http11AprProtocol</phrase></literal>. You should <emphasis role="strong">NOT</emphasis> be seeing <literal><phrase role="code">org.apache.coyote.http11.Http11Protocol</phrase></literal>. You might have to install the Tomcat native library if not already available on your system.</simpara>
</important>
<simpara>You will then need to configure the servlet in your application&#8217;s <literal><phrase role="code">web.xml</phrase></literal> which will provide WebSocket upgrade support within AS7.</simpara>
<simpara>Add the following to the <literal><phrase role="code">web.xml</phrase></literal>:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;context-param&gt;
  &lt;param-name&gt;websockets-enabled&lt;/param-name&gt;
  &lt;param-value&gt;true&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;context-param&gt;
  &lt;param-name&gt;websocket-path-element&lt;/param-name&gt;
  &lt;param-value&gt;in.erraiBusWS&lt;/param-value&gt;
&lt;/context-param&gt;</programlisting>
<simpara>This will tell the bus to enable web sockets support. The <literal><phrase role="code">websocket-path-element</phrase></literal> specified the path element within a URL which the client bus should request in order to negotiate a websocket connection. For instance, specifying <literal><phrase role="code">in.erraiBusWS</phrase></literal> as we have in the snippit above, will result in attempted negotiation at <literal><phrase role="code"><ulink url="http://&lt;your_server&gt;:&lt;your_port&gt;/&lt;context_path&gt;/in.erraiBusWS">http://&lt;your_server&gt;:&lt;your_port&gt;/&lt;context_path&gt;/in.erraiBusWS</ulink></phrase></literal>. For this to have any meaningful result, we must add a servlet mapping that will match this pattern:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;servlet&gt;
  &lt;servlet-name&gt;ErraiWSServlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;org.jboss.errai.bus.server.servlet.JBossAS7WebSocketServlet&lt;/servlet-class&gt;
  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;ErraiWSServlet&lt;/servlet-name&gt;
  &lt;url-pattern&gt;*.erraiBusWS&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</programlisting>
<important>
<title>Do not remove the regular ErraiBus servlet mappings!</title>
<simpara>When configuring ErraiBus to use WebSockets on JBoss AS, you <emphasis>do not</emphasis> remove the existing servlet mappings for the bus. The WebSocket servlet is in <emphasis>addition to</emphasis> your current bus servlet. This is because ErraiBus <emphasis>always</emphasis> negotiates WebSocket sessions over the COMET channel.</simpara>
</important>
<important>
<title>Important dependency</title>
<simpara>Also make sure to deploy the required errai-bus-jboss7-websocket.jar to your server. If you&#8217;re using Maven simply add the following dependency to your pom.xml file:</simpara>
<programlisting language="xml" linenumbering="unnumbered">	&lt;dependency&gt;
  		&lt;groupId&gt;org.jboss.errai&lt;/groupId&gt;
  		&lt;artifactId&gt;errai-bus-jboss7-websocket&lt;/artifactId&gt;
  		&lt;version&gt;${errai.version}&lt;/version&gt;
	&lt;/dependency&gt;</programlisting>
</important>
</section>
<section id="_jsr_356_websocket_support_deploying_to_wildfly_8_0_or_higher">
<title>JSR-356 WebSocket support (Deploying to WildFly 8.0 or higher)</title>
<simpara>Errai provides two implementations for this:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>errai-bus-jsr356-websocket: A simple JSR-356 implementation, that does not rely on CDI or Weld.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>errai-bus-jsr356-websocket-weld: Provides the possibility to use the builtin CDI scopes (javax.enterprise.context.RequestScoped, javax.enterprise.context.SessionScoped, javax.enterprise.context.ConversationScoped). This implementation uses WELD and is intended for JBoss WildFly 8 or higher.</simpara>
      
    </listitem>
  
</orderedlist>
<simpara>Make sure to add the following project dependency:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- For JSR-356 without depending on Weld --&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.jboss.errai&lt;/groupId&gt;
	&lt;artifactId&gt;errai-bus-jsr356-websocket&lt;/artifactId&gt;
	&lt;version&gt;${errai.version}&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- For JEE environment with Weld--&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.jboss.errai&lt;/groupId&gt;
	&lt;artifactId&gt;errai-bus-jsr356-websocket-weld&lt;/artifactId&gt;
	&lt;version&gt;${errai.version}&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
<important>
<title>Dependency on Weld!</title>
<simpara>The JSR-356 specification is not addressing the integration with builtin CDI scopes which is what the <literal><phrase role="code">&lt;artifactId&gt;errai-bus-jsr356-websocket-weld&lt;/artifactId&gt;</phrase></literal> module provides. It therefore depends directly to JBoss Weld. If you use a non Weld-based middleware, you can use <literal><phrase role="code">&lt;artifactId&gt;errai-bus-jsr356-websocket&lt;/artifactId&gt;</phrase></literal> instead.</simpara>
</important>
<simpara>To configure ErraiBus that WebSocket communication should be used, define the following in your <literal><phrase role="code">web.xml</phrase></literal></simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;context-param&gt;
	&lt;param-name&gt;websockets-enabled&lt;/param-name&gt;
	&lt;param-value&gt;true&lt;/param-value&gt;
&lt;/context-param&gt;</programlisting>
<important>
<title>Do not remove the regular ErraiBus servlet mappings!</title>
<simpara>When configuring ErraiBus to use JSR-356 WebSocket, you <emphasis>do not</emphasis> remove the existing servlet mappings for the bus. This is because ErraiBus <emphasis>always</emphasis> negotiates WebSocket sessions over the COMET channel.</simpara>
</important>
<simpara>You can also define filters when using the JSR-356 WebSocket implementation. These filters will be executed for each received ErraiBus message on the server. Your filters need to implement <literal><phrase role="code">org.jboss.errai.bus.server.websocket.jsr356.filter.WebSocketFilter</phrase></literal> and must be configured in your appliations&#8217;s <literal><phrase role="code">web.xml</phrase></literal> as an ordered comma separated list:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;context-param&gt;
	&lt;param-name&gt;errai-jsr-356-websocket-filter&lt;/param-name&gt;
	&lt;param-value&gt;foo.bar.FooFilter,foo.bar.BarFilter&lt;/param-value&gt;
&lt;/context-param&gt;</programlisting>
<simpara>Because one of the filter method parameters is the actual WebSocket session, you also have to add the following dependency to your  <literal><phrase role="code">pom.xml</phrase></literal>:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
	&lt;groupId&gt;org.jboss.spec.javax.websocket&lt;/groupId&gt;
	&lt;artifactId&gt;jboss-websocket-api_1.1_spec&lt;/artifactId&gt;
	&lt;scope&gt;provided&lt;/scope&gt;
	&lt;version&gt;1.0.0.Final&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
<simpara>Please take a look at the JavaDoc of the filter interface for more information about the method parameters.</simpara>
</section>
<section id="_websocket_security">
<title>WebSocket Security</title>
<simpara>Errai supports Websocket security (wss) for two deployment scenarios.</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>The servlet container is deployed behind a reverse-proxy or other SSL terminating appliance</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The servlet container is deployed in front and takes care of SSL termination</simpara>
      
    </listitem>
  
</orderedlist>
<section id="_servlet_container_is_deployed_behind_a_reverse_proxy">
<title>Servlet container is deployed behind a reverse-proxy</title>
<simpara>All you need to do is configure the following context parameter in your <literal><phrase role="code">web.xml</phrase></literal></simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;context-param&gt;
  &lt;param-name&gt;force-secure-websockets&lt;/param-name&gt;
  &lt;param-value&gt;true&lt;/param-value&gt;
&lt;/context-param&gt;</programlisting>
<simpara>This will work for the sideband-server as well as JBoss AS7 and WildFly based websocket support.</simpara>
<important>
<title>Don&#8217;t forget to configure your reverse-proxy or appliance to handle websocket connections with SSL!</title>
<simpara>To use this kind of configuration you have to configure your reverse-proxy or appliance to use HTTPS (SSL / TLS).</simpara>
</important>
</section>
<section id="_servlet_container_takes_care_of_ssl_termination">
<title>Servlet container takes care of SSL termination</title>
<section id="_with_jboss_as_7_1_2_or_higher_amp_jsr_356_websocket_wildfly_8_or_higher">
<title>With JBoss AS 7.1.2 (or higher) &amp; JSR-356 WebSocket (WildFly 8 or higher)</title>
<simpara>If the servlet container is configured to use HTTPS, the Errai WebSocket Servlet for JBoss AS 7 and / or the Errai JSR-356 WebSocket implementation for WildFly will use the WSS scheme automatically. So, there&#8217;s is nothing else to do!</simpara>
</section>
<section id="_using_the_sideband_server">
<title>Using the sideband server</title>
<simpara>To tell the sideband server to use SSL and configure Errai to use the WSS scheme the following properties are mandatory in <literal><phrase role="code">ErraiService.properties</phrase></literal>:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>errai.bus.secure_web_socket_server=true &#8594; This tells the sideband server and Errai to use SSL / WSS.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>errai.bus.web_socket_keystore=[full qualified path to the JKS or PKCS12 keystore] &#8594; Key store to use</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>errai.bus.web_socket_keystore_password=[password for the key store] &#8594; Password for the key store to use</simpara>
      
    </listitem>
  
</orderedlist>
<simpara>Depending on your configuration and type of PKI container you can the add following addtional properties in the <literal><phrase role="code">ErraiService.properties</phrase></literal>:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>errai.bus.web_socket_keystore_type=[kind of key store] &#8594; When you want to use the PKCS12 format instead of JKS (default)</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>errai.bus.web_socket_key_password=[password of private key] &#8594; When the private key in the container has a different password than the keystore itself.</simpara>
      
    </listitem>
  
</orderedlist>
<important>
<title>Sidband server needs a keystore.</title>
<simpara>In this deployment case, the sideband server needs a keystore with a server certificate and the corresponding private key.</simpara>
</important>
</section>
</section>
</section>
</section>
<section id="sid-59146643">
<title>Bus Lifecycle</title>
<section id="sid-59146643_BusLifecycle-TurningServerCommunicationOnandOff">
<title>Turning Server Communication On and Off</title>
<simpara>By default, Errai&#8217;s client-side message bus attempts to connect to the server as soon as the ErraiBus module has been loaded. The bus will stay connected until a lengthy (about 45 seconds) communication failure occurs, or the web page is unloaded.</simpara>
<simpara>The application can affect bus communication through two mechanisms:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>By setting a global JavaScript variable <literal><phrase role="code">erraiBusRemoteCommunicationEnabled = false</phrase></literal> before the GWT scripts load, bus communication with the server is permanently disabled</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>By calling <literal>((ClientMessageBus) ErraiBus.get()).stop()</literal>, the bus disconnects from the server</simpara>
      
    </listitem>
  
</orderedlist>
<simpara>To resume server communication after a call to <literal><phrase role="code">ClientMessageBus.stop()</phrase></literal> or after communication with the server has exceeded the bus' retry timeout, call <literal>((ClientMessageBus) ErraiBus.get()).init()</literal>. You can use a <literal><phrase role="code">BusLifecycleListener</phrase></literal> to monitor the success or failure of this attempt. See the next section for details.</simpara>
</section>
<section id="sid-59146643_BusLifecycle-ObservingBusLifecycleStateandCommunicationStatus">
<title>Observing Bus Lifecycle State and Communication Status</title>
<simpara>In a perfect world, the client message bus would always be able to communicate with the server message bus. But in the real world, there&#8217;s a whole array of reasons why the communication link between the server and the client might be interrupted.</simpara>
<simpara>On its own, the client message bus will attempt to reconnect with the server whenever communication has been disrupted. Errai applications can monitor the status of the bus' communication link (whether it is disconnected, attempting to connect, or fully connected) through the <literal><phrase role="code">BusLifecycleListener</phrase></literal> interface:</simpara>
<programlisting language="java" linenumbering="unnumbered">class BusStatusLogger implements BusLifecycleListener {

  @Override
  public void busAssociating(BusLifecycleEvent e) {
    GWT.log("Errai Bus trying to connect...");
  }

  @Override
  public void busOnline(BusLifecycleEvent e) {
    GWT.log("Errai Bus connected!");
  }

  @Override
  public void busOffline(BusLifecycleEvent e) {
    GWT.log("Errai Bus trying to connect...");
  }

  @Override
  public void busDisassociating(BusLifecycleEvent e) {
    GWT.log("Errai Bus going into local-only mode.");
  }
}</programlisting>
<simpara>To attach such a listener to the bus, make the following call in client-side code:</simpara>
<programlisting language="java" linenumbering="unnumbered">ClientMessageBus bus = (ClientMessageBus) ErraiBus.get();
bus.addLifecycleListener(new BusStatusLogger());</programlisting>
</section>
</section>
<section id="sid-68355291">
<title>Shadow Services</title>
<simpara>Shadow Services is a Service that will get invoked when there is no longer a connection with the server. This is particular helpful when developing an application for mobile. To create a Shadow Service for a specific Services all you have to do is annotate a new client side implementation with the @ShadowService:</simpara>
<programlisting language="java" linenumbering="unnumbered">@ShadowService
public class SignupShadowService implements MessageCallback {
   @Override
   public void callback(Message message) {
   }
}</programlisting>
<simpara>Also when you have a RPC based Service you can just add @ShadowService on a client side implementation to configure it to be the service to get called when there is no network:</simpara>
<programlisting language="java" linenumbering="unnumbered">@ShadowService
public class SignupServiceShadow implements SignupService {
   @Override
   public User register(User newUserObject, String password) throws RegistrationException {
   }
}</programlisting>
<simpara>In this shadow service we can create logic that will deal with the temporary connection loss. For instance you could save the data that needs to get send to the server with JPA on the client and then when the bus get online again sent the data to the server.</simpara>
</section>
<section id="sid-5931386">
<title>Debugging Messaging Problems</title>
<simpara>Errai includes a bus monitoring application, which allows you to monitor all of the message exchange activity on the bus in order to help track down any potential problems It allows you to inspect individual messages to examine their state and structure.</simpara>
<simpara>To utilize the bus monitor, you&#8217;ll need to include the _errai-tools _ package as part of your application&#8217;s dependencies. When you run your application in development mode, you will simply need to add the following JVM options to your run configuration in order to launch the monitor: <literal><phrase role="code">-Derrai.tools.bus_monitor_attach=true</phrase></literal></simpara>
<figure>
<title>ErraiBus Monitor</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/5931386/MonitorOverview.png"/>
    </imageobject>
    <textobject><phrase>MonitorOverview</phrase></textobject>
  </mediaobject>
</figure>
<simpara>The monitor provides you a real-time perspective on what&#8217;s going on inside the bus. The left side of the main screen lists the services that are currently available, and the right side is the service-explorer, which will show details about the service.</simpara>
<simpara>To see what&#8217;s going on with a specific service, simply double-click on the service or highlight the service, then click "Monitor Service&#8230;". This will bring up the service activity monitor.</simpara>
<figure>
<title>ErraiBus Monitor details</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/5931386/MonitorOverview2.png"/>
    </imageobject>
    <textobject><phrase>MonitorOverview2</phrase></textobject>
  </mediaobject>
</figure>
<simpara>The service activity monitor will display a list of all the messages that were transmitted on the bus since the monitor became active. You do not need to actually have each specific monitor window open in order to actively monitor the bus activity. All activity on the bus is recorded.</simpara>
<simpara>The monitor allows you select individual messages, an view their individual parts. Clicking on a message part will bring up the object inspector, which will allow you to explore the state of any objects contained within the message, not unlike the object inspectors provided by debuggers in your favorite IDE. This can be a powerful tool for looking under the covers of your application.</simpara>
</section>
</chapter>
<chapter id="sid-5931402">
<title>Dependency Injection</title>
<note>
<title>Manual Setup</title>
<simpara>Checkout the <link linkend="Manual-Setup-Section">Manual Setup Section</link> for instructions on how to manually add Errai IOC to your project.</simpara>
</note>
<simpara>The core Errai IOC module implements the <emphasis>JSR-330 Dependency Injection</emphasis> specification for in-client component wiring.</simpara>
<simpara>Dependency injection (DI) allows for cleaner and more modular code, by permitting the implementation of decoupled and type-safe components. By using DI, components do not need to be aware of the implementation of provided services. Instead, they merely declare a contract with the container, which in turn provides instances of the services that component depends on.</simpara>
<important>
<title>Classpath Scanning and ErraiApp.properties</title>
<simpara>Errai only scans the contents of classpath locations (JARs and directories) that have <link linkend="sid-5931354">a file called
          ErraiApp.properties</link> at their META-INF directory. If dependency injection is not working for you, double-check that you have an <literal><phrase role="code">ErraiApp.properties</phrase></literal> in every JAR and directory that contains classes Errai should know about.</simpara>
</important>
<simpara>A simple example:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class MyLittleClass {
  private final TimeService timeService;

  @Inject
  public MyLittleClass(TimeService timeService) {
    this.timeService = timeService;
  }

  public void printTime() {
    System.out.println(this.timeService.getTime());
  }
}</programlisting>
<simpara>In this example, we create a simple class which declares a dependency using <literal><phrase role="code">@Inject</phrase></literal> for the interface <literal><phrase role="code">TimeService</phrase></literal>. In this particular case, we use constructor injection to establish the contract between the container and the component. We can similarly use field injection to the same effect:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class MyLittleClass {
  @Inject
  private TimeService timeService;

  public void printTime() {
    System.out.println(this.timeService.getTime());
  }
}</programlisting>
<simpara>Below is an example of an <literal><phrase role="code">@ApplicationScoped TimeService</phrase></literal>, meaning a single instance of <literal><phrase role="code">TimeService</phrase></literal> would be provided by the container for all injection sites.</simpara>
<programlisting language="java" linenumbering="unnumbered">@ApplicationScoped
public class TimeService {
}</programlisting>
<simpara>We could also annotate the type <literal><phrase role="code">@Dependent</phrase></literal> so that every injection site has its own unique instance.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Dependent
public class TimeService {
}</programlisting>
<note>
<title>Implicitly Dependent Beans</title>
<simpara>Types lacking explicit scopes may also be injected, in which case they will be implicitly <literal><phrase role="code">@Dependent</phrase></literal>.</simpara>
</note>
<tip>
<title>Best Practices</title>
<simpara>Although field injection results in less code, a major disadvantage is that you cannot create immutable classes using the pattern, since the container must first call the default, no-argument constructor, and then iterate through its injection tasks, which leaves the potential albeit remote that the object could be left in an partially or improperly initialized state. The advantage of constructor injection is that fields can be immutable (final), and invariance rules applied at construction time, leading to earlier failures, and the guarantee of consistent state.</simpara>
</tip>
<section id="sid-5931407">
<title>Container Wiring</title>
<simpara>In contrast to <ulink url="http://code.google.com/p/google-gin/">Gin</ulink>, the Errai IOC container does not provide a programmatic way of creating and configuring injectors. Instead, container-level binding rules are defined by implementing a <literal><phrase role="code">Provider</phrase></literal>, which is scanned for and auto-discovered by the container.</simpara>
<simpara>A <literal><phrase role="code">Provider</phrase></literal> is essentially a factory which produces type instances within in the container, and defers instantiation responsibility for the provided type to the provider implementation. Top-level providers use the standard <literal><phrase role="code">javax.inject.Provider&lt;T&gt;</phrase></literal> interface.</simpara>
<simpara>Types made available as <emphasis>top-level</emphasis> providers will be available for injection in any managed component within the container.</simpara>
<simpara>Out of the box, Errai IOC implements these default top-level providers, all defined in the <literal><phrase role="code">org.jboss.errai.ioc.client.api.builtin</phrase></literal> package:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara><literal><phrase role="code">CallerProvider</phrase></literal>: Makes RPC <literal><phrase role="code">Caller&lt;T&gt;</phrase></literal> objects available for injection.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal><phrase role="code">DisposerProvider</phrase></literal>: Makes Errai IoC <literal><phrase role="code">Disposer&lt;T&gt;</phrase></literal> objects available for injection.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal><phrase role="code">InitBallotProvider</phrase></literal>: Makes instances of <literal><phrase role="code">InitBallot</phrase></literal> available for injection.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal><phrase role="code">IOCBeanManagerProvider</phrase></literal>: Makes Errai&#8217;s client-side bean manager, <literal><phrase role="code">ClientBeanManager</phrase></literal>, available for injection.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal><phrase role="code">MessageBusProvider</phrase></literal>: Makes Errai&#8217;s client-side <literal><phrase role="code">MessageBus</phrase></literal> singleton available for injection.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal><phrase role="code">RequestDispatcherProvider</phrase></literal>: Makes an instance of the <literal><phrase role="code">RequestDispatcher</phrase></literal> available for injection.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal><phrase role="code">RootPanelProvider</phrase></literal>: Makes GWT&#8217;s <literal><phrase role="code">RootPanel</phrase></literal> singleton injectable.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal><phrase role="code">SenderProvider</phrase></literal>: Makes MessageBus <literal><phrase role="code">Sender&lt;T&gt;</phrase></literal> objects available for injection.</simpara>
      
    </listitem>
  
</itemizedlist>

<simpara>Implementing a <literal><phrase role="code">Provider</phrase></literal> is relatively straight-forward. Consider the following two classes:</simpara>
<simpara><emphasis>TimeService.java</emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">public interface TimeService {
  public String getTime();
}</programlisting>
<simpara><emphasis>TimeServiceProvider.java</emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">@IOCProvider
@Singleton
public class TimeServiceProvider implements Provider&lt;TimeService&gt; {
  @Override
  public TimeService get() {
    return new TimeService() {
      public String getTime() {
        return "It's midnight somewhere!";
      }
    };
  }
}</programlisting>
<simpara>If you are familiar with Guice, this is semantically identical to configuring an injector like so:</simpara>
<programlisting language="java" linenumbering="unnumbered">Guice.createInjector(new AbstractModule() {
  public void configure() {
    bind(TimeService.class).toProvider(TimeServiceProvider.class);
  }
 }).getInstance(MyApp.class);</programlisting>
<simpara>As shown in the above example code, the annotation <literal><phrase role="code">@IOCProvider</phrase></literal> is used to denote top-level providers.</simpara>
<simpara>The classpath will be searched for all annotated providers at compile time.</simpara>
<important>
<simpara>Top-level providers are regular beans, so they can inject dependencies particularly from other top-level providers as necessary.</simpara>
</important>
</section>
<section id="sid-5931332">
<title>Wiring server side components</title>
<simpara>By default, Errai uses Google Guice to wire server-side components. When deploying services on the server-side, it is currently possible to obtain references to the <literal><phrase role="code">MessageBus</phrase></literal>, <literal><phrase role="code">RequestDispatcher</phrase></literal>, the <literal><phrase role="code">ErraiServiceConfigurator</phrase></literal>, and <literal><phrase role="code">ErraiService</phrase></literal> by declaring them as injection dependencies in Service classes, extension components, and session providers.</simpara>
<simpara>Alternatively, supports CDI based wiring of server-side components. See the chapter on Errai CDI for more information.</simpara>
</section>
<section id="sid-20938792">
<title>Scopes</title>
<simpara>Out of the box, the IOC container supports three bean scopes, <literal><phrase role="code">@Dependent</phrase></literal>, <literal><phrase role="code">@Singleton</phrase></literal> and <literal><phrase role="code">@EntryPoint</phrase></literal>. The singleton and entry-point scopes are roughly the same semantics.</simpara>
<section id="sid-24674461">
<title>Dependent Scope</title>
<simpara>In Errai IOC, all client types are valid bean types if they are default constructable or can have construction dependencies satisfied. These unqualified beans belong to the dependent pseudo-scope. See: <ulink url="http://docs.jboss.org/weld/reference/latest/en-US/html/scopescontexts.html#d0e1997">Dependent Psuedo-Scope from CDI Documentation</ulink></simpara>
<simpara>Additionally, beans may be qualified as <literal><phrase role="code">@ApplicationScoped</phrase></literal>, <literal><phrase role="code">@Singleton</phrase></literal> or <literal><phrase role="code">@EntryPoint</phrase></literal>. Although <literal><phrase role="code">@ApplicationScoped</phrase></literal> and <literal><phrase role="code">@Singleton</phrase></literal> are supported for completeness and conformance, within the client they effectively result in behavior that is identical.</simpara>
<example>
<title>Example dependent scoped bean</title>
<programlisting language="java" linenumbering="unnumbered">public void MyDependentScopedBean {
  private final Date createdDate;

  public MyDependentScopedBean {
    createdDate = new Date();
  }
}</programlisting>
</example>
<example>
<title>Example ApplicationScoped bean</title>
<programlisting language="java" linenumbering="unnumbered">@ApplicationScoped
public void MyClientBean {
  @Inject MyDependentScopedBean bean;

  // ... //
}</programlisting>
</example>
<important>
<title>Availability of dependent beans in the client-side BeanManager</title>
<simpara>As is mentioned in the <link linkend="sid-21627016_Client-SideBeanManager-AvailabilityOfBeans">bean manager documentation</link>, only beans that are <emphasis>explicitly</emphasis> scoped will be made available to the bean manager for lookup. So while it is not necessary for regular injection, you must annotate your dependent scoped beans with <literal><phrase role="code">@Dependent</phrase></literal> if you wish to dynamically lookup these beans at runtime.</simpara>
</important>
</section>
</section>
<section id="sid-20938794">
<title>Built-in Extensions</title>
<section id="sid-20938797">
<title>Bus Services</title>
<simpara>As Errai IOC provides a container-based approach to client development, support for Errai services are exposed to the container so they may be injected and used throughout your application where appropriate. This section covers those services.</simpara>
<section id="sid-20938797_BusServices-@Service">
<title>@Service</title>
<simpara>The <literal><phrase role="code">org.jboss.errai.bus.server.annotations.Service</phrase></literal> annotation is used for binding service endpoints to the bus. Within the Errai IOC container you can annotate services and have them published to the bus on the client (or on the server) in a very straight-forward manner:</simpara>
<example>
<title>A simple message receiving service</title>
<programlisting language="java" linenumbering="unnumbered">@Service
public class MyService implements MessageCallback {
  public void callback(Message message) {
    // ... //
  }
}</programlisting>
</example>
<simpara>As with server-side use of the annotation, if a service name is not explicitly specified, the underlying class name or field name being annotated will be used as the service name.</simpara>
</section>
<section id="sid-20938797_BusServices-@Local">
<title>@Local</title>
<simpara>The <literal><phrase role="code">org.jboss.errai.bus.server.api.Local</phrase></literal> annotation is used in conjunction with the <literal><phrase role="code">@Service</phrase></literal> annotation to advertise a service only for visibility on the local bus and thus, cannot receive messages across the wire for the service.</simpara>
<example>
<title>A local only service</title>
<programlisting language="java" linenumbering="unnumbered">@Service @Local
public class MyLocalService implements MessageCallback {
  public void callback(Message message) {
    // ... //
  }
}</programlisting>
</example>
</section>
<section id="sid-20938797_BusServices-LifecycleImpactofServices">
<title>Lifecycle Impact of Services</title>
<simpara>Services which are registered with ErraiBus via the bean manager through use of the <literal><phrase role="code">@Service</phrase></literal> annotation, have de-registration hooks tied implicitly to the destruction of the bean. Thus, <link linkend="sid-22872238">destruction of the bean</link> implies that these associated services are to be dereferenced.</simpara>
</section>
</section>
<section id="sid-20938800">
<title>Client Components</title>
<simpara>The IOC container, by default, provides a set of default injectable bean types. They range from basic services, to injectable proxies for RPC. This section covers the facilities available out-of-the-box.</simpara>
<section id="sid-20938800_ClientComponents-MessageBus">
<title>MessageBus</title>
<simpara>The type <literal><phrase role="code">org.jboss.errai.bus.client.framework.MessageBus</phrase></literal> is globally injectable into any bean. Injecting this type will provide the instance of the active message bus running in the client.</simpara>
<example>
<title>Injecting a MessageBus</title>
<programlisting language="java" linenumbering="unnumbered">@Inject MessageBus bus;</programlisting>
</example>
</section>
<section id="sid-20938800_ClientComponents-RequestDispatcher">
<title>RequestDispatcher</title>
<simpara>The type <literal><phrase role="code">org.jboss.errai.bus.client.framework.RequestDispatcher</phrase></literal> is globally injectable into any bean. Injecting this type will provide a <literal><phrase role="code">RequestDispatcher</phrase></literal> instance capable of delivering any messages provided to it, to the <literal><phrase role="code">MessageBus</phrase></literal>.</simpara>
<example>
<title>Injecting a RequestDispatcher</title>
<programlisting language="java" linenumbering="unnumbered">@Inject RequestDispatcher dispatcher;</programlisting>
</example>
</section>
<section id="sid-20938800_ClientComponents-Caller%3C%3F%3E">
<title>Caller&lt;?&gt;</title>
<simpara>The type <literal><phrase role="code">org.jboss.errai.common.client.api.Caller&lt;?&gt;</phrase></literal> is a globally injectable RPC proxy. RPC proxies may be provided by various components. For example, JAX-RS or Errai RPC. The proxy itself is agnostic to the underlying RPC mechanism and is qualified by it&#8217;s type parameterization.</simpara>
<simpara>For example:</simpara>
<example>
<title>An example Caller&lt;?&gt; proxy</title>
<programlisting language="java" linenumbering="unnumbered">public void MyClientBean {
  @Inject
  private Caller&lt;MyRpcInterface&gt; rpcCaller;

  // ... ///

  @EventHandler("button")
  public void onButtonClick(ClickHandler handler) {
    rpcCaller.call(new RemoteCallback&lt;Void&gt;() {
      public void callback(Void void) {
        // put code here that should execute after RPC response arrives
      }
    ).callSomeMethod();
  }
}</programlisting>
</example>
<simpara>The above code shows the injection of a proxy for the RPC remote interface, <literal><phrase role="code">MyRpcInterface</phrase></literal>. For more information on defining RPC proxies see <link linkend="sid-5931313">Remote Procedure Calls (RPC)</link>.</simpara>
</section>
<section id="sid-20938800_ClientComponents-Sender%3C%3F%3E">
<title>Sender&lt;?&gt;</title>
<simpara>The <literal><phrase role="code">org.jboss.errai.ioc.support.bus.client.Sender&lt;?&gt;</phrase></literal> interface is the lower-level counterpart to the <literal><phrase role="code">Caller&lt;?&gt;</phrase></literal> interface described above. You can inject a <literal><phrase role="code">Sender</phrase></literal> to send low-level ErraiBus messages directly to subscribers on any subject.</simpara>
<simpara>For example:</simpara>
<programlisting language="java" linenumbering="unnumbered">  @Inject
  @ToSubject("ListCapitializationService")
  Sender&lt;List&lt;String&gt;&gt; listSender;

  // ... ///

  @EventHandler("button")
  public void onButtonClick(ClickHandler handler) {
    List&lt;String&gt; myListOfStrings = getSelectedCitiesFromForm();
    listSender.send(myListOfStrings, new MessageCallback() {
      public void callback(Message reply) {
        // do stuff with reply
      }
    );
  }</programlisting>
<simpara>The <literal><phrase role="code">Sender.send()</phrase></literal> method is overloaded. The variant demonstrated above takes a value and a MessageCallback to reply receive a reply (assuming the subscriber sends a conversational reply). The following variants are available:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara><literal><phrase role="code">send(T)</phrase></literal></simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal><phrase role="code">send(T, ErrorCallback)</phrase></literal></simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal><phrase role="code">send(T, MessageCallback)</phrase></literal></simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal><phrase role="code">send(T, MessageCallback, ErrorCallback)</phrase></literal></simpara>
      
    </listitem>
  
</itemizedlist>

<simpara>The reply-to service can also be specified declaratively using the <literal><phrase role="code">@ReplyTo</phrase></literal> annotation. This allows the app to receive conversational replies even when using the <literal><phrase role="code">send()</phrase></literal> variants that do not take a <literal><phrase role="code">MessageCallback</phrase></literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">  @Inject
  @ToSubject("ListCapitializationService")
  @ReplyTo("ClientListService")
  Sender&lt;List&lt;String&gt;&gt; listSender;

  // ... ///

  @EventHandler("button")
  public void onButtonClick(ClickHandler handler) {
    List&lt;String&gt; myListOfStrings = getSelectedCitiesFromForm();
    listSender.send(myListOfStrings);
  }

  @Singleton
  @Service
  public static class ClientListService implements MessageCallback {
    @Override
    public void callback(Message message) {
      // do stuff with message
    }
  }</programlisting>
<simpara>These <literal><phrase role="code">Sender&lt;?&gt;</phrase></literal> features are just convenient wrappers around the full-featured programmatic ErraiBus API. See <link linkend="sid-5931280">Messaging API Basics</link> and <link linkend="sid-24674472">Conversations</link> for full information about low-level ErraiBus communication.</simpara>
</section>
</section>
<section id="_global_exception_handling">
<title>Global Exception Handling</title>
<simpara>In plain GWT apps you can register your own handler for uncaught exceptions with <literal>GWT.setUncaughtExceptionHandler</literal>. With Errai IOC you can annotate methods in IOC beans as uncaught exception handlers as in the example below.</simpara>
<programlisting language="java" linenumbering="unnumbered">@ApplicationScoped
public class SingletonHandler {
  @UncaughtExceptionHandler
  private void handle(Throwable t) {
    // do something
  }
}</programlisting>
<simpara>In this example, <literal>SingletonHandler</literal> is <literal>@ApplicationScoped</literal> so the <literal>handle</literal> method will be invoked on the same instance for every uncaught exception. If the <literal>SingletonHandler</literal> has not bean instantiated when an uncaught exception occurs, the container will instantiate the instance and invoke the <literal>handle</literal> method.</simpara>
<simpara>An <literal>@UncaughtExceptionHandler</literal> method in a <literal>@Dependent</literal> bean will only be invoked for instances that have already been created. If multiple instances of such a bean exist, the <literal>@UncaughtExceptionHandler</literal> method will be invoked for each instance. If none exists the container will not create an instance and no handler methods will be invoked for that type.</simpara>
</section>
<section id="sid-21758082">
<title>Lifecycle Tools</title>
<simpara>A problem commonly associated with building large applications in the browser is ensuring that things happen in the proper order when code starts executing. Errai IOC provides you tools which permit you to ensure things happen before initialization, and forcing things to happen after initialization of all of the Errai services.</simpara>
<section id="sid-21758082_LifecycleTools-ControllingStartup">
<title>Controlling Startup</title>
<simpara>In order to prevent initialization of the bus and it&#8217;s services so that you can do necessary configuration, especially if you are writing extensions to the Errai framework itself, you can create an implicit startup dependency on your bean by injecting an <literal><phrase role="code">org.jboss.errai.ioc.client.api.InitBallot&lt;?&gt;</phrase></literal>.</simpara>
<example>
<title>Using an InitBallot to Control Startup</title>
<programlisting language="java" linenumbering="unnumbered">@Singleton
public class MyClientBean {
  @Inject InitBallot&lt;MyClientBean&gt; ballot;

  @PostConstruct
  public void doStuff() {
    // ... do some work ...

    ballot.voteForInit();
  }
}</programlisting>
</example>
</section>
<section id="sid-21758082_LifecycleTools-PerformingTasksAfterInitialization">
<title>Performing Tasks After Initialization</title>
<simpara>Sending RPC calls to the server from inside constructors and <literal><phrase role="code">@PostConstruct</phrase></literal> methods in Errai is not always reliable due to the fact that the bus and RPC proxies initialize asynchronously with the rest of the application. Therefore it is often desirable to have such things happen in a post-initialization task, which is exposed in the <literal><phrase role="code">ClientMessageBus</phrase></literal> API. However, it is much cleaner to use the <literal><phrase role="code">@AfterInitialization</phrase></literal> annotation on one of your bean methods.</simpara>
<example>
<title>Using @AfterInitialization to do something after startup</title>
<programlisting language="java" linenumbering="unnumbered">@Singleton
public class MyClientBean {
  @AfterInitialization
  public void doStuffAfterInit() {
    // ... do some work ...
  }
}</programlisting>
</example>
</section>
<section id="_increase_the_initialization_timeout">
<title>Increase the Initialization Timeout</title>
<simpara>For some very large applications it is possible for initialization to timeout in Development Mode because of deferred code generation. If you experience this problem, you can adjust the initialization timeout value by setting the <literal>erraiInitTimeout</literal> variable in your GWT Host Page to a value in milliseconds.</simpara>
</section>
</section>
<section id="sid-71467095">
<title>Timed Methods</title>
<simpara>The <literal><phrase role="code">@Timed</phrase></literal> annotation allows scheduling method executions on managed client-side beans. Timers are automatically scoped to the scope of the corresponding managed bean and participate in the same lifecycle (see <link linkend="sid-22872238">Bean Lifecycle</link> for details).</simpara>
<simpara>In the following example the <literal><phrase role="code">updateTime</phrase></literal> method is invoked repeatedly every second.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Timed(type = TimerType.REPEATING, interval = 1, timeUnit = TimeUnit.SECONDS)
private void updateTime() {
  timeWidget.setTime(System.currentTimeMillis);
}</programlisting>
<simpara>For delayed one-time execution of methods <literal><phrase role="code">type = TimerType.DELAYED</phrase></literal> can be used instead.</simpara>
</section>
</section>
<section id="sid-21627016">
<title>Client-Side Bean Manager</title>
<simpara>It may be necessary at times to manually obtain instances of beans managed by Errai IOC from outside the container managed scope or creating a hard dependency from your bean. Errai IOC provides a simple client-side bean manager for handling these scenarios: <literal><phrase role="code">org.jboss.errai.ioc.client.container.ClientBeanManager</phrase></literal>.</simpara>
<simpara>As you might expect, you can inject a bean manager instance into any of your managed beans. If you use Errai IOC in its default mode you will need to inject the synchronous bean manager (<literal><phrase role="code">org.jboss.errai.ioc.client.container.SyncBeanManager</phrase></literal>).</simpara>
<simpara>If you have asynchronous IOC mode enabled simply inject the asynchronous bean manager (<literal><phrase role="code">org.jboss.errai.ioc.client.container.async.AsyncBeanManager</phrase></literal>) instead. Asynchronous IOC brings support for <ulink url="http://www.gwtproject.org/doc/latest/DevGuideCodeSplitting.html">code splitting</ulink>. That means that any bean annotated with <literal><phrase role="code">@LoadAsync</phrase></literal> can be compiled into a separate JavaScript file that&#8217;s downloaded when the bean is first needed on the client. <literal><phrase role="code">@LoadAsync</phrase></literal> also allows to specify a fragment name using a class literal. Using GWT 2.6.0 or higher, all types with the same fragment name will be part of the same JavaScript file.</simpara>
<example>
<title>Injecting the client-side bean manager</title>
<programlisting language="java" linenumbering="unnumbered">public MyManagedBean {
  @Inject SyncBeanManager manager;

  // class body
}</programlisting>
</example>
<simpara>If you need to access the bean manager outside a managed bean, such as in a unit test, you can access it by calling <literal><phrase role="code">org.jboss.errai.ioc.client.container.IOC.getBeanManager()</phrase></literal></simpara>
<section id="sid-21627016_Client-SideBeanManager-Lookingupbeans">
<title>Looking up beans</title>
<simpara>Looking up beans can be done through the use of the <literal><phrase role="code">lookupBeans()</phrase></literal> method. Here&#8217;s a basic example:</simpara>
<example>
<title>Example lookup of a bean</title>
<programlisting language="java" linenumbering="unnumbered">public MyManagedBean {
  @Inject SyncBeanManager manager;

  public void lookupBean() {
    IOCBeanDef&lt;SimpleBean&gt; bean = manager.lookupBean(SimpleBean.class);

    if (bean != null) {
      // get the instance of the bean
      SimpleBean inst = bean.getInstance();
    }
  }
}</programlisting>
</example>
<simpara>In this example we lookup a bean class named <literal><phrase role="code">SimpleBean</phrase></literal>. This example will succeed assuming that <literal><phrase role="code">SimpleBean</phrase></literal> is unambiguous. If the bean is ambiguous and requires qualification, you can do a qualified lookup like so:</simpara>
<example>
<title>Looking up beans with qualifiers</title>
<programlisting language="java" linenumbering="unnumbered">MyQualifier qual = new MyQualifier() {
  public annotationType() {
    return MyQualifier.class;
  }
}

MyOtherQualifier qual2 = new MyOtherQualifier() {
  public annotationType() {
    return MyOtherQualifier.class;
  }
}

// pass qualifiers to ClientBeanManager.lookupBeans
IOCBeanDef&lt;SimpleBean&gt; bean = beanManager.lookupBean(SimpleBean.class, qual, qual2);</programlisting>
</example>
<simpara>In this example we manually construct instances of qualifier annotations in order to pass it to the bean manager for lookup. This is a necessary step since there&#8217;s currently no support for annotation literals in Errai client code.</simpara>
</section>
<section id="sid-21627016_Client-SideBeanManager-Availabilityofbeans">
<title>Availability of beans</title>
<simpara>Not all beans that are available for injection are available for lookup from the bean manager by default. Only beans which are <emphasis>explicitly</emphasis> scoped are available for dynamic lookup. This is an intentional feature to keep the size of the generated code down in the browser.</simpara>
</section>
</section>
<section id="sid-22872133">
<title>Alternatives</title>
<simpara>It may be desirable to have multiple matching dependencies for a given injection point with the ability to specify which implementation to use at runtime. For instance, you may have different versions of your application which target different browsers or capabilities of the browser. Using alternatives allows you to share common interfaces among your beans, while still using dependency injection, by exporting consideration of what implementation to use to the container&#8217;s configuration.</simpara>
<simpara>Consider the following example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Singleton @Alternative
public class MobileView implements View {
  // ... //
}</programlisting>
<simpara>and</simpara>
<programlisting language="java" linenumbering="unnumbered">@Singleton @Alternative
public class DesktopView implements View {
  // ... //</programlisting>
<simpara>In our controller logic we in turn inject the <literal><phrase role="code">View</phrase></literal> interface:</simpara>
<programlisting language="java" linenumbering="unnumbered">@EntryPoint
public class MyApp {
  @Inject
  View view;

  // ... //
}</programlisting>
<simpara>This code is unaware of the implementation of <literal><phrase role="code">View</phrase></literal>, which maintains good separation of concerns. However, this of course creates an ambiguous dependency on the <literal><phrase role="code">View</phrase></literal> interface as it has two matching subtypes in this case. Thus, we must configure the container to specify which alternative to use. Also note, that the beans in both cases have been annotated with <literal><phrase role="code">javax.enterprise.inject.Alternative</phrase></literal>.</simpara>
<simpara>In your <literal><phrase role="code">ErraiApp.properties</phrase></literal> for the module, you can simply specify which active alternative should be used:</simpara>
<programlisting language="ini" linenumbering="unnumbered">errai.ioc.enabled.alternatives=org.foo.MobileView</programlisting>
<simpara>You can specify multiple alternative classes by white space separating them:</simpara>
<programlisting language="ini" linenumbering="unnumbered">errai.ioc.enabled.alternatives=org.foo.MobileView \
                               org.foo.HTML5Orientation \
                               org.foo.MobileStorage</programlisting>
<simpara>You can only have one enabled alternative for a matching set of alternatives, otherwise you will get ambiguous resolution errors from the container.</simpara>
</section>
<section id="sid-22872238">
<title>Bean Lifecycle</title>
<simpara>All beans managed by the Errai IOC container support the <literal><phrase role="code">@PostConstruct</phrase></literal> and <literal><phrase role="code">@PreDestroy</phrase></literal> annotations.</simpara>
<simpara>Beans which have methods annotated with <literal><phrase role="code">@PostConstruct</phrase></literal> are guaranteed to have those methods called before the bean is put into service, and only after all dependencies within its graph has been satisfied.</simpara>
<simpara>Beans are also guaranteed to have their <literal><phrase role="code">@PreDestroy</phrase></literal> annotated methods called before they are destroyed by the bean manager.</simpara>
<important>
<simpara>This cannot be guaranteed when the browser DOM is destroyed prematurely due to: closing the browser window; closing a tab; refreshing the page, etc.</simpara>
</important>
<section id="sid-22872238_BeanLifecycle-DestructionofBeans">
<title>Destruction of Beans</title>
<simpara>Beans under management of Errai IOC, of any scope, can be explicitly destroyed through the client bean manager. Destruction of a managed bean is accomplished by passing a reference to the <literal><phrase role="code">destroyBean()</phrase></literal> method of the bean manager.</simpara>
<example>
<title>Destruction of bean</title>
<programlisting language="java" linenumbering="unnumbered">public MyManagedBean {
  @Inject SyncBeanManager manager;

  public void createABeanThenDestroyIt() {
    // get a new bean.
    SimpleBean bean = manager.lookupBean(SimpleBean.class).getInstance();

    bean.sendMessage("Sorry, I need to dispose of you now");

    // destroy the bean!
    manager.destroyBean(bean);
  }
}</programlisting>
</example>
<simpara>When the bean manager "destroys" the bean, any pre-destroy methods the bean declares are called, it is taken out of service and no longer tracked by the bean manager. If there are references on the bean by other objects, the bean will continue to be accessible to those objects.</simpara>
<important>
<simpara>Container managed resources that are dependent on the bean such as bus service endpoints or CDI event observers will also be automatically destroyed when the bean is destroyed.</simpara>
</important>
<simpara>Another important consideration is the rule, "all beans created together are destroyed together." Consider the following example:</simpara>
<example>
<title>SimpleBean.class</title>
<programlisting language="java" linenumbering="unnumbered">@Dependent
public class SimpleBean {
   @Inject @New AnotherBean anotherBean;

   public AnotherBean getAnotherBean() {
     return anotherBean;
   }

   @PreDestroy
   private void cleanUp() {
     // do some cleanup tasks
   }
}</programlisting>
</example>
<example>
<title>Destroying bean from subgraph</title>
<programlisting language="java" linenumbering="unnumbered">public MyManagedBean {
  @Inject SyncBeanManager manager;

  public void createABeanThenDestroyIt() {
    // get a new bean.
    SimpleBean bean = manager.lookupBean(SimpleBean.class).getInstance();

    // destroy the AnotherBean reference from inside the bean
    manager.destroyBean(bean.getAnotherBean());
  }
}</programlisting>
</example>
<simpara>In this example we pass the instance of <literal><phrase role="code">AnotherBean</phrase></literal>, created as a dependency of <literal><phrase role="code">SimpleBean</phrase></literal>, to the bean manager for destruction. Because this bean was created at the same time as its parent, its destruction will also result in the destruction of <literal><phrase role="code">SimpleBean</phrase></literal>; thus, this action will result in the <literal><phrase role="code">@PreDestroy</phrase></literal> <literal><phrase role="code">cleanUp()</phrase></literal> method of <literal><phrase role="code">SimpleBean</phrase></literal> being invoked.</simpara>
<section id="sid-22872238_BeanLifecycle-Disposers">
<title>Disposers</title>
<simpara>Another way which beans can be destroyed is through the use of the injectable <literal><phrase role="code">org.jboss.errai.ioc.client.api.Disposer&lt;T&gt;</phrase></literal> class. The class provides a straight forward way of disposing of bean type.</simpara>
<simpara>For instance:</simpara>
<example>
<title>Destroying bean with disposer</title>
<programlisting language="java" linenumbering="unnumbered">public MyManagedBean {
  @Inject @New SimpleBean myNewSimpleBean;
  @Inject Disposer&lt;SimpleBean&gt; simpleBeanDisposer;

  public void destroyMyBean() {
    simpleBeanDisposer.dispose(myNewSimpleBean);
  }
}</programlisting>
</example>
</section>
</section>
</section>
</chapter>
<chapter id="sid-19398999">
<title>Errai CDI</title>
<note>
<title>Manual Setup</title>
<simpara>Checkout the <link linkend="Manual-Setup-Section">Manual Setup Section</link> for instructions on how to manually add Errai CDI to your project.</simpara>
</note>
<simpara>CDI (Contexts and Dependency Injection) is the Java EE standard (JSR-299) for handling dependency injection. In addition to dependency injection, the standard encompasses component lifecycle, application configuration, call-interception and a decoupled, type-safe eventing specification.</simpara>
<simpara>The Errai CDI extension implements a subset of the specification for use inside of client-side applications within Errai, as well as additional capabilities such as distributed eventing.</simpara>
<simpara>Errai CDI does not currently implement all life cycles specified in JSR-299 or interceptors. These deficiencies may be addressed in future versions.</simpara>
<important>
<simpara>Errai CDI is implemented as an extension on top of the Errai IOC Framework (see <link linkend="sid-5931402">Dependency Injection</link>), which itself implements JSR-330. Inclusion of the CDI module your GWT project will result in the extensions automatically being loaded and made available to your application.</simpara>
</important>
<note>
<title>Classpath Scanning and ErraiApp.properties</title>
<simpara>Errai CDI only scans the contents of classpath locations (JARs and directories) that have <link linkend="sid-5931354">a file called
          ErraiApp.properties</link> at their META-INF directory. If CDI features such as dependency injection, event observation, and <literal><phrase role="code">@PostConstruct</phrase></literal> are not working for your classes, double-check that you have an <literal><phrase role="code">ErraiApp.properties</phrase></literal> at the META-INF directory of every JAR and directory tree that contains classes Errai should know about.</simpara>
</note>
<section id="sid-5931498">
<title>Features and Limitations</title>
<simpara>Beans that are deployed to a CDI container will automatically be registered with Errai and exposed to your GWT client application. So, you can use Errai to communicate between your GWT client components and your CDI backend beans.</simpara>
<simpara>Errai CDI based applications use the same annotation-driven programming model as server-side CDI components, with some notable limitations. Many of these limitations will be addressed in future releases.</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>There is no support for CDI interceptors in the client.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Passivating scopes are not supported.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The JSR-299 SPI is not supported for client side code. Although writing extensions for the client side container is possible via the Errai IOC Extensions API.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The <literal><phrase role="code">@Interceptor</phrase></literal> annotation is unsupported.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The <literal><phrase role="code">@Decorator</phrase></literal> annotation is unsupported.</simpara>
      
    </listitem>
  
</orderedlist>
<section id="sid-5931498_FeaturesandLimitations-Otherfeatures">
<title>Other features</title>
<simpara>The CDI container in Errai is built around the <link linkend="sid-5931402">Errai IOC module</link>, and thus is a superset of the existing functionality in Errai IOC. Thus, all features and APIs documented in Errai IOC are accessible and usable with this Errai CDI programming model.</simpara>
</section>
</section>
<section id="sid-21758054">
<title>Events</title>
<simpara>Any CDI managed component may produce and consume <ulink url="http://docs.jboss.org/weld/reference/latest/en-US/html/events.html">events</ulink>. This allows beans to interact in a completely decoupled fashion. Beans consume events by registering for a particular event type and optional qualifiers. The Errai CDI extension simply extends this concept into the client tier. A GWT client application can simply register an <literal><phrase role="code">Observer</phrase></literal> for a particular event type and thus receive events that are produced on the server-side. Likewise and using the same API, GWT clients can produce events that are consumed by a server-side observer.</simpara>
<simpara>Let&#8217;s take a look at an example.</simpara>
<example>
<title>FraudClient.java</title>
<programlisting language="java" linenumbering="unnumbered">public class FraudClient extends LayoutPanel {

  @Inject
  private Event&lt;AccountActivity&gt; event; (1)

  private HTML responsePanel;

  public FraudClient() {
    super(new BoxLayout(BoxLayout.Orientation.VERTICAL));
  }

  @PostConstruct
  public void buildUI() {
    Button button = new Button("Create activity", new ClickHandler() {
      public void onClick(ClickEvent clickEvent) {
        event.fire(new AccountActivity());
      }
    });
    responsePanel = new HTML();
    add(button);
    add(responsePanel);
  }

  public void processFraud(@Observes @Detected Fraud fraudEvent) { (2)
    responsePanel.setText("Fraud detected: " + fraudEvent.getTimestamp());
  }
}</programlisting>
</example>
<simpara>Two things are noteworthy in this example:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>Injection of an <literal><phrase role="code">Event</phrase></literal> dispatcher proxy</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Creation of an <literal><phrase role="code">Observer</phrase></literal> method for a particular event type</simpara>
      
    </listitem>
  
</orderedlist>
<simpara>The event dispatcher is responsible for sending events created on the client-side to the server-side event subsystem (CDI container). This means any event that is fired through a dispatcher will eventually be consumed by a CDI managed bean, if there is an corresponding <literal><phrase role="code">Observer</phrase></literal> registered for it on the server side.</simpara>
<simpara>In order to consume events that are created on the server-side you need to declare an client-side observer method for a particular event type. In case an event is fired on the server this method will be invoked with an event instance of type you declared.</simpara>
<simpara>To complete the example, let&#8217;s look at the corresponding server-side CDI bean:</simpara>
<example>
<title>AccountService.java</title>
<programlisting language="java" linenumbering="unnumbered">@ApplicationScoped
public class AccountService {

  @Inject @Detected
  private Event&lt;Fraud&gt; event;

  public void watchActivity(@Observes AccountActivity activity) {
    Fraud fraud = new Fraud(System.currentTimeMillis());
    event.fire(fraud);
 }
}</programlisting>
</example>
<important>
<title>Dependent-scope observers work differently in Errai</title>
<simpara>When an event is observed in a full CDI implementation (such as Weld), the container:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>Obtains an instance of the bean from the active context</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Invokes the observer method</simpara>
      
    </listitem>
  
</orderedlist>
<simpara>For dependent-scoped beans, there is no "active-context", so the container <emphasis role="strong">creates a new bean that is destroyed immediately after the observer method is invoked</emphasis>.</simpara>
<simpara>Errai does not behave this way with client-side, dependent-scoped observers. Instead when an event is fired, Errai will invoke the relevant observer method on <emphasis role="strong">every dependent-scoped bean that has already been instantiated</emphasis> (i.e. zero or more observers can be invoked).</simpara>
</important>
<section id="sid-21758054_Events-Conversationalevents">
<title>Conversational events</title>
<simpara>A server can address a single client in response to an event annotating event types as <literal><phrase role="code">@Conversational</phrase></literal>. Consider a service that responds to a subscription event.</simpara>
<example>
<title>SubscriptionService.java</title>
<programlisting language="java" linenumbering="unnumbered">@ApplicationScoped
public class SubscriptionService {

  @Inject
  private Event&lt;Documents&gt; welcomeEvent;

  public void onSubscription(@Observes Subscription subscription) {
    Document docs = createWelcomePackage(subscription);
    welcomeEvent.fire(docs);
 }
}</programlisting>
</example>
<simpara>And the <literal><phrase role="code">Document</phrase></literal> class would be annotated like so:</simpara>
<example>
<title>Document.java</title>
<programlisting language="java" linenumbering="unnumbered">@Conversational @Portable
public class Document {
   // code here
}</programlisting>
</example>
<simpara>As such, when <literal><phrase role="code">Document</phrase></literal> events are fired, they will be limited in scope to the initiating conversational contents which are implicitly inferred by the caller. So only the client which fired the <literal><phrase role="code">Subscription</phrase></literal> event will receive the fired <literal><phrase role="code">Document</phrase></literal> event.</simpara>
</section>
<section id="_local_events">
<title>Local Events</title>
<simpara>The simplest way to stop a CDI Event from being broadcast over the wire is to avoid annotating the type with <literal>@Portable</literal>. But in some cases you may wish to send a type over the network with Errai RPC or the Message Bus, but only fire it locally as a CDI Event.</simpara>
<simpara>This can be accomplished by annotating a type with <literal>@LocalEvent</literal>, as in this example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Portable @LocalEvent
public DocumentChange {
  private String diff;

  public String getDiff() {
    return diff;
  }

  public void setDiff(String diff) {
    this.diff = diff;
  }
}</programlisting>
<simpara>Because of the <literal>@Portable</literal> annotation instances of <literal>DocumentChange</literal> can be sent over the wire via RPC calls or bus messages, but because of the <literal>@LocalEvent</literal> annotation they will not be sent over the network if fired via a CDI Event.</simpara>
</section>
<section id="sid-21758054_Events-ClientServerEventExample">
<title>Client-Server Event Example</title>
<simpara>A key feature of the Errai CDI framework is the ability to federate the CDI eventing bus between the client and the server. This permits the observation of server produced events on the client, and vice-versa.</simpara>
<simpara>Example server code:</simpara>
<example>
<title>MyServerBean.java</title>
<programlisting language="java" linenumbering="unnumbered">@ApplicationScoped
public class MyServerBean {
  @Inject
  Event&lt;MyResponseEvent&gt; myResponseEvent;

  public void myClientObserver(@Observes MyRequestEvent event) {
    MyResponseEvent response;

    if (event.isThankYou()) {
      // aww, that's nice!
      response = new MyResponseEvent("Well, you're welcome!");
    }
    else {
      // how rude!
      response = new MyResponseEvent("What? Nobody says 'thank you' anymore?");
    }

    myResponseEvent.fire(response);
  }
}</programlisting>
</example>
<simpara>Domain-model:</simpara>
<example>
<title>MyRequestEvent.java</title>
<programlisting language="java" linenumbering="unnumbered">@Portable
public class MyRequestEvent {
  private boolean thankYou;

  public MyRequestEvent(boolean thankYou) {
    setThankYou(thankYou);
  }

  public void setThankYou(boolean thankYou) {
    this.thankYou = thankYou;
  }

  public boolean isThankYou() {
    return thankYou;
  }
}</programlisting>
</example>
<example>
<title>MyResponseEvent.java</title>
<programlisting language="java" linenumbering="unnumbered">@Portable
public class MyResponseEvent {
  private String message;

  public MyRequestEvent(String message) {
    setMessage(message);
  }

  public void setMessage(String message) {
    this.message = message;
  }

  public String getMessage() {
    return message;
  }
}</programlisting>
</example>
<simpara>Client application logic:</simpara>
<example>
<title>MyClientBean.java</title>
<programlisting language="java" linenumbering="unnumbered">@EntryPoint
public class MyClientBean {
   @Inject
   Event&lt;MyRequestEvent&gt; requestEvent;

   public void myResponseObserver(@Observes MyResponseEvent event) {
     Window.alert("Server replied: " + event.getMessage());
   }

   @PostConstruct
   public void init() {
     Button thankYou = new Button("Say Thank You!");
     thankYou.addClickHandler(new ClickHandler() {
       public void onClick(ClickEvent event) {
         requestEvent.fire(new MyRequestEvent(true));
       }
     }

     Button nothing = new Button("Say nothing!");
     nothing.addClickHandler(new ClickHandler() {
       public void onClick(ClickEvent event) {
         requestEvent.fire(new MyRequestEvent(false));
       }
     }

     VerticalPanel vPanel = new VerticalPanel();
     vPanel.add(thankYou);
     vPanel.add(nothing);

     RootPanel.get().add(vPanel);
   }
}</programlisting>
</example>
</section>
</section>
<section id="sid-21758062">
<title>Producers</title>
<simpara>Producer methods and fields act as sources of objects to be injected. They are useful when additional control over object creation is needed before injections can take place e.g. when you need to make a decision at runtime before an object can be created and injected.</simpara>
<example>
<title>App.java</title>
<programlisting language="java" linenumbering="unnumbered">@EntryPoint
public class App {
  ...

  @Produces @Supported
  private MyBaseWidget createWidget() {
    return (Canvas.isSupported()) ? new MyHtml5Widget() : new MyDefaultWidget();
  }
}</programlisting>
</example>
<example>
<title>MyComposite.java</title>
<programlisting language="java" linenumbering="unnumbered">@ApplicationScoped
public class MyComposite extends Composite {

  @Inject @Supported
  private MyBaseWidget widget;

  ...
}
</programlisting>
</example>
<simpara>Producers can also be scoped themselves. By default, producer methods are dependent-scoped, meaning they get called every time an injection for their provided type is requested. If a producer method is scoped <literal><phrase role="code">@Singleton</phrase></literal> for instance, the method will only be called once, and the bean manager will inject the instance from the first invokation of the producer into every matching injection point.</simpara>
<example>
<title>Singleton producer</title>
<programlisting language="java" linenumbering="unnumbered">public class App {
  ...

  @Produces @Singleton
  private MyBean produceMyBean() {
    return new MyBean();
  }
}</programlisting>
</example>
<simpara>For more information on CDI producers, see the <ulink url="http://docs.jboss.org/cdi/spec/1.0/html/">CDI specification</ulink> and the <ulink url="http://seamframework.org/Weld/WeldDocumentation">WELD reference documentation</ulink>.</simpara>
</section>
<section id="sid-53118110">
<title>Safe dynamic lookup</title>
<simpara>As an alternative to using the bean manager to dynamically create beans, this can be accomplished in a type-safe way by injecting a <literal><phrase role="code">javax.enterprise.inject.Instance&lt;T&gt;</phrase></literal>.</simpara>
<simpara>For instance, assume you have a dependent-scoped bean <literal><phrase role="code">Bar</phrase></literal> and consider the following:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Foo {
  @Inject Instance&lt;Bar&gt; barInstance;

  public void pingNewBar() {
    Bar bar = barInstance.get();
    bar.ping();
  }
}</programlisting>
<simpara>In this example, calling <literal><phrase role="code">barInstance.get()</phrase></literal> returns a new instance of the dependent-scoped bean <literal><phrase role="code">Bar</phrase></literal>.</simpara>
</section>
<section id="sid-5931501">
<title>Deploying Errai CDI</title>
<simpara>The CDI integration is a plugin to the Errai core framework and represents a CDI portable extension. Which means it is discovered automatically by both Errai and the CDI container. In order to use it, you first need to understand the different runtime models involved when working GWT, Errai, and CDI.</simpara>
<simpara>Typically a GWT application lifecycle begins in <ulink url="http://code.google.com/webtoolkit/doc/latest/DevGuideCompilingAndDebugging.html">Development Mode</ulink> and finally a web application containing the GWT client code will be deployed to a target container (Servlet Engine, Application Server). This is no way different when working with CDI components to back your application.</simpara>
<simpara>What&#8217;s different however is availability of the CDI container across the different runtimes. In GWT development mode and in a pure servlet environment you need to provide and bootstrap the CDI environment on your own. While any Java EE 6 Application Server already provides a preconfigured CDI container. To accomodate these differences, we need to do a little trickery when executing the GWT Development Mode and packaging our application for deployment.</simpara>
<note>
<title>Manual Setup</title>
<simpara>Checkout the <link linkend="Manual-Setup-Section">Manual Setup Section</link> for instructions on how to manually setup Errai CDI in Development Mode.</simpara>
</note>
</section>
</chapter>
<chapter id="sid-5931328">
<title>Marshalling</title>
<simpara>Errai includes a comprehensive marshalling framework which permits the serialization of domain objects between the browser and the server. From the perspective of GWT, this is a complete replacement for the provided GWT serialization facilities and offers a great deal more flexibility. You can use it with your own application-specific domain models as well as preexisting models, including classes from third-party libraries using configuration files or the custom definitions API.</simpara>
<section id="sid-5931328_Marshalling-MappingYourDomain">
<title>Mapping Your Domain</title>
<simpara>All classes that you intend to be marshalled between the client and the server must be exposed to the marshalling framework explicitly. There are several ways to do that, and this section will take you through the different approaches.</simpara>
<section id="sid-5931328_Marshalling-@Portableand@NonPortable">
<title>@Portable and @NonPortable</title>
<simpara>The easiest way to make a Java class eligible for serialization with Errai Marshalling is to mark it with the <literal><phrase role="code">org.jboss.errai.common.client.api.annotations.Portable</phrase></literal> annotation. This tells the marshalling system to generate marshalling and demarshalling code for the annotated class and all of its nested classes.</simpara>
<simpara>The mapping strategy that will be used depends on how much information you provide about your model up-front. If you simply annotate a domain type with <literal><phrase role="code">@Portable</phrase></literal> and do nothing else, the marshalling system will use an exhaustive strategy to determine how to serialize and deserialize instances of that type and its nested types.</simpara>
<simpara>The Errai marshalling system works by enumerating all of the Portable types it can find (by any of the three methods discussed in this section of the reference guide), eliminating all the non-portable types it can find (via <literal><phrase role="code">@NonPortable</phrase></literal> annotations and entries in <literal><phrase role="code">ErraiApp.properties</phrase></literal>), then enumerating the marshallable properties that make up each remaining portable entity type. The rules that Errai uses for enumerating the properties of a portable entity type are as follows:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>If an entity type has a field called <literal><phrase role="code">foo</phrase></literal>, then that entity has a property called <literal><phrase role="code">foo</phrase></literal> unless the field is marked <literal><phrase role="code">static</phrase></literal> or <literal><phrase role="code">transient</phrase></literal>.</simpara>
      
    </listitem>
  
</itemizedlist>

<simpara>Note that the existence of methods called <literal><phrase role="code">getFoo()</phrase></literal>, <literal><phrase role="code">setFoo()</phrase></literal>, or both, <emphasis>does not</emphasis> mean that the entity has a property called <literal><phrase role="code">foo</phrase></literal>. Errai Marshalling always works from fields when discovering properties.</simpara>
<simpara>When reading a field <literal><phrase role="code">foo</phrase></literal>, Errai Marshalling will call the method <literal><phrase role="code">getFoo()</phrase></literal> in preference to direct field access if the <literal><phrase role="code">getFoo()</phrase></literal> method exists.</simpara>
<simpara>When writing a field <literal><phrase role="code">foo</phrase></literal>, Errai Marshalling gives first preference to a parameter of the <emphasis>mapping constructor</emphasis> (defined below) annotated with <literal><phrase role="code">@MapsTo("foo")</phrase></literal>. Failing this, Errai Marshalling will the method <literal><phrase role="code">setFoo()</phrase></literal> if it exists. As a last resort, Errai Marshalling will use direct field access to write the value of <literal><phrase role="code">foo</phrase></literal>.</simpara>
<simpara>Each field is mapped independently according to the above priority rules. Portable classes can rely on a mix of constructor, setter/getter, and field access.</simpara>
<simpara>For de-marshalling a <literal><phrase role="code">@Portable</phrase></literal> type, Errai must know how to obtain a new instance of that type. To do this, it selects a <emphasis>mapping constructor</emphasis> (which could literally be a constructor, but could also be a static factory method) using the following rules:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>If the entity has a constructor where every argument is annotated with <literal><phrase role="code">@MapsTo</phrase></literal>, then this is the mapping constructor. The constructor doesn&#8217;t have to be public.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Otherwise, if the entity has a public static method whose return type matches the entity type and every argument is annotated with <literal><phrase role="code">@MapsTo</phrase></literal>, then it is the mapping constructor. Unlike a constructor, such a method is free to return an instance of a subtype of the marshalled type, or resolve an instance from a cache. In this case, do keep in mind that left-over properties not covered by the method&#8217;s <literal><phrase role="code">@MapsTo</phrase></literal> parameters will still be written by setters and direct field access.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Otherwise, if the entity has a public no-arguments constructor (including the one the Java compiler provides in the absence of explicit constructors), it is the mapping constructor.</simpara>
      
    </listitem>
  
</itemizedlist>

<simpara>If no suitable mapping constructor can be found on a type marked <literal><phrase role="code">@Portable</phrase></literal>, it is a compile-time error.</simpara>
<simpara>Now let&#8217;s take a look at some common examples of how this works.</simpara>
<section id="sid-5931328_Marshalling-Example%3AASimpleEntity">
<title>Example: A Common Mutable Bean</title>
<programlisting language="java" linenumbering="unnumbered">@Portable
public class Person {
  private String name;
  private int age;

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public int getAge() {
    return age;
  }

  public void setAge(int age) {
    this.age = age;
  }
}</programlisting>
<simpara>This class is a straightforward mutable bean. Errai will read and write the name and age properties via the setter and getter methods. It will create new instances of the type using the default no-args public constructor that the Java compiler generated implicitly.</simpara>
</section>
<section id="sid-5931328_Marshalling-Example%3AAnImmutableEntitywithaPublicConstructor">
<title>Example: An Immutable Entity with a Public Constructor</title>
<simpara>It&#8217;s always good to aim for truly immutabile value types wherever practical, and Errai&#8217;s marshalling system does not force you to compromise on this ideal.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Portable
public final class Person {
  private final String name;
  private final int age;

  public Person(@MapsTo("name") String name, @MapsTo("age") int age) {
    this.name = name;
    this.age = age;
  }

  public String getName() {
    return name;
  }

  public int getAge() {
    return age;
  }
}</programlisting>
<simpara>Both fields are final, so they cannot be written by setter methods or by direct field access. But that&#8217;s okay, because we have given Errai a way to set them using the annotated constructor parameters.</simpara>
</section>
<section id="sid-5931328_Marshalling-Example%3AAnImmutableEntitywithaFactoryMethod">
<title>Example: An Immutable Entity with a Factory Method</title>
<simpara>Another good practice is to use a factory pattern to enforce invariance. Once again, let&#8217;s modify our example.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Portable
public class Person {
  private final String name;
  private final int age;

  private Person(String name, int age) {
    this.name = name;
    this.age = age;
  }

  public static Person createPerson(@MapsTo("name") String name, @MapsTo("age") int age) {
    return new Person(name, age);
  }

  public String getName() {
    return name;
  }

  public int getAge() {
    return age;
  }
}</programlisting>
<simpara>Here we have made our only declared constructor private, and created a static factory method. Notice that we&#8217;ve simply used the same <literal><phrase role="code">@MapsTo</phrase></literal> annotation in the same way we did on the constructor from our previous example. The marshaller will see this method and know that it should use it to construct the object.</simpara>
</section>
<section id="sid-5931328_Marshalling-Example%3AAnImmutableEntitywithaBuilder">
<title>Example: An Immutable Entity with a Builder</title>
<simpara>For types with a large number of optional attributes, a builder is often the best approach.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Portable
public class Person {
  private final String name;
  private final int age;

  private Person(@MapsTo("name") String name, @MapsTo("age") int age) {
    this.name = name;
    this.age = age;
  }

  public String getName() {
    return name;
  }

  public int getAge() {
    return age;
  }

  @NonPortable
  public static class Builder {
    private String name;
    private int age;

    public Builder name(String name) {
      this.name = name;
      return this;
    }

    public Builder age(int age) {
      this.age = age;
      return this;
    }

    public Person build() {
      return new Person(name, age);
    }
  }
}</programlisting>
<simpara>In this example, we have a nested <literal><phrase role="code">Builder</phrase></literal> class that implements the Builder Pattern and calls the private <literal><phrase role="code">Person</phrase></literal> constructor. Hand-written code will always use the builder to create <literal><phrase role="code">Person</phrase></literal> instances, but the <literal><phrase role="code">@MapsTo</phrase></literal> annotations on the private <literal><phrase role="code">Person</phrase></literal> constructor tell Errai Marshalling to bypass the builder and construct instances of Person directly.</simpara>
<simpara>One final note: as a nested type of <literal><phrase role="code">Person</phrase></literal> (which is marked <literal><phrase role="code">@Portable</phrase></literal>), the builder itself would normally be portable. However, we do not intend to move instances of <literal><phrase role="code">Person.Builder</phrase></literal> across the network, so we mark <literal><phrase role="code">Person.Builder</phrase></literal> as <literal><phrase role="code">@NonPortable</phrase></literal>.</simpara>
</section>
</section>
<section id="sid-5931328_Marshalling-ManualMapping">
<title>Manual Mapping</title>
<simpara>Some classes may be out of your control, making it impossible to annotate them for auto-discovery by the marshalling framework. For cases such as this, there are two approaches to include these classes in your application.</simpara>
<simpara>The first approach is the easiest, but is contingent on whether or not the class is directly exposed to the GWT compiler. That means, the classes must be part of a GWT module and within the GWT client packages. See the GWT documentation on <ulink url="http://code.google.com/webtoolkit/doc/latest/DevGuideCodingBasicsClient.html">Client-Side Code</ulink> for information on this.</simpara>
<section id="sid-5931328_Marshalling-MappingExistingClientClassesx">
<title>Mapping Existing Client Classes</title>
<simpara>If you have client-exposed classes that cannot be annotated with the <literal><phrase role="code">@Portable</phrase></literal> annotation, you may manually map these classes so that the marshaller framework will comprehend and produce marshallers for them and their nested types.</simpara>
<simpara>To do this, specify them in <emphasis>ErraiApp.properties</emphasis>, using the <literal><phrase role="code">errai.marshalling.serializableTypes</phrase></literal> attribute with a whitespace separated list of classes to make portable.</simpara>
<example>
<title>Example ErraiApp.properties defining portable classes.</title>
<programlisting language="ini" linenumbering="unnumbered">errai.marshalling.serializableTypes=org.foo.client.UserEntity \
                                    org.foo.client.GroupEntity \
                                    org.abcinc.model.client.Profile</programlisting>
</example>
<simpara>If any of the serializable types have nested classes that you wish to make non-portable, you can specify them like this:</simpara>
<example>
<title>Example ErraiApp.properties defining nonportable classes.</title>
<programlisting language="ini" linenumbering="unnumbered">errai.marshalling.nonserializableTypes=org.foo.client.UserEntity$Builder \
                                       org.foo.client.GroupEntity$Builder</programlisting>
</example>
</section>
<section id="sid-5931328_Marshalling-AliasedMappingsofExistingInterfaceContracts">
<title>Aliased Mappings of Existing Interface Contracts</title>
<simpara>The marshalling framework supports and promotes the concept of marshalling by interface contract, where possible. For instance, the framework ships with a marshaller which can marshall data to and from the <literal><phrase role="code">java.util.List</phrase></literal> interface. Instead of having custom marshallers for classes such as <literal><phrase role="code">ArrayList</phrase></literal> and <literal><phrase role="code">LinkedList</phrase></literal>, by default, these implementations are merely aliased to the <literal><phrase role="code">java.util.List</phrase></literal> marshaller.</simpara>
<simpara>There are two distinct ways to go about doing this. The most straightforward is to specify which marshaller to alias when declaring your class is <literal><phrase role="code">@Portable</phrase></literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">package org.foo.client;

@Portable(aliasOf = java.util.List.class)
public MyListImpl extends ArrayList {
  // .. //
}</programlisting>
<simpara>In the case of this example, the marshaller will not attempt to comprehend your class. Instead, it will merely rely on the <literal><phrase role="code">java.util.List</phrase></literal> marshaller to dematerialize and serialize instances of this type onto the wire.</simpara>
<simpara>If for some reason it is not feasible to annotate the class, directly, you may specify the mapping in the <emphasis>ErraiApp.properties</emphasis> file using the <literal><phrase role="code">errai.marshalling.mappingAliases</phrase></literal> attribute.</simpara>
<programlisting language="ini" linenumbering="unnumbered">errai.marshalling.mappingAliases=org.foo.client.MyListImpl-&gt;java.util.List \
                                 org.foo.client.MyMapImpl-&gt;java.util.Map</programlisting>
<simpara>The list of classes is whitespace-separated so that it may be split across lines.</simpara>
<simpara>The example above shows the equivalent mapping for the <literal><phrase role="code">MyListImpl</phrase></literal> class from the previous example, as well as a mapping of a class to the <literal><phrase role="code">java.util.Map</phrase></literal> marshaller.</simpara>
<simpara>The syntax of the mapping is as follows: <literal><phrase role="code">&lt;class_to_map&gt;</phrase></literal><emphasis>&#8594;</emphasis><literal><phrase role="code">&lt;contract_to_map_to&gt;</phrase></literal>.</simpara>
<important>
<title>Aliases do not inherit fields!</title>
<simpara>When you alias a class to another marshalling contract, extended fields of the aliased class will not be available upon deserialization. For this you must provide custom marshallers for those classes.</simpara>
</important>
</section>
</section>
<section id="sid-5931328_Marshalling-ManualClassMapping">
<title>Manual Class Mapping</title>
<simpara>Although the default marshalling strategies in Errai Marshalling will suit the vast majority of use cases, there may be situations where it is necessary to manually map your classes into the marshalling framework to teach it how to construct and deconstruct your objects.</simpara>
<simpara>This is accomplished by specifying <literal><phrase role="code">MappingDefinition</phrase></literal> classes which inform the framework exactly how to read and write state in the process of constructing and deconstructing objects.</simpara>
<section id="sid-5931328_Marshalling-MappingDefinition">
<title>MappingDefinition</title>
<simpara>All manual mappings should extend the <literal><phrase role="code">org.jboss.errai.marshalling.rebind.api.model.MappingDefinition</phrase></literal> class. This is base metadata class which contains data on exactly how the marshaller can deconstruct and construct objects.</simpara>
<simpara>Consider the following class:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class MySuperCustomEntity {
   private final String mySuperName;
   private String mySuperNickname;

   public MySuperCustomEntity(String mySuperName) {
     this.mySuperName = mySuperName;;
   }

   public String getMySuperName() {
     return this.mySuperName;
   }

   public void setMySuperNickname(String mySuperNickname) {
     this.mySuperNickname = mySuperNickname;
   }

   public String getMySuperNickname() {
     return this.mySuperNickname;
   }
}</programlisting>
<simpara>Let us construct this object like so:</simpara>
<programlisting language="java" linenumbering="unnumbered">  MySuperCustomEntity entity = new MySuperCustomEntity("Coolio");
  entity.setSuperNickname("coo");</programlisting>
<simpara>It is clear that we may rely on this object&#8217;s two getter methods to extract the totality of its state. But due to the fact that the <literal><phrase role="code">mySuperName</phrase></literal> field is final, the only way to properly construct this object is to call its only public constructor and pass in the desired value of <literal><phrase role="code">mySuperName</phrase></literal>.</simpara>
<simpara>Let us consider how we could go about telling the marshalling framework to pull this off:</simpara>
<programlisting language="java" linenumbering="unnumbered">@CustomMapping
public MySuperCustomEntityMapping extends MappingDefinition {
  public MySuperCustomEntityMapping() {
    super(MySuperCustomEntity.class);                                                          // (1)

    SimpleConstructorMapping cnsMapping = new SimpleConstructorMapping();
    cnsMapping.mapParmToIndex("mySuperName", 0, String.class);                                 // (2)

    setInstantiationMapping(cnsMapping);

    addMemberMapping(new WriteMapping("mySuperNickname", String.class, "setMySuperNickname")); // (3)

    addMemberMapping(new ReadMapping("mySuperName", String.class, "getMySuperName"));          // (4)
    addMemberMapping(new ReadMapping("mySuperNickname", String.class, "getMySuperNickname"));  // (5)
  }
}</programlisting>
<simpara>And that&#8217;s it. This describes to the marshalling framework how it should go about constructing and deconstructing <literal><phrase role="code">MySuperCustomEntity</phrase></literal>.</simpara>
<simpara>Paying attention to our annotating comments, let&#8217;s describe what we&#8217;ve done here.</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>Call the constructor in <literal><phrase role="code">MappingDefinition</phrase></literal> passing our reference to the class we are mapping.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Using the <literal><phrase role="code">SimpleConstructorMapping</phrase></literal> class, we have indicated that a custom constructor will be needed to instantiate this class. We have called the <literal><phrase role="code">mapParmToIndex</phrase></literal> method with three parameters. The first, <literal><phrase role="code">"mySupername"</phrase></literal> describes the class field that we are targeting. The second parameter, the integer <literal><phrase role="code">0</phrase></literal> indicates the parameter index of the constructor arguments that we&#8217;ll be providing the value for the aforementioned field in this case the first and only, and the final parameter <literal><phrase role="code">String.class</phrase></literal> tells the marshalling framework which marshalling contract to use in order to de-marshall the value.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Using the <literal><phrase role="code">WriteMapping</phrase></literal> class, we have indicated to the marshaller framework how to write the <literal><phrase role="code">"mySuperNickname"</phrase></literal> field, using the <literal><phrase role="code">String.class</phrase></literal> marshaller, and using the setter method <literal><phrase role="code">setMySuperNickname</phrase></literal>.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Using the <literal><phrase role="code">ReadMapping</phrase></literal> class, we have indicated to the marshaller framework how to read the <literal><phrase role="code">"mySuperName"</phrase></literal> field, using the <literal><phrase role="code">String.class</phrase></literal> marshaller, and using the getter method <literal><phrase role="code">getMySuperName</phrase></literal>.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Using the <literal><phrase role="code">ReadMapping</phrase></literal> class, we have indicated to the marshaller framework how to read the <literal><phrase role="code">"mySuperNickname"</phrase></literal> field, using the <literal><phrase role="code">String.class</phrase></literal> marshaller, and using the getter method <literal><phrase role="code">getMySuperNickname</phrase></literal>.</simpara>
      
    </listitem>
  
</orderedlist>
</section>
</section>
<section id="sid-5931328_Marshalling-CustomMarshallers">
<title>Custom Marshallers</title>
<simpara>There is another approach to extending the marshalling functionality that doesn&#8217;t involve mapping rules, and that is to implement your own <literal><phrase role="code">Marshaller</phrase></literal> class. This gives you complete control over the parsing and emission of the JSON structure.</simpara>
<simpara>The implementation of marshallers is made relatively straight forward by the fact that both the server and the client share the same JSON parsing API.</simpara>
<simpara>Consider the included <literal><phrase role="code">java.util.Date</phrase></literal> marshaller that comes built-in to the marshalling framework:</simpara>
<example>
<title>DataMarshaller.java from the built-in marshallers</title>
<programlisting language="java" linenumbering="unnumbered">@ClientMarshaller(Date.class)
@ServerMarshaller(Date.class)
public class DateMarshaller extends AbstractNullableMarshaller&lt;Date&gt; {
  @Override
  public Date[] getEmptyArray() {
    return new Date[0];
  }

  @Override
  public Date doNotNullDemarshall(final EJValue o, final MarshallingSession ctx) {
    if (o.isObject() != null) {
      EJValue qualifiedValue = o.isObject().get(SerializationParts.QUALIFIED_VALUE);
      if (!qualifiedValue.isNull() &amp;&amp; qualifiedValue.isString() != null) {
        return new Date(Long.parseLong(qualifiedValue.isString().stringValue()));
      }
      EJValue numericValue = o.isObject().get(SerializationParts.NUMERIC_VALUE);
      if (!numericValue.isNull() &amp;&amp; numericValue.isNumber() != null) {
        return new Date(new Double(numericValue.isNumber().doubleValue()).longValue());
      }
      if (!numericValue.isNull() &amp;&amp; numericValue.isString() != null) {
        return new Date(Long.parseLong(numericValue.isString().stringValue()));
      }
    }

    return null;
  }

  @Override
  public String doNotNullMarshall(final Date o, final MarshallingSession ctx) {
    return "{\"" + SerializationParts.ENCODED_TYPE + "\":\"" + Date.class.getName() + "\"," +
            "\"" + SerializationParts.OBJECT_ID + "\":\"" + o.hashCode() + "\"," +
            "\"" + SerializationParts.QUALIFIED_VALUE + "\":\"" + o.getTime() + "\"}";
  }
}</programlisting>
</example>
<simpara>The class is annotated with both <literal><phrase role="code">@ClientMarshaller</phrase></literal> and <literal><phrase role="code">@ServerMarshaller</phrase></literal> indicating that this class should be used for both marshalling on the client and on the server.</simpara>
<simpara>The <literal><phrase role="code">doNotNullDemarshall()</phrase></literal> method is responsible for converting the given JSON object (which has already been parsed and verified non-null) into a Java object.</simpara>
<simpara>The <literal><phrase role="code">doNotNullMarshall()</phrase></literal> method does roughly the inverse: it converts the given Java object into a String (which must be parseable as a JSON object) for transmission on the wire.</simpara>
</section>
</section>
</chapter>
<chapter id="sid-5931313">
<title>Remote Procedure Calls (RPC)</title>
<simpara>ErraiBus supports a high-level RPC layer to make typical client-server RPC communication easy on top of the bus. While it is possible to use ErraiBus without ever using this API, you may find it to be a more useful and concise approach for exposing services to the clients.</simpara>
<simpara>Please note that this API has changed since version 1.0. RPC services provide a way of creating type-safe mechanisms to make client-to-server calls. Currently, this mechanism only support client-to-server calls, and not vice-versa.</simpara>
<note>
<title>Manual Setup</title>
<simpara>Checkout the <link linkend="Manual-Setup-Section">Manual Setup Section</link> for instructions on how to manually add Errai Messaging or Errai CDI to a project.</simpara>
</note>
<section id="_creating_an_rpc_interface">
<title>Creating an RPC Interface</title>
<simpara>Creating a service is straight forward. It requires the definition of a remote interface, and a service class which implements it. See the following:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Remote
public interface MyRemoteService {
  public boolean isEveryoneHappy();
}</programlisting>
<simpara>The <literal><phrase role="code">@Remote</phrase></literal> annotation tells Errai that we&#8217;d like to use this interface as a remote interface. The remote interface must be part of of the GWT client code. It cannot be part of the server-side code, since the interface will need to be referenced from both the client and server side code. That said, the implementation of a service is relatively simple to the point:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Service
public class MyRemoteServiceImpl implements MyRemoteService {

  public boolean isEveryoneHappy() {
    // blatently lie and say everyone's happy.
    return true;
  }
}</programlisting>
<simpara>That&#8217;s all there is to it. You use the same <literal><phrase role="code">@Service</phrase></literal> annotation as described in Section 2.4. The presence of the remote interface tips Errai off as to what you want to do with the class.</simpara>
<warning>
<simpara>Beginning with Errai 2.0.CR1, the default for automatic service discovery has changed in favour of CDI based applications, meaning RPC service discovery must be explicitly turned on in case Errai CDI is not used (the <literal><phrase role="code">weld-integration.jar</phrase></literal> is not on the classpath). This can be done using an init-param in the servlet config of your web.xml:</simpara>
</warning>
<programlisting language="xml" linenumbering="unnumbered">&lt;servlet&gt;
  &lt;servlet-name&gt;ErraiServlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;org.jboss.errai.bus.server.servlet.DefaultBlockingServlet&lt;/servlet-class&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;auto-discover-services&lt;/param-name&gt;
    &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;</programlisting>
</section>
<section id="sid-5931313_RemoteProcedureCalls%28RPC%29-Makingcalls">
<title>Making calls</title>
<simpara>Calling a remote service involves use of the <literal><phrase role="code">MessageBuilder</phrase></literal> API. Since all messages are asynchronous, the actual code for calling the remote service involves the use of a callback, which we use to receive the response from the remote method. Let&#8217;s see how it works:</simpara>
<programlisting language="java" linenumbering="unnumbered">MessageBuilder.createCall(new RemoteCallback&lt;Boolean&gt;() {
  public void callback(Boolean isHappy) {
    if (isHappy) Window.alert("Everyone is happy!");
  }
 }, MyRemoteService.class).isEveryoneHappy();
</programlisting>
<simpara>In the above example, we declare a remote callback that receives a Boolean, to correspond to the return value of the method on the server. We also reference the remote interface we are calling, and directly call the method. However, <emphasis>don&#8217;t be tempted to write code like this</emphasis>:</simpara>
<programlisting language="java" linenumbering="unnumbered"> boolean bool = MessageBuilder.createCall(..., MyRemoteService.class).isEveryoneHappy();</programlisting>
<simpara>The above code will never return a valid result. In fact, it will always return null, false, or 0 depending on the type. This is due to the fact that the method is dispatched asynchronously, as in, it does not wait for a server response before returning control. The reason we chose to do this, as opposed to emulate the native GWT-approach, which requires the implementation of remote and async interfaces, was purely a function of a tradeoff for simplicity.</simpara>
<section id="sid-5931313_RemoteProcedureCalls%28RPC%29-ProxyInjection">
<title>Proxy Injection</title>
<simpara>An alternative to using the <literal><phrase role="code">MessageBuilder</phrase></literal> API is to have a proxy of the service injected.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Inject
private Caller&lt;MyRemoteService&gt; remoteService;</programlisting>
<simpara>For calling the remote service, the callback objects need to be provided to the <literal><phrase role="code">call</phrase></literal> method before the corresponding interface method is invoked.</simpara>
<programlisting language="java" linenumbering="unnumbered">remoteService.call(callback).isEveryoneHappy();</programlisting>
<simpara>The Errai IOC GWT module needs to be inherited to make use of caller injection. To do this, the following line needs to be added to the application&#8217;s <literal><phrase role="code">*.gwt.xml</phrase></literal> file. It is important that this line comes <literal><phrase role="code">after</phrase></literal> the Errai Bus module:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;inherits name="org.jboss.errai.ioc.Container"/&gt;</programlisting>
</section>
</section>
<section id="sid-5931313_RemoteProcedureCalls%28RPC%29-Handlingexceptions">
<title>Handling exceptions</title>
<simpara>Handling remote exceptions can be done by providing an <literal><phrase role="code">ErrorCallback</phrase></literal> on the client:</simpara>
<programlisting language="java" linenumbering="unnumbered">MessageBuilder.createCall(
  new RemoteCallback&lt;Boolean&gt;() {
    public void callback(Boolean isHappy) {
      if (isHappy) Window.alert("Everyone is happy!");
    }
  },
  new ErrorCallback() {
    public boolean error(Message message, Throwable caught) {
      try {
        throw caught;
      }
      catch (NobodyIsHappyException e) {
        Window.alert("OK, that's sad!");
      }
      catch (Throwable t) {
        GWT.log("An unexpected error has occurred", t);
      }
      return false;
    }
  },
  MyRemoteService.class).isEveryoneHappy();</programlisting>
<simpara>As remote exceptions need to be serialized to be sent to the client, the <literal><phrase role="code">@Portable</phrase></literal> annotation needs to be present on the corresponding exception class (see <link linkend="sid-5931328">Marshalling</link>). Further the exception class needs to be part of the client-side code. For more details on <literal><phrase role="code">ErrorCallbacks</phrase></literal> see <link linkend="sid-5931306">Handling Errors</link>.</simpara>
<section id="sid-5931313_RemoteProcedureCalls%28RPC%29-GlobalRPCexceptionhandler">
<title>Global RPC exception handler</title>
<simpara>In a scenario where many different remote calls potentially throw the same exception types (e.g. exceptions related to authentication or authorization) it can be easier to register a global exception handler instead of providing error callbacks at each RPC invocation. This global exception handler is called in case an exception occurs in the process of a remote call that has no error callback associated with it. So, it will handle an otherwise uncaught exception.</simpara>
<programlisting language="java" linenumbering="unnumbered">@UncaughtExceptionHandler
private void onUncaughtException(Throwable caught) {
  try {
    throw caught;
  }
  catch (UserNotLoggedInException e) {
    // navigate to login dialog
  }
  catch (Throwable t) {
    GWT.log("An unexpected error has occurred", t);
  }
}</programlisting>
</section>
<section id="_logging_rpc_exceptions_on_the_server">
<title>Logging RPC exceptions on the server</title>
<simpara>Errai logs all exceptions thrown by RPC endpoints on the server at the DEBUG level. To show these messages in your server logs, set the logger "org.jboss.errai.bus.server.io.AbstractRPCMethodCallback" to the DEBUG level. Errai uses SLF4J, so how you go about setting this logger to debug will depend on what logging backend you use.</simpara>
</section>
</section>
<section id="sid-5931313_RemoteProcedureCalls%28RPC%29-ClientsideInterceptors">
<title>Client-side Interceptors</title>
<simpara>Client-side remote call interceptors provide the ability to manipulate or bypass the remote call before it&#8217;s being sent. This is useful for implementing crosscutting concerns like caching, for example when the remote call should be avoided if the data is already cached locally.</simpara>
<section id="_annotating_the_remote_interface">
<title>Annotating the Remote Interface</title>
<simpara>To have a remote call intercepted, either an interface method or the remote interface type has to be annotated with <literal><phrase role="code">@InterceptedCall</phrase></literal>. If the type is annotated, all interface methods will be intercepted.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Remote
public interface CustomerService {

  @InterceptedCall(MyCacheInterceptor.class)
  public Customer retrieveCustomerById(long id);
}</programlisting>
<simpara>Note that an ordered list of interceptors can be used for specifying an interceptor chain e.g.</simpara>
<programlisting language="java" linenumbering="unnumbered">@InterceptedCall({MyCacheInterceptor.class, MySecurityInterceptor.class})
public Customer retrieveCustomerById(long id);
</programlisting>
</section>
<section id="_implementing_an_interceptor">
<title>Implementing an Interceptor</title>
<simpara>Implementing an interceptor is easy:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class MyCacheInterceptor implements RpcInterceptor {

  @Override
  public void aroundInvoke(final RemoteCallContext context) {
    // e.g check if the result is cached and carry out the actual call only in case it's not.
    context.proceed() // executes the next interceptor in the chain or the actual remote call.
    // context.setResult() // sets the result directly without carrying out the remote call.
  }
}</programlisting>
<simpara>The <literal><phrase role="code">RemoteCallContext</phrase></literal> passed to the <literal><phrase role="code">aroundInvoke</phrase></literal> method provides access to the intercepted method&#8217;s name and read/write access to the parameter values provided at the call site.</simpara>
<simpara>Calling <literal><phrase role="code">proceed</phrase></literal> executes the next interceptor in the chain or the actual remote call if all interceptors have already been executed. If access to the result of the (asynchronous) remote call is needed in the interceptor, one of the overloaded versions of <literal><phrase role="code">proceed</phrase></literal> accepting a <literal><phrase role="code">RemoteCallback</phrase></literal> has to be used instead.</simpara>
<simpara>The result of the remote call can be manipulated by calling <literal><phrase role="code">RemoteCallContext.setResult()</phrase></literal>.</simpara>
<simpara>Not calling <literal><phrase role="code">proceed</phrase></literal> in the interceptor bypasses the actual remote call, passing <literal><phrase role="code">RestCallContext.getResult()</phrase></literal> to the <literal><phrase role="code">RemoteCallBack</phrase></literal> provided at the call site.</simpara>
</section>
<section id="_annotating_the_interceptor_alternative">
<title>Annotating the Interceptor (alternative)</title>
<simpara>If you cannot (or do not wish to) annotate the remote interface you may instead define remote call interceptors by annotating the interceptor class itself with <literal><phrase role="code">@InterceptsRemoteCall</phrase></literal>.  This annotation requires the developer to specify the remote interface that should be intercepted.  The interceptor will then be applied to all methods in that interface.  If the interface method is annotated with <literal><phrase role="code">InterceptedCall</phrase></literal>, that annotation will win out.</simpara>
<programlisting language="java" linenumbering="unnumbered">@InterceptsRemoteCall({ MyRemoteInterface.class, MyOtherRemoteInterface.class })
public class CustomRpcInterceptor implements RpcInterceptor {

  @Override
  public void aroundInvoke(final RemoteCallContext context) {
    // interceptor logic goes here
  }
}</programlisting>
<simpara>This approach sacrifices granularity (you cannot intercept individual methods on the remote interface).  However, it does allow method interception without modification to the remote interface (which is particularly useful when the developer is not in control of the remote interface).</simpara>
</section>
<section id="_interceptors_and_ioc">
<title>Interceptors and IOC</title>
<simpara>It is worth noting that interceptors <emphasis role="strong">may</emphasis> be defined as managed beans using the <literal><phrase role="code">@Dependent</phrase></literal>, <literal><phrase role="code">@Singleton</phrase></literal>, or <literal><phrase role="code">@ApplicationScoped</phrase></literal> annotations.  If the Errai application is using IOC (i.e. imports the IOC Errai module) <emphasis role="strong">and</emphasis> the interceptor is annotated as a managed bean, then the IOC container will be used to get/create the interceptor instance.  This allows developers to <literal><phrase role="code">@Inject</phrase></literal> dependencies into interceptors.  If IOC is not being used, or else the interceptor is not properly annotated, then the interceptor class will simply be instantiated via <emphasis role="strong">new</emphasis>.</simpara>
</section>
</section>
<section id="sid-5931313_RemoteProcedureCalls%28RPC%29-SessionandrequestobjectsinRPCendpoints">
<title>Session and request objects in RPC endpoints</title>
<simpara>Before invoking an endpoint method Errai sets up an <literal><phrase role="code">RpcContext</phrase></literal> that provides access to message resources that are otherwise not visible to RPC endpoints.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Service
public class MyRemoteServiceImpl implements MyRemoteService {

  public boolean isEveryoneHappy() {
    HttpSession session = RpcContext.getHttpSession();
    ServletRequest request = RpcContext.getServletRequest();
    ...
    return true;
  }
}</programlisting>
</section>
<section id="sid-5931313_RemoteProcedureCalls%28RPC%29-Batchingremotecalls">
<title>Batching remote calls</title>
<simpara>Some use cases require multiple interactions with the server to complete. Errai&#8217;s RPC mechanism allows for batched invocations of remote methods that will be executed using a single server round-trip. This is useful for reducing the number of simultaneous HTTP connections and at the same time allows for reusing and combining fine-grained remote services.</simpara>
<simpara>Injecting a BatchCaller instead of a Caller&lt;T&gt; is all it takes to make use of batched remote procedure calls.</simpara>
<programlisting language="java" linenumbering="unnumbered">@EntryPoint
public class MyBean {

 @Inject
 private BatchCaller batchCaller;

 private void someMethod() {
    // ...
    batchCaller.call(remoteCallback1, RemoteService1.class).method1();
    batchCaller.call(remoteCallback2, RemoteService2.class).method2();

    // Invokes the accumulated remote requests using a single server round-trip.
    batchCaller.sendBatch();
 }

}</programlisting>
<simpara>The remote methods will get executed only after <literal><phrase role="code">sendBatch()</phrase></literal> was called. The method <literal><phrase role="code">sendBatch</phrase></literal> accepts an additional <literal><phrase role="code">RemoteCallback</phrase></literal> instance as a parameter which will we invoked when all remote calls have completed in success. Consequently, an <literal><phrase role="code">ErrorCallback</phrase></literal> can also be provided which will get executed for all remote calls that have completed in failure.</simpara>
</section>
<section id="_asynchronous_handling_of_rpcs_on_the_server">
<title>Asynchronous handling of RPCs on the server</title>
<simpara>If computing the result of an RPC call takes a significant amount of time (i.e. because a third party service needs to be contacted or a long running query needs to be executed) it might be preferable to release the request-processing thread so it can perform other work and provide the result in a different execution context farther in the future. So, the RPC endpoint method can return immediately and the thread handling the incoming request doesn&#8217;t need to stay active until the result is available. Computing and setting the result can be done in a different thread (i.e. from a smaller thread pool provided by a library).</simpara>
<simpara>Errai provides a special return type <literal><phrase role="code">CallableFuture</phrase></literal> to indicate to the RPC system that the result of the remote method call will be provided asynchronously (after the remote method call has returned).</simpara>
<simpara>Here&#8217;s an example returning a result of type String:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Remote
public interface LongRunningService {
  public CallableFuture&lt;String&gt; someLongRunningTask();
}</programlisting>
<programlisting language="java" linenumbering="unnumbered">@Service
public class LongRunningServiceImpl implements LongRunningService {
  @Override
  public CallableFuture&lt;String&gt; someLongRunningTask() {
    final CallableFuture&lt;String&gt; future = CallableFutureFactory.get().createFuture(String.class);

    final ExecutorService executorService = Executors.newSingleThreadExecutor();
    executorService.submit(new Runnable() {
      @Override
      public void run() {
        try {
          Thread.sleep(5000);
          future.setValue("result");
        }
        catch (Throwable t) {
          t.printStackTrace();
        }
      }
    });
    executorService.shutdown();
    return future;
  }
}</programlisting>
<simpara>Note that the client-side code does not change when using this feature and will work exactly as described in <xref linkend="sid-5931313_RemoteProcedureCalls%28RPC%29-Makingcalls"/> i.e.:</simpara>
<programlisting language="java" linenumbering="unnumbered">MessageBuilder.createCall(new RemoteCallback&lt;String&gt;() {
  @Override
  public void callback(String response) {
    assertEquals("foobar", response);
    finishTest();
  }
}, LongRunningService.class).someLongRunningTask();</programlisting>
</section>
</chapter>
<chapter id="sid-19398997">
<title>Errai JAX-RS</title>
<simpara>JAX-RS (Java API for RESTful Web Services) is a Java EE standard (JSR-311) for implementing REST-based Web services in Java. Errai JAX-RS brings this standard to the browser and simplifies the integration of REST-based services in GWT client applications. Errai can generate proxies based on JAX-RS interfaces which will handle all the underlying communication and serialization logic. All that&#8217;s left to do is to invoke a Java method.</simpara>
<simpara>Errai&#8217;s JAX-RS support consists of the following:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>A client-side API to communicate with JAX-RS endpoints</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>A code generator that runs at your project&#8217;s build time, providing proxy implementations for each JAX-RS resource interfaces visible within the GWT module</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Errai IoC and CDI providers that allow you to <literal><phrase role="code">@Inject</phrase></literal> instances of <literal><phrase role="code">Caller&lt;T&gt;</phrase></literal> (the same API used in Errai RPC)</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Integration with either Errai Marshalling or Jackson to translate request and response data between Java object and a string-based wire format</simpara>
      
    </listitem>
  
</itemizedlist>

<note>
<title>Manual Setup</title>
<simpara>Checkout the <link linkend="Manual-Setup-Section">Manual Setup Section</link> for instructions on how to manually add JAX-RS to your project. You can also go to the <ulink url="https://github.com/errai/errai-tutorial/archive/main.zip">Errai tutorial project</ulink> or the <ulink url="https://github.com/errai/errai/tree/main/errai-demos">demo collection</ulink> for an example of JAX-RS.</simpara>
</note>
<section id="sid-19398997_ErraiJAX-RS-ServerSideJAXRSImplementation">
<title>Server-Side JAX-RS Implementation</title>
<simpara>Errai&#8217;s JAX-RS support consists mostly of features that make the client side easier and more reliable to maintain. You will need to use an existing third-party JAX-RS implementation on the server side. All Java EE 6 application servers include such a module out-of-the-box. If you are developing an application that you intend to deploy on a plain servlet container, you will have to choose a JAX-RS implementation (for example, RestEasy) and configure it properly in your web.xml.</simpara>
<simpara>Alternatively, you could keep your REST resource layer in a completely separate web application hosted on the same server (perhaps build an Errai JAX-RS client against an existing REST service you developed previously). In this case, you could factor out the shared JAX-RS interface into a shared library, leaving the implementation in the non-Errai application.</simpara>
<simpara>Finally, you can take advantage of the cross-origin resource sharing (CoRS) feature in modern browsers and use Errai JAX-RS to send requests to a third-party server. The third-party server would have to be configured to allow cross-domain requests. In this case, you would write a JAX-RS-Annotated interface describing the remote REST resources, but you would not create an implementation of that interface.</simpara>
</section>
<section id="sid-19398997_ErraiJAX-RS-SharedJAXRSInterface">
<title>Shared JAX-RS Interface</title>
<simpara>Errai JAX-RS works by leveraging standard Java interfaces that bear JAX-RS annotations. You will also want these interfaces visible to server-side code so that your JAX-RS resource classes can implement them (and inherit the annotations). This keeps the whole setup typesafe, and reduces duplication to the bare minimum. The natural solution, then is to put the JAX-RS interfaces under the client.shared package within your GWT module:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>project</simpara>
      

<itemizedlist>
  
    <listitem>
      <simpara>src/main/java</simpara>
      

<itemizedlist>
  
    <listitem>
      <simpara>com.mycompany.myapp</simpara>
      

<itemizedlist>
  
    <listitem>
      <simpara>MyApp.gwt.xml <emphasis>[the app&#8217;s GWT module]</emphasis></simpara>
      
    </listitem>
  
</itemizedlist>


      
    </listitem>
  
    <listitem>
      <simpara>com.mycompany.myapp.client.local</simpara>
      

<itemizedlist>
  
    <listitem>
      <simpara>MyAppClientStuff.java <emphasis>[code that @Injects Caller&lt;MyAppRestResource&gt;]</emphasis></simpara>
      
    </listitem>
  
</itemizedlist>


      
    </listitem>
  
    <listitem>
      <simpara>com.mycompany.myapp.client.shared</simpara>
      

<itemizedlist>
  
    <listitem>
      <simpara>CustomerService.java <emphasis>[the JAX-RS interface]</emphasis></simpara>
      
    </listitem>
  
</itemizedlist>


      
    </listitem>
  
    <listitem>
      <simpara>com.mycompany.myapp.server</simpara>
      

<itemizedlist>
  
    <listitem>
      <simpara>CustomerServiceImpl.java <emphasis>[the server-side JAX-RS resource implementation]</emphasis></simpara>
      
    </listitem>
  
</itemizedlist>


      
    </listitem>
  
</itemizedlist>


      
    </listitem>
  
</itemizedlist>


      
    </listitem>
  
</itemizedlist>

<simpara>The contents of the server-side files would be as follows:</simpara>
<example>
<title>CustomerService.java</title>
<programlisting language="java" linenumbering="unnumbered">@Path("customers")
public interface CustomerService {
  @GET
  @Produces("application/json")
  public List&lt;Customer&gt; listAllCustomers();

  @POST
  @Consumes("application/json")
  @Produces("text/plain")
  public long createCustomer(Customer customer);
}</programlisting>
</example>
<simpara>The above interface is visible both to server-side code and to client-side code. It is used by client-side code to describe the available operations, their parameter types, and their return types. If you use your IDE&#8217;s refactoring tools to modify this interface, both the server-side and client-side code will be updated automatically.</simpara>
<example>
<title>CustomerServiceImpl.java</title>
<programlisting language="java" linenumbering="unnumbered">public class CustomerServiceImpl implements CustomerService {

  @Override
  public List&lt;Customer&gt; listAllCustomers() {
    // Use a database API to look up all customers in back-end data store
    // Return the resulting list
  }

  @Override
  public long createCustomer(Customer customer) {
    // Store new Customer instance in back-end data store
  }
}</programlisting>
</example>
<simpara>The above class implements the shared interface. Since it performs database and/or filesystem operations to manipulate the persistent data store, it is not GWT translatable, and it&#8217;s therefore kept in a package that is not part of the GWT module.</simpara>
<important>
<title>Save typing and reduce duplication</title>
<simpara>Note that all JAX-RS annotations (<literal><phrase role="code">@Path</phrase></literal>, <literal><phrase role="code">@GET</phrase></literal>, <literal><phrase role="code">@Consumes</phrase></literal>, and so on) can be inherited from the interface. You do not need to repeat these annotations in your resource implementation classes.</simpara>
</important>
</section>
<section id="sid-19398997_ErraiJAX-RS-CreatingRequests">
<title>Creating Requests</title>
<simpara>This section assumes you have already set up the CustomerService JAX-RS endpoint as described in the previous section.</simpara>
<simpara>To create a request on the client, all that needs to be done is to invoke <literal><phrase role="code">RestClient.create()</phrase></literal>, thereby providing the JAX-RS interface, a response callback and to invoke the corresponding interface method:</simpara>
<example>
<title>App.java</title>
<programlisting language="java" linenumbering="unnumbered">...
Button create = new Button("Create", new ClickHandler() {
  public void onClick(ClickEvent clickEvent) {
    Customer customer = new Customer(firstName, lastName, postalCode);
    RestClient.create(CustomerService.class, callback).createCustomer(customer);
  }
});
...</programlisting>
</example>
<simpara>For details on the callback mechanism see <link linkend="sid-19398997_ErraiJAX-RS-HandlingResponses">Handling Responses</link>.</simpara>
<section id="sid-19398997_ErraiJAX-RS-ProxyInjection">
<title>Proxy Injection</title>
<simpara>Injectable proxies can be used as an alternative to calling <literal><phrase role="code">RestClient.create()</phrase></literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Inject
private Caller&lt;CustomerService&gt; customerService;</programlisting>
<simpara>To create a request, the callback objects need to be provided to the <literal><phrase role="code">call</phrase></literal> method before the corresponding interface method is invoked.</simpara>
<programlisting language="java" linenumbering="unnumbered">customerService.call(callback).listAllCustomers();</programlisting>
<simpara>To use caller injection, your application needs to inherit the Errai IOC GWT module. To do this, just add this line to your application&#8217;s <literal><phrase role="code">*.gwt.xml</phrase></literal> file and make sure it comes <literal><phrase role="code">after</phrase></literal> the Errai JAX-RS module (see <link linkend="sid-19398997_ErraiJAX-RS-GettingStarted">Getting Started</link>):</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;inherits name="org.jboss.errai.ioc.Container"/&gt;</programlisting>
<note>
<simpara>The JAX-RS interfaces need to be visible to the GWT compiler and must therefore reside within the client packages (e.g. client.shared).</simpara>
</note>
</section>
</section>
<section id="sid-19398997_ErraiJAX-RS-HandlingResponses">
<title>Handling Responses</title>
<simpara>An instance of Errai&#8217;s <literal><phrase role="code">RemoteCallback&lt;T&gt;</phrase></literal> has to be passed to the <literal><phrase role="code">RestClient.create()</phrase></literal> call, which will provide access to the JAX-RS resource method&#8217;s result. <literal><phrase role="code">T</phrase></literal> is the return type of the JAX-RS resource method. In the example below it&#8217;s just a <literal><phrase role="code">Long</phrase></literal> representing a customer ID, but it can be any serializable type (see <link linkend="sid-5931328">Marshalling</link>).</simpara>
<programlisting language="java" linenumbering="unnumbered">RemoteCallback&lt;Long&gt; callback = new RemoteCallback&lt;Long&gt;() {
  public void callback(Long id) {
    Window.alert("Customer created with ID: " + id);
  }
};</programlisting>
<simpara>One special use case for the <literal><phrase role="code">RemoteCallback</phrase></literal> is for JAX-RS interface methods that return a <literal><phrase role="code">javax.ws.rs.core.Response</phrase></literal> type. Errai does not provide a client implementation of the <literal><phrase role="code">javax.ws.rs.core.Response</phrase></literal> class. Instead calls to methods returning a <literal><phrase role="code">javax.ws.rs.core.Response</phrase></literal> should use a <literal><phrase role="code">RemoteCallback&lt;com.google.gwt.http.client.Response&gt;</phrase></literal>. The <literal><phrase role="code">MarshallingWrapper</phrase></literal> class can be used to manually deserialize an entity from the body of a response.</simpara>
<programlisting language="java" linenumbering="unnumbered">RemoteCallback&lt;Response&gt; callback = new RemoteCallback&lt;Response&gt;() {
  public void callback(Response response) {
    Window.alert("HTTP status code: " + response.getStatusCode());
    Window.alert("HTTP response body: " + response.getText());
    Window.alert("Demarshalled entity: " + MasrhallingWrapper.fromJSON(response.getText()));
  }
};</programlisting>
<section id="sid-19398997_ErraiJAX-RS-HandlingErrors">
<title>Handling Errors</title>
<simpara>For handling errors, Errai&#8217;s error callback mechanism can be reused and an instance of <literal><phrase role="code">ErrorCallback</phrase></literal> can optionally be passed to the <literal><phrase role="code">RestClient.create()</phrase></literal> call. In case of an HTTP error, the <literal><phrase role="code">ResponseException</phrase></literal> provides access to the <literal><phrase role="code">Response</phrase></literal> object. All other <literal><phrase role="code">Throwables</phrase></literal> indicate a communication problem.</simpara>
<programlisting language="java" linenumbering="unnumbered">ErrorCallback errorCallback = new RestErrorCallback() {
  public boolean error(Request request, Throwable throwable) {
    try {
      throw throwable;
    }
    catch (ResponseException e) {
      Response response = e.getResponse();
      // process unexpected response
      response.getStatusCode();
    }
    catch (Throwable t) {
      // process unexpected error (e.g. a network problem)
    }
    return false;
  }
};</programlisting>
<simpara>To provide more customized error handling, Errai also defines client side exception handling via the <literal><phrase role="code">ClientExceptionMapper</phrase></literal> interface.  The client exception mapper allows developers to process a REST <literal><phrase role="code">Response</phrase></literal> into a <literal><phrase role="code">Throwable</phrase></literal> prior to the error being delivered to the <literal><phrase role="code">ErrorCallback</phrase></literal> described above.  The exception mapper class must be annotated with <literal><phrase role="code">javax.ws.rs.ext.Provider</phrase></literal> as well as implement the <literal><phrase role="code">ClientExceptionMapper</phrase></literal> interface.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Provider
public class MyAppExceptionMapper implements ClientExceptionMapper {

  /**
   * @see org.jboss.errai.enterprise.client.jaxrs.ClientExceptionMapper#fromResponse(com.google.gwt.http.client.Response)
   */
  @Override
  public Throwable fromResponse(Response response) {
    if (response.getStatusCode() == 404)
      return new MyAppNotFoundException();
    else
      return new MyAppServerError(response.getStatusText());
  }

}
</programlisting>
<important>
<title>Must be used in conjunction with <literal><phrase role="code">RestErrorCallback</phrase></literal></title>
<simpara>It is important to note that the <literal><phrase role="code">ClientExceptionMapper</phrase></literal> will only be invoked when the callback passed to the <literal><phrase role="code">Caller</phrase></literal> is an instance of <literal><phrase role="code">RestErrorCallback</phrase></literal>.</simpara>
</important>
<simpara>The <literal><phrase role="code">ClientExceptionMapper</phrase></literal> will, by default, be invoked for every error response.  However, Errai also provides the <literal><phrase role="code">org.jboss.errai.enterprise.shared.api.annotations.MapsFrom</phrase></literal> annotation which provides for additional granularity.  An exception mapper can be annotated so that it is only invoked for methods on specific REST interfaces.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Provider
@MapsFrom({ SomeRestInterface.class })
public class SpecificClientExceptionMapper implements ClientExceptionMapper {

  /**
   * @see org.jboss.errai.enterprise.client.jaxrs.ClientExceptionMapper#fromResponse(com.google.gwt.http.client.Response)
   */
  @Override
  public Throwable fromResponse(Response response) {
     ... // Do something specific here
  }

}</programlisting>
</section>
</section>
<section id="sid-19398997_ErraiJAX-RS-AbortingRequests">
<title>Accesssing and aborting requests</title>
<simpara>An instance of Errai&#8217;s <literal><phrase role="code">RequestCallback</phrase></literal> can optionally be passed to the <literal><phrase role="code">RestClient.create()</phrase></literal> call, which will
provide access to the underlying HTTP request. The callback is invoked synchronously after the HTTP request has been initiated.
This means that you will have access to the request immediately after the call.</simpara>
<programlisting language="java" linenumbering="unnumbered">RequestCallback requestCallback = new RequestCallback() {
  @Override
  public void callback(Request request) {
    this.request = request;
  }
};

RestClient.create(SearchService.class, callback, requestCallback).find(query);</programlisting>
<simpara>This allows you to cancel a pending request. Alternatively, a <literal><phrase role="code">RequestHolder</phrase></literal> can be used instead.</simpara>
<programlisting language="java" linenumbering="unnumbered">RequestHolder searchRequestHolder = new RequestHolder();
RestClient.create(SearchService.class, callback, searchRequestHolder).find(query);
...
if (searchRequestHolder.isAlive()) {
  searchRequestHolder.getRequest().cancel();
}</programlisting>
</section>
<section id="sid-19398997_ErraiJAX-RS-ClientsideInterceptors">
<title>Client-side Interceptors</title>
<simpara>Client-side remote call interceptors provide the ability to manipulate or bypass the request before it&#8217;s being sent. This is useful for implementing crosscutting concerns like caching or security features e.g:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>avoiding the request when the data is cached locally</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>adding special HTTP headers or parameters to the request</simpara>
      
    </listitem>
  
</itemizedlist>

<section id="_annotating_the_jax_rs_interface">
<title>Annotating the JAX-RS Interface</title>
<simpara>To have a JAX-RS remote call intercepted, either an interface method or the JAX-RS implementation class method has to be annotated with <literal><phrase role="code">@InterceptedCall</phrase></literal>. If the type is annotated, all interface methods will be intercepted.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Path("customers")
public interface CustomerService {

  @GET
  @Path("/{id}")
  @Produces("application/json")
  @InterceptedCall(MyCacheInterceptor.class)
  public Customer retrieveCustomerById(@PathParam("id") long id);
}</programlisting>
<simpara>Note that an ordered list of interceptors can be used for specifying an interceptor chain e.g.</simpara>
<programlisting language="java" linenumbering="unnumbered">@InterceptedCall({MyCacheInterceptor.class, MySecurityInterceptor.class})
public Customer retrieveCustomerById(@PathParam("id") long id);</programlisting>
</section>
<section id="_implementing_an_interceptor_2">
<title>Implementing an Interceptor</title>
<simpara>Implementing an interceptor is easy:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class MyCacheInterceptor implements RestClientInterceptor {

  @Override
  public void aroundInvoke(final RestCallContext context) {
    RequestBuilder builder = context.getRequestBuilder();
    builder.setHeader("headerName", "value");
    context.proceed();
  }
}</programlisting>
<simpara>The <literal><phrase role="code">RestCallContext</phrase></literal> passed to the <literal><phrase role="code">aroundInvoke</phrase></literal> method provides access to the context of the intercepted JAX-RS (REST) remote call. It allows to read and write the parameter values provided at the call site and provides read/write access to the <literal><phrase role="code">RequestBuilder</phrase></literal> instance which has the URL, HTTP headers and parameters set.</simpara>
<simpara>Calling <literal><phrase role="code">proceed</phrase></literal> executes the next interceptor in the chain or the actual remote call if all interceptors have already been executed. If access to the result of the (asynchronous) remote call is needed in the interceptor, one of the overloaded versions of <literal><phrase role="code">proceed</phrase></literal> accepting a <literal><phrase role="code">RemoteCallback</phrase></literal> has to be used instead.</simpara>
<simpara>The result of the remote call can be manipulated by calling <literal><phrase role="code">RestCallContext.setResult()</phrase></literal>.</simpara>
<simpara>Not calling <literal><phrase role="code">proceed</phrase></literal> in the interceptor bypasses the actual remote call, passing <literal><phrase role="code">RestCallContext.getResult()</phrase></literal> to the <literal><phrase role="code">RemoteCallBack</phrase></literal> provided at the call site.</simpara>
</section>
<section id="_annotating_the_interceptor_alternative_2">
<title>Annotating the Interceptor (alternative)</title>
<simpara>If you cannot (or do not wish to) annotate the JAX-RS interface you may instead define remote call interceptors by annotating the interceptor class itself with <literal><phrase role="code">@InterceptsRemoteCall</phrase></literal>. This annotation requires the developer to specify the JAX-RS interface that should be intercepted. The interceptor will then be applied to all methods in that interface.  If the interface method is annotated with <literal><phrase role="code">InterceptedCall</phrase></literal>, that annotation will win out.</simpara>
<programlisting language="java" linenumbering="unnumbered">@InterceptsRemoteCall({ MyJaxrsInterface.class, MyOtherJaxrsInterface.class })
public class MyCacheInterceptor implements RestClientInterceptor {

  @Override
  public void aroundInvoke(final RestCallContext context) {
    // Do interceptor logic here
    context.proceed();
  }
}</programlisting>
<simpara>This approach sacrifices granularity (you cannot intercept individual methods on the JAX-RS interface). However, it does allow method interception without modification to the JAX-RS interface (which is particularly useful when the developer is not in control of the JAX-RS interface).</simpara>
</section>
<section id="_interceptors_and_ioc_2">
<title>Interceptors and IOC</title>
<simpara>It is worth noting that interceptors <emphasis role="strong">may</emphasis> be defined as managed beans using the <literal><phrase role="code">@Dependent</phrase></literal>, <literal><phrase role="code">@Singleton</phrase></literal>, or <literal><phrase role="code">@ApplicationScoped</phrase></literal> annotations. If the Errai application is using IOC (i.e. imports the IOC Errai module) <emphasis role="strong">and</emphasis> the interceptor is annotated as a managed bean, then the IOC container will be used to get/create the interceptor instance. This allows developers to <literal><phrase role="code">@Inject</phrase></literal> dependencies into interceptors.  If IOC is not being used, or else the interceptor is not properly annotated, then the interceptor class will simply be instantiated via <emphasis role="strong">new</emphasis>.</simpara>
</section>
</section>
<section id="sid-19398997_ErraiJAX-RS-WireFormat">
<title>Wire Format</title>
<simpara>Errai&#8217;s JSON format will be used to serialize/deserialize your custom types. See <link linkend="sid-5931328">Marshalling</link> for details.</simpara>
<simpara>Alternatively, a Jackson compatible JSON format can be used on the wire. See <link linkend="sid-19398997_ErraiJAX-RS-Configuration">Configuration</link> for details on how to enable Jackson marshalling.</simpara>
</section>
<section id="_path">
<title>Path</title>
<simpara>All paths specified using the <literal><phrase role="code">@Path</phrase></literal> annotation on JAX-RS interfaces are by definition relative paths. Therefore, by default, it is assumed that the JAX-RS endpoints can be found at the specified paths relative to the GWT client application&#8217;s context path.</simpara>
<important>
<title>Configuring the Path</title>
<simpara>To learn more about configuring the path, checkout <link linkend="sid-19398997_ErraiJAX-RS-Configuration">the JAX-RS Configuration Section</link>.</simpara>
</important>
</section>
<section id="_csrf_protection">
<title>CSRF Protection</title>
<simpara>Errai provides a filter for protecting REST endpoints from Cross Site Request Forgery (CSRF) attacks. The filter <literal>org.jboss.errai.bus.server.servlet.CSRFTokenFilter</literal> generates a CSRF token for every HTTP session that is required as an HTTP header for all POST, PUT, and DELETE requests. Requests made with an Errai <literal>Caller&lt;T&gt;</literal> will automatically negotiate for a CSRF token, or the same filter can be added to the host page, where it will inject the token onto the page as a JavaScript variable.</simpara>
</section>
</chapter>
<chapter id="sid-54493688">
<title>Errai JPA</title>
<warning>
<title>Deprecated</title>
<simpara>Errai JPA is deprecated. These features are no longer being updated and will be removed in a future release.</simpara>
</warning>
<simpara>Starting with Errai 2.1, Errai implements a subset of JPA 2.0. With Errai JPA, you can store and retrieve entity objects on the client side, in the browser&#8217;s local storage. This allows the reuse of JPA-related code (both entity class definitions and procedural logic that uses the EntityManager) between client and server.</simpara>
<simpara>Errai JPA implements the following subset of JPA 2.0:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>Annotation-based configuration</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Entity Types with</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Identifiers of any numeric type (int, long, short, etc.)</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Generated identifiers</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Regular attributes of any JPA Basic type (Java primitive types, boxed primitives, enums, BigInteger, BigDecimal, String, Date, Time, and Timestamp)</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Singular and Plural (collection-valued) attributes of other entity types</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>All association types (one-to-one, one-to-many, many-to-one, many-to-many)</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>All association cascade rules (ALL, PERSIST, MERGE, REMOVE, REFRESH, DETACH)</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Circular and self references work properly</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Polymorphic queries and collections (queries for a base entity type can result in instances of its subtypes)</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Property access by field or get/set methods</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Named, typed JPQL queries that select exactly one entity type</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>With cascading fetch of related entities</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>With or without <literal><phrase role="code">WHERE</phrase></literal> clause</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>All boolean, arithmetic, and string operators supported</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>All String manipulation functions supported</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>With or without <literal><phrase role="code">ORDER BY</phrase></literal> clause</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Lifecycle events and entity lifecycle listeners</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Much of the Metamodel API (<literal><phrase role="code">Metamodel</phrase></literal>, <literal><phrase role="code">EntityType</phrase></literal>, <literal><phrase role="code">SingularAttribute</phrase></literal>, <literal><phrase role="code">PluralAttribute</phrase></literal>, etc.)</simpara>
      
    </listitem>
  
</itemizedlist>

<important>
<title>It&#8217;s all client-side</title>
<simpara>Errai JPA is a declarative, typesafe interface to the web browser&#8217;s <literal><phrase role="code">localStorage</phrase></literal> object. As such it is a <emphasis>client-side implementation</emphasis> of JPA. Objects are stored and fetched from the browser&#8217;s local storage, <emphasis>not</emphasis> from the JPA provider on the server side.</simpara>
</important>
<section id="sid-54493688_ErraiJPA-GettingStarted">
<title>Getting Started</title>
<note>
<title>Manual Setup</title>
<simpara>Checkout the <link linkend="Manual-Setup-Section">Manual Setup Section</link> for instructions on how to manually add Errai JPA to your project.</simpara>
</note>
<section id="_meta_inf_persistence_xml">
<title>META-INF/persistence.xml</title>
<simpara>Errai ignores META-INF/persistence.xml for purposes of client-side JPA. Instead, Errai scans all Java packages that are part of your GWT modules for classes annotated with <literal><phrase role="code">@Entity</phrase></literal>. This allows you the freedom of defining a persistence.xml that includes both shared entity classes that you use on the client and the server, plus server-only entities that are defined in a server-only package.</simpara>
</section>
<section id="sid-54493688_ErraiJPA-DeclaringanEntityClass">
<title>Declaring an Entity Class</title>
<simpara>Classes whose instances can be stored and retrieved by JPA are called <emphasis>entities</emphasis>. To declare a class as a JPA entity, annotate it with <literal><phrase role="code">@Entity</phrase></literal>.</simpara>
<simpara>JPA requires that entity classes conform to a set of rules. These are:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>The class must have an ID attribute</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The class must have a public or protected constructor that takes no arguments</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The class must be public and nonfinal</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>No methods or persistent fields of the class may be final</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The class must be a top-level type (not a nested or inner class)</simpara>
      
    </listitem>
  
</itemizedlist>

<simpara>Here is an example of a valid entity class with an ID attribute (<literal><phrase role="code">id</phrase></literal>) and a String-valued persistent attribute (<literal><phrase role="code">name</phrase></literal>):</simpara>
<programlisting language="java" linenumbering="unnumbered">@Entity
public class Genre {

  @Id @GeneratedValue
  private int id;

  private String name;

  // This constructor is used by JPA
  public Genre() {}

  // This constructor is not used by JPA
  public Genre(String name) {
    this();
    this.name = name;
  }


  // These getter and Setter methods are optional:

  public int getId() { return id; }
  public void setId(int id) { this.id = id; }

  public String getName() { return name; }
  public void setName(String name) { this.name = name; }
}</programlisting>
<section id="sid-54493688_ErraiJPA-EntityAttributes">
<title>Entity Attributes</title>
<simpara>The state of fields and JavaBeans properties of entities are generally persisted with the entity instance. These persistent things are called <emphasis>attributes</emphasis>.</simpara>
<simpara>JPA Attributes are subdivided into two main types: <emphasis>singular</emphasis> and <emphasis>plural</emphasis>. Singular attributes are scalar types like <literal><phrase role="code">Integer</phrase></literal> or <literal><phrase role="code">String</phrase></literal>. Plural attributes are collection values, such as <literal><phrase role="code">List&lt;Integer&gt;</phrase></literal> or <literal><phrase role="code">Set&lt;String&gt;</phrase></literal>.</simpara>
<simpara>The values of singular attributes (and the elements of plural attributes) can be of any application-defined entity type or a JPA Basic type. The JPA basic types are all of the Java primitive types, all boxed primitives, enums, BigInteger, BigDecimal, String, Date (<literal><phrase role="code">java.util.Date</phrase></literal> or <literal><phrase role="code">java.sql.Date</phrase></literal>), Time, and Timestamp.</simpara>
<simpara>You can direct JPA to read and write your entity&#8217;s attributes by direct field access or via JavaBeans property access methods (that is, "getters and setters"). Direct field access is the default. To request property access, annotate the class with <literal><phrase role="code">@Access(AccessType.PROPERTY)</phrase></literal>. If using direct field access, attribute-specific JPA annotations should be on the fields themselves; when using property access, the attribute-specific annotations should be on the getter method for that property.</simpara>
</section>
<section id="sid-54493688_ErraiJPA-IDAttributesandAutoGeneratedIdentifiers">
<title>ID Attributes and Auto-Generated Identifiers</title>
<simpara>Each entity class must have exactly one ID attribute. The value of this attribute together with the fully-qualified class name uniquely identifies an instance to the entity manager.</simpara>
<simpara>ID values can be assigned by the application, or they can be generated by the JPA entity manager. To declare a generated identifier, annotate the field with <literal><phrase role="code">@GeneratedValue</phrase></literal>. To declare an application-assigned identifier, leave off the <literal><phrase role="code">@GeneratedValue</phrase></literal> annotation.</simpara>
<simpara>Generated identifier fields must not be initialized or modified by application code. Application-assigned identifier fields must be initialized to a unique value before the entity is persisted by the entity manager, but must not be modified afterward.</simpara>
</section>
<section id="sid-54493688_ErraiJPA-SinglevaluedAttributes">
<title>Single-valued Attributes</title>
<simpara>By default, every field of a JPA basic type is a persistent attribute. If a basic type field should not be presistent, mark it with <literal><phrase role="code">transient</phrase></literal> or annotate it with <literal><phrase role="code">@Transient</phrase></literal>.</simpara>
<simpara>Single-valued attributes of entity types must be annotated with <literal><phrase role="code">@OneToOne</phrase></literal> or <literal><phrase role="code">@ManyToOne</phrase></literal>.</simpara>
<simpara>Single-valued types that are neither entity types nor JPA Basic types are not presently supported by Errai JPA. Such attributes must be marked transient.</simpara>
<simpara>Here is an example of an entity with single-valued basic attributes and a single-valued relation to another entity type:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Entity
public class Album {

  @GeneratedValue
  @Id
  private Long id;

  private String name;

  @ManyToOne
  private Artist artist;

  private Date releaseDate;

  private Format format;

  public Long getId() { return id; }
  public void setId(Long id) { this.id = id; }

  public String getName() { return name; }
  public void setName(String name) { this.name = name; }

  public Artist getArtist() { return artist; }
  public void setArtist(Artist artist) { this.artist = artist; }

  public Date getReleaseDate() { return releaseDate; }
  public void setReleaseDate(Date releaseDate) { this.releaseDate = releaseDate; }

  public Format getFormat() { return format; }
  public void setFormat(Format format) { this.format = format; }
}</programlisting>
</section>
<section id="sid-54493688_ErraiJPA-Plural%28collectionvalued%29Attributes">
<title>Plural (collection-valued) Attributes</title>
<simpara>Collection-valued types <literal><phrase role="code">Collection&lt;T&gt;</phrase></literal>, <literal><phrase role="code">Set&lt;T&gt;</phrase></literal>, and <literal><phrase role="code">List&lt;T&gt;</phrase></literal> are supported. JPA rules require that all access to the collections are done through the collection interface method; never by specific methods on an implementation.</simpara>
<simpara>The element type of a collection attribute can be a JPA basic type or an entity type. If it is an entity type, the attribute must be annotated with <literal><phrase role="code">@OneToMany</phrase></literal> or <literal><phrase role="code">@ManyToMany</phrase></literal>.</simpara>
<simpara>Here is an example of an entity with two plural attributes:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Entity
public class Artist {

  @Id
  private Long id;

  private String name;

  // a two-way relationship (albums refer back to artists)
  @OneToMany(mappedBy="artist", cascade=CascadeType.ALL)
  private Set&lt;Album&gt; albums = new HashSet&lt;Album&gt;();

  // a one-way relationship (genres don't reference artists)
  @OneToMany(cascade={CascadeType.PERSIST, CascadeType.MERGE})
  private Set&lt;Genre&gt; genres = new HashSet&lt;Genre&gt;();

  public Long getId() { return id; }
  public void setId(Long id) { this.id = id; }

  public String getName() { return name; }
  public void setName(String name) { this.name = name; }

  public Set&lt;Album&gt; getAlbums() { return albums; }
  public void setAlbums(Set&lt;Album&gt; albums) { this.albums = albums; }

  public Set&lt;Genre&gt; getGenres() { return genres; }
  public void setGenres(Set&lt;Genre&gt; genres) { this.genres = genres; }
}</programlisting>
</section>
</section>
<section id="sid-54493688_ErraiJPA-EntityLifecycleStates">
<title>Entity Lifecycle States</title>
<section id="sid-54493688_ErraiJPA-CascadeRules">
<title>Cascade Rules</title>
<simpara>When an entity changes state (more on this later), that state change can be cascaded automatically to related entity instances. By default, no state changes are cascaded to related entities. To request cascading of entity state changes, use the <literal><phrase role="code">cascade</phrase></literal> attribute on any of the relationship quantifiers <literal><phrase role="code">@OneToOne</phrase></literal>, <literal><phrase role="code">@ManyToOne</phrase></literal>, <literal><phrase role="code">@OneToMany</phrase></literal>, and <literal><phrase role="code">@ManyToMany</phrase></literal>.</simpara>
<informaltable frame="all"
    rowsep="1" colsep="1">
  
  <tgroup cols="2">
    
    <colspec colname="col_1" colwidth="50*"/>
    
    <colspec colname="col_2" colwidth="50*"/>
    
    
    <thead>
      
      <row>
        
        <entry align="left" valign="top">CascadeType value</entry>
        
        <entry align="left" valign="top">Description</entry>
        
      </row>
      
    </thead>
    
    <tbody>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">PERSIST</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>Persist the related entity object(s) when this entity is persisted</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">MERGE</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>Merge the attributes of the related entity object(s) when this entity is merged</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">REMOVE</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>Remove the related entity object(s) from persistent storage when this one is removed</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">REFRESH</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>Not applicable in Errai JPA</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">DETACH</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>Detach the related entity object(s) from the entity manager when this object is detached</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">ALL</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>Equivalent to specifying all of the above</simpara></entry>
        
      </row>
      
    </tbody>
    
  </tgroup>
</informaltable>
<simpara>For an example of specifying cascade rules, refer to the <literal><phrase role="code">Artist</phrase></literal> example above. In that example, the cascade type on <literal><phrase role="code">albums</phrase></literal> is <literal><phrase role="code">ALL</phrase></literal>. When a particular <literal><phrase role="code">Artist</phrase></literal> is persisted or removed, detached, etc., all of that artist&#8217;s albums will also be persisted or removed, or detached correspondingly. However, the cascade rules for <literal><phrase role="code">genres</phrase></literal> are different: we only specify <literal><phrase role="code">PERSIST</phrase></literal> and <literal><phrase role="code">MERGE</phrase></literal>. Because a <literal><phrase role="code">Genre</phrase></literal> instance is reusable and potentially shared between many artists, we do not want to remove or detach these when one artist that references them is removed or detached. However, we still want the convenience of automatic cascading persistence in case we persist an <literal><phrase role="code">Artist</phrase></literal> which references a new, unmanaged <literal><phrase role="code">Genre</phrase></literal>.</simpara>
</section>
</section>
<section id="sid-54493688_ErraiJPA-ObtaininganinstanceofEntityManager">
<title>Obtaining an instance of EntityManager</title>
<simpara>The entity manager provides the means for storing, retrieving, removing, and otherwise affecting the lifecycle state of entity instances.</simpara>
<simpara>To obtain an instance of EntityManager on the client side, use Errai IoC (or CDI) to inject it into any client-side bean:</simpara>
<programlisting language="java" linenumbering="unnumbered">@EntryPoint
public class Main {
  @Inject EntityManager em;
}</programlisting>
<section id="sid-54493688_ErraiJPA-StoringandUpdatingEntities">
<title>Storing and Updating Entities</title>
<simpara>To store an entity object in persistent storage, pass that object to the <literal><phrase role="code">EntityManager.persist()</phrase></literal> method. Once this is done, the entity instance transitions from the <emphasis>new</emphasis> state to the <emphasis>managed</emphasis> state.</simpara>
<simpara>If the entity references any related entities, these entities must be in the managed state already, or have cascade-on-persist enabled. If neither of these criteria are met, an <literal><phrase role="code">IllegalStateException</phrase></literal> will be thrown.</simpara>
<simpara>See an example in the following section.</simpara>
</section>
<section id="sid-54493688_ErraiJPA-FetchingEntitiesbyID">
<title>Fetching Entities by ID</title>
<simpara>If you know the unique ID of an entity object, you can use the <literal><phrase role="code">EntityManager.find()</phrase></literal> method to retrieve it from persistent storage. The object returned from the <literal><phrase role="code">find()</phrase></literal> method will be in the managed state.</simpara>
<simpara>Example:</simpara>
<programlisting language="java" linenumbering="unnumbered">    // make it
    Album album = new Album();
    album.setArtist(null);
    album.setName("Abbey Road");
    album.setReleaseDate(new Date(-8366400000L));

    // store it
    EntityManager em = getEntityManager();
    em.persist(album);
    em.flush();
    em.detach(album);
    assertNotNull(album.getId());

    // fetch it
    Album fetchedAlbum = em.find(Album.class, album.getId());
    assertNotSame(album, fetchedAlbum);
    assertEquals(album.toString(), fetchedAlbum.toString());</programlisting>
</section>
<section id="sid-54493688_ErraiJPA-RemovingEntitiesfromPersistentStorage">
<title>Removing Entities from Persistent Storage</title>
<simpara>To remove a persistent managed entity, pass it to the <literal><phrase role="code">EntityManager.remove()</phrase></literal> method. As the cascade rules specify, related entities will also be removed recursively.</simpara>
<simpara>Once an entity has been removed and the entity manager&#8217;s state has been flushed, the entity object is unmanaged and back in the <emphasis>new</emphasis> state.</simpara>
<section id="sid-54493688_ErraiJPA-ClearingallLocalStorage">
<title>Clearing all Local Storage</title>
<simpara>Errai&#8217;s EntityManager class provides a <literal><phrase role="code">removeAll()</phrase></literal> method which removes everything from the browser&#8217;s persistent store for the domain of the current webpage.</simpara>
<simpara>This method is not part of the JPA standard, so you must down-cast your client-side <literal><phrase role="code">EntityManager</phrase></literal> instance to <literal><phrase role="code">ErraiEntityManager</phrase></literal>. Example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@EntryPoint
public class Main {

  @Inject EntityManager em;

  void resetJpaStorage() {
    ((ErraiEntityManager) em).removeAll();
  }
}</programlisting>
</section>
</section>
<section id="sid-54493688_ErraiJPA-DetachingEntityInstancesfromtheEntityManager">
<title>Detaching Entity Instances from the Entity Manager</title>
<simpara>For every entity instance in the managed state, changes to the attribute values of that entity are persisted to local storage whenever the entity manager is flushed. To prevent this automatic updating from happening, you can <emphasis>detach</emphasis> an entity from the entity manager. When an instance is detached, it is not deleted. All information about it remains in persistent storage. The next time that entity is retrieved, the entity manager will create a new and separate managed instance for it.</simpara>
<simpara>To detach one particular object along with all related objects whose cascade rules say so, call <literal><phrase role="code">EntityManager.detach()</phrase></literal> and pass in that object.</simpara>
<simpara>To detach all objects from the entity manager at once, call <literal><phrase role="code">EntityManager.detachAll()</phrase></literal>.</simpara>
</section>
<section id="sid-54493688_ErraiJPA-TestingifanEntityisintheManagedState">
<title>Testing if an Entity is in the Managed State</title>
<simpara>To check if a given object is presently managed by the entity manager, call <literal><phrase role="code">EntityManager.contains()</phrase></literal> and pass in the object of interest.</simpara>
</section>
</section>
<section id="sid-54493688_ErraiJPA-NamedQueries">
<title>Named Queries</title>
<simpara>To retrieve one or more entities that match a set of criteria, Errai JPA allows the use of JPA <emphasis>named queries</emphasis>. Named queries are declared in annotations on entity classes.</simpara>
<section id="sid-54493688_ErraiJPA-DeclaringNamedQueries">
<title>Declaring Named Queries</title>
<simpara>Queries in JPA are written in the JPQL language. As of Errai 2.1, Errai JPA does not support all JPQL features. Most importantly, implicit and explicit joins in queries are not yet supported. Queries of the following form generally work:</simpara>
<programlisting language="java" linenumbering="unnumbered">SELECT et FROM EntityType et WHERE [expression with constants, named parameters and attributes of et] ORDER BY et.attr1 [ASC|DESC], et.attr2 [ASC|DESC]</programlisting>
<simpara>Here is how to declare a JPQL query on an entity:</simpara>
<programlisting language="java" linenumbering="unnumbered">@NamedQuery(name="selectAlbumByName", query="SELECT a FROM Album a WHERE a.name=:name")
@Entity
public class Album {
  ... same as before ...
}</programlisting>
<simpara>To declare more than one query on the same entity, wrap the <literal><phrase role="code">@NamedQuery</phrase></literal> annotations in <literal><phrase role="code">@NamedQueries</phrase></literal> like this:</simpara>
<programlisting language="java" linenumbering="unnumbered">@NamedQueries({
  @NamedQuery(name="selectAlbumByName", query="SELECT a FROM Album a WHERE a.name = :name"),
  @NamedQuery(name="selectAlbumsAfter", query="SELECT a FROM Album a WHERE a.releaseDate &gt;= :startDate")
})
@Entity
public class Album {
  ... same as before ...
}</programlisting>
</section>
<section id="sid-54493688_ErraiJPA-ExecutingNamedQueries">
<title>Executing Named Queries</title>
<simpara>To execute a named query, retrieve it by name and result type from the entity manager, set the values of its parameters (if any), and then call one of the execution methods <literal><phrase role="code">getSingleResult()</phrase></literal> or <literal><phrase role="code">getResultList()</phrase></literal>.</simpara>
<simpara>Example:</simpara>
<programlisting language="java" linenumbering="unnumbered">    TypedQuery&lt;Album&gt; q = em.createNamedQuery("selectAlbumByName", Album.class);
    q.setParameter("name", "Let It Be");
    List&lt;Album&gt; fetchedAlbums = q.getResultList();</programlisting>
</section>
</section>
<section id="sid-54493688_ErraiJPA-EntityLifecycleEvents">
<title>Entity Lifecycle Events</title>
<simpara>To receive a notification when an entity instance transitions from one lifecycle state to another, use an entity lifecycle listener.</simpara>
<simpara>These annotations can be applied to methods in order to receive notifications at certain points in an entity&#8217;s lifecycle. These events are delivered for direct operations initiated on the EntityManager as well as operations that happen due to cascade rules.</simpara>
<informaltable frame="all"
    rowsep="1" colsep="1">
  
  <tgroup cols="2">
    
    <colspec colname="col_1" colwidth="50*"/>
    
    <colspec colname="col_2" colwidth="50*"/>
    
    
    <thead>
      
      <row>
        
        <entry align="left" valign="top">Annotation</entry>
        
        <entry align="left" valign="top">Meaning</entry>
        
      </row>
      
    </thead>
    
    <tbody>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">@PrePersist</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>The entity is about to be persisted or merged into the entity manager.</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">@PostPersist</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>The entity has just been persisted or merged into the entity manager.</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">@PreUpdate</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>The entity&#8217;s state is about to be captured into the browser&#8217;s localStorage.</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">@PostUpdate</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>The entity&#8217;s state has just been captured into the browser&#8217;s localStorage.</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">@PreRemove</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>The entity is about to be removed from persistent storage.</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">@PostRemove</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>The entity has just been removed from persistent storage.</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">@PostLoad</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>The entity&#8217;s state has just been retrieved from the browser&#8217;s localStorage.</simpara></entry>
        
      </row>
      
    </tbody>
    
  </tgroup>
</informaltable>
<simpara>JPA lifecycle event annotations can be placed on methods in the entity type itself, or on a method of any type with a public no-args constructor.</simpara>
<simpara>To receive lifecycle event notifications directly on the affected entity instance, create a no-args method on the entity class and annotate it with one or more of the lifecycle annotations in the above table.</simpara>
<simpara>For example, here is a variant of the Album class where instances receive notification right after they are loaded from persistent storage:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Entity
public class Album {

  ... same as before ...

  @PostLoad
  public void postLoad() {
    System.out.println("Album " + getName() + " was just loaded into the entity manager");
  }
}</programlisting>
<simpara>To receive lifecycle methods in a different class, declare a method that takes one parameter of the entity type and annotate it with the desired lifecycle annotations. Then name that class in the <literal><phrase role="code">@EntityListeners</phrase></literal> annotation on the entity type.</simpara>
<simpara>The following example produces the same results as the previous example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Entity
@EntityListeners(StandaloneLifecycleListener.class)
public class Album {

  ... same as always ...

}

public class StandaloneLifecycleListener {

  @PostLoad
  public void albumLoaded(Album a) {
  public void postLoad() {
    System.out.println("Album " + a.getName() + " was just loaded into the entity manager");
  }
}</programlisting>
</section>
<section id="sid-54493688_ErraiJPA-JPAMetamodel">
<title>JPA Metamodel</title>
<simpara>Errai captures structural information about entity types at compile time and makes them available in the GWT runtime environment. The JPA metamodel includes methods for enumerating all known entity types and enumerating the singular and plural attributes of those types. Errai extends the JPA 2.0 Metamodel by providing methods that can create new instances of entity classes, and read and write attribute values of existing entity instances.</simpara>
<simpara>As an example of what is possible, this functionality could be used to create a reusable UI widget that can present an editable table of any JPA entity type.</simpara>
<simpara>To access the JPA Metamodel, call the <literal><phrase role="code">EntityManager.getMetamodel()</phrase></literal> method. For details on what can be done with the stock JPA metamodel, see the API&#8217;s javadoc or consult the JPA specification.</simpara>
<section id="sid-54493688_ErraiJPA-ErraiExtensionstoJPAMetamodelAPI">
<title>Errai Extensions to JPA Metamodel API</title>
<simpara>Wherever you obtain an instance of <literal><phrase role="code">SingularAttribute</phrase></literal> from the metamodel API, you can down-cast it to <literal><phrase role="code">ErraiSingularAttribute</phrase></literal>. Likewise, you can down-cast any <literal><phrase role="code">PluralAttribute</phrase></literal> to <literal><phrase role="code">ErraiPluralAttribute</phrase></literal>.</simpara>
<simpara>In either case, you can read the value of an arbitrary attribute by calling <literal><phrase role="code">ErraiAttribute.get()</phrase></literal> and passing in the entity instance. You can set any attribute&#8217;s value by calling <literal><phrase role="code">ErraiAttribute.set()</phrase></literal>, passing in the entity instance and the new value.</simpara>
<simpara>In addition to <literal><phrase role="code">get()</phrase></literal> and <literal><phrase role="code">set()</phrase></literal>, <literal><phrase role="code">ErraiPluralAttribute</phrase></literal> also has the <literal><phrase role="code">createEmptyCollection()</phrase></literal> method, which creates an empty collection of the correct interface type for the given attribute.</simpara>
</section>
</section>
<section id="sid-54493688_ErraiJPA-JPAFeaturesNotImplementedinErrai2.4">
<title>JPA Features Not Implemented in Errai 2.4</title>
<simpara>The following features are not yet implemented, but could conceivably be implemented in a future Errai JPA release:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>Flush modes other than immediate</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Transactions, including EntityManager.getTransaction()</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>In named queries:</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Joins and nested attribute paths (<literal><phrase role="code">a.b.c</phrase></literal>) do not yet work, although single-step attribute paths (<literal><phrase role="code">a.b</phrase></literal>) do.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The <literal><phrase role="code">SELECT</phrase></literal> clause must specify exactly one entity type. Selection of individual attributes is not yet implemented.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Embedded collections</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Compound identifiers (presently, only basic types are supported for entity IDs)</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal><phrase role="code">EntityManager.refresh()</phrase></literal> to pick up changes made in localStorage from a different browser window/tab.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Criteria Queries</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The generated static Metamodel</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The <literal><phrase role="code">@PersistenceContext</phrase></literal> annotation currently has no effect in client-side code (use <literal><phrase role="code">@Inject</phrase></literal> instead)</simpara>
      
    </listitem>
  
</itemizedlist>

<simpara>The following may never be implemented due to limitations and restrictions in the GWT client-side environment:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara><literal><phrase role="code">EntityManager.createQuery(String, &#8230;)</phrase></literal> (that is, unnamed queries) are impractical because JPQL queries are parsed at compile time, not in the browser.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal><phrase role="code">EntityManager.createNativeQuery(String, &#8230;)</phrase></literal> don&#8217;t make sense because the underlying database is just a hash table. It does not have a query language.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Persistent attributes of type <literal><phrase role="code">java.util.Calendar</phrase></literal> because the <literal><phrase role="code">Calendar</phrase></literal> class is not in GWT&#8217;s JRE emulation library.</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
<section id="sid-54493688_ErraiJPA-OtherCaveatsforErrai2.1JPA">
<title>Other Caveats for Errai 2.1 JPA</title>
<simpara>We hope to remedy these shortcomings in a future release.</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>In Dev Mode, changes to entity classes are not discovered on page refresh. You need to restart Dev Mode.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The local data stored in the browser is not encrypted</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
</section>
<section id="sid-71467090">
<title>Errai JPA Data Sync</title>
<simpara>Traditional JPA implementations allow you to store and retrieve entity objects on the server side. Errai&#8217;s JPA implementation allows you to store and retrieve entity objects in the web browser using the same APIs. All that&#8217;s missing is the ability to synchronize the stored data between the server side and the client side.</simpara>
<simpara>This is where Errai JPA Data Sync comes in: it provides an easy mechanism for two-way synchronization of data sets between the client and the server.</simpara>
<section id="sid-71467090_ErraiJPADataSync-HowToUseIt">
<title>How To Use It</title>
<note>
<title>Manual Setup</title>
<simpara>Checkout the <link linkend="Manual-Setup-Section">Manual Setup Section</link> for instructions on how to manually add Errai JPA Datasync to your project.</simpara>
</note>
<section id="sid-71467090_ErraiJPADataSync-ARunningExample">
<title>A Running Example</title>
<simpara>For the rest of this chapter, we will refer to the following Entity classes, which are defined in a <literal><phrase role="code">shared</phrase></literal> package that&#8217;s visible to client and server code:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Portable
@Entity
@NamedQuery(name = "allUsers", query = "SELECT u FROM User u")
public class User {

  @Id
  @GeneratedValue
  private long id;

  private String name;

  // getters and setters omitted
}</programlisting>
<programlisting language="java" linenumbering="unnumbered">@Portable
@Entity
@NamedQuery(name = "groceryListsForUser", query = "SELECT gl FROM GroceryList gl WHERE gl.owner=:user")
public class GroceryList {

  @Id
  @GeneratedValue
  private long id;

  @ManyToOne
  private User owner;

  @OneToMany(cascade = { CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REFRESH })
  private List&lt;Item&gt; items = new ArrayList&lt;Item&gt;();

  // getters and setters omitted
}</programlisting>
<programlisting language="java" linenumbering="unnumbered">@Portable
@Entity
@NamedQuery(name = "allItems", query = "SELECT i FROM Item i")
public class Item {

  @Id
  @GeneratedValue
  private long id;

  private String name;
  private String department;
  private String comment;
  private Date addedOn;

  @ManyToOne(cascade = { CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REFRESH })
  private User addedBy;

  // getters and setters omitted
}</programlisting>
<simpara>To summarize: there are three entity types: <literal><phrase role="code">User</phrase></literal>, <literal><phrase role="code">GroceryList</phrase></literal>, and <literal><phrase role="code">Item</phrase></literal>. Each <literal><phrase role="code">GroceryList</phrase></literal> belongs to a <literal><phrase role="code">User</phrase></literal> and has a list of <literal><phrase role="code">Item</phrase></literal> objects.</simpara>
<note>
<simpara>All the entities involved in the data synchronization request must be marshallable via Errai Marshalling. This is normally accomplished by adding the <literal><phrase role="code">@Portable</phrase></literal> annotation to each JPA entity class, but it is also acceptable to list them in <literal><phrase role="code">ErraiApp.properties</phrase></literal>. See the <link linkend="sid-5931328">Marshalling</link> section for more details.</simpara>
</note>
<simpara>Now let&#8217;s say we want to synchronize the data for all of a user&#8217;s grocery lists. This will make them available for offline use through Errai JPA, and at the same time it will update the server with the latest changes made on the client. Ultimately, the sync operation is accomplished via an annotated method or an asynchronous call into <literal>ClientSyncManager</literal>, but first we have to prepare a few things on the client and the server.</simpara>
</section>
<section id="sid-71467090_ErraiJPADataSync-ServerSide%E2%80%93DataSyncServiceImpl">
<title>Server Side DataSyncServiceImpl</title>
<simpara>A data sync operation begins when the client-side sync manager sends an <link linkend="sid-5931313">Errai RPC</link> request to the server. Although a server-side implementation of the remote interface is provided, you are responsible for implementing a thin wrapper around it. This wrapper serves two purposes:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>It allows you to determine how to obtain a reference to the JPA EntityManager (and to choose which persistence context the server-side data sync will operate on)</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>It allows you to inspect the contents of each sync request and make security decisions about access to particular entities</simpara>
      
    </listitem>
  
</orderedlist>
<simpara>If you are deploying to a container that supports CDI and EJB 3, you can use this DataSyncServiceImpl as a template for your own:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Stateless @org.jboss.errai.bus.server.annotations.Service
public class DataSyncServiceImpl implements DataSyncService {

  @PersistenceContext
  private EntityManager em;

  private final JpaAttributeAccessor attributeAccessor = new JavaReflectionAttributeAccessor();

  @Inject private LoginService loginService;

  @Override
  public &lt;X&gt; List&lt;SyncResponse&lt;X&gt;&gt; coldSync(SyncableDataSet&lt;X&gt; dataSet, List&lt;SyncRequestOperation&lt;X&gt;&gt; remoteResults) {

    // Ensure a user is logged in
    User currentUser = loginService.whoAmI();
    if (currentUser == null) {
      throw new IllegalStateException("Nobody is logged in!");
    }

    // Ensure user is accessing their own data!
    if (dataSet.getQueryName().equals("groceryListsForUser")) {
      User requestedUser = (User) dataSet.getParameters().get("user");
      if (!currentUser.getId().equals(requestedUser.getId())) {
        throw new AccessDeniedException("You don't have permission to sync user " + requestedUser.getId());
      }
    }
    else {
      throw new IllegalArgumentException("You don't have permission to sync dataset " + dataSet.getQueryName());
    }

    DataSyncService dss = new org.jboss.errai.jpa.sync.server.DataSyncServiceImpl(em, attributeAccessor);
    return dss.coldSync(dataSet, remoteResults);
  }
}</programlisting>
<simpara>If you are not using EJB 3, you will not be able to use the <literal><phrase role="code">@PersistenceContext</phrase></literal> annotation. In this case, obtain a reference to your EntityManager the same way you would anywhere else in your application.</simpara>
</section>
<section id="ErraiJPADataSync-ClientSide-Declarative">
<title>Client Side&#8201;&#8212;&#8201;Declarative</title>
<simpara>Like many Errai features, Errai JPA DataSync provides an annotation-driven programming model and a programmatic API.
You can choose which to use based on your needs and preferences.</simpara>
<simpara>The declarative data sync API is driven by the <literal>@Sync</literal> annotation. Consider the following example client-side class:</simpara>
<programlisting language="java" linenumbering="unnumbered">  // This injected User object could have been set up in a @PostConstruct method instead of being injected.
  @Inject
  private User syncThisUser;

  @Sync(query = "groceryListsForUser", params = { @SyncParam(name = "user", val = "{syncThisUser}") })
  private void onDataSyncComplete(SyncResponses&lt;GroceryList&gt; responses) {
    Window.alert("Data Sync Complete!");
  }</programlisting>
<simpara>By placing the above code snippet in a client-side bean, you tell Errai JPA Data Sync that, as long as a managed
instance of the bean containing the <literal>@Sync</literal> method exists, the Data Sync system should keep all grocery lists
belonging to the <literal>syncThisUser</literal> user in sync between the client-side JPA EntityManager and the server-side EntityManager.
Right now, the data sets are kept in sync using a sync request every 5 seconds. In the future, this may be optimised
to an incremental approach that pushes changes as they occur.</simpara>
<simpara>The annotated method needs to have exactly one parameter of type <literal>SyncResponses</literal> and will
be called each time a data sync operation has completed. All sync operations passed to the
method will have already been applied to the local EntityManager, with conflicts resolved in
favour of the server&#8217;s version of the data. The original client values are available in the
<literal>SyncResponses</literal> object, which gives you a chance to implement a different conflict
resolution policy.</simpara>
<simpara>The <literal>query</literal> attribute on the <literal>@Sync</literal> annotation must refer to an existing JPA Named Query that is defined on a shared
JPA entity class.</simpara>
<simpara>The <literal>params</literal> attribute is an array of <literal>@SyncParam</literal> annotations. There must be exactly one <literal>@SyncParam</literal> for each named
parameter in the JPA query (positional parameters are not supported). If the <literal>val</literal> argument is surrounded with brace
brackets (as it is in the example aboce) then it is interpreted as a reference to a declared or inherited field in
the containing class. Otherwise, it is interpreted as a literal String value.</simpara>
<note>
<simpara>Field-reference sync params are captured just after the bean&#8217;s <literal>@PostConstruct</literal> method is invoked. This means that
values of referenced fields can be provided using <literal>@Inject</literal> (which in turn could come from a CDI Producer method)
or by code in the <literal>@PostConstruct</literal> method.</simpara>
</note>
<simpara>Transport (network) errors are logged to the slf4j logger channel <literal>org.jboss.errai.jpa.sync.client.local.ClientSyncWorker</literal>.
As of Errai 3.0.0.M4, it is not possible to specify a custom error handler using the declarative API. See the next
section for information about the programmatic API.</simpara>
</section>
<section id="ErraiJPADataSync-ClientSide-Programmatic">
<title>Client Side&#8201;&#8212;&#8201;Programmatic</title>
<programlisting language="java" linenumbering="unnumbered">  @Inject private ClientSyncManager syncManager;
  @Inject private EntityManager em;

  public void syncGroceryLists(User forUser) {
    RemoteCallback&lt;List&lt;SyncResponse&lt;GroceryList&gt;&gt;&gt; onCompletion = new RemoteCallback&lt;List&lt;SyncResponse&lt;GroceryList&gt;&gt;&gt;() {
      @Override
      public void callback(List&lt;SyncResponse&lt;GroceryList&gt;&gt; response) {
        Window.alert("Data Sync Complete!");
      }
    };

    ErrorCallback&lt;?&gt; onError = new BusErrorCallback() {

      @Override
      public boolean error(Message message, Throwable throwable) {
        Window.alert("Data Sync failed!");
        return false;
      }
    };

    Map&lt;String, Object&gt; queryParams = new HashMap&lt;String, Object&gt;();
    queryParams.put("user", forUser);

    syncManager.coldSync("groceryListsForUser", GroceryList.class, queryParams, onCompletion, onError);
  }</programlisting>
<important>
<simpara>The <literal><phrase role="code">onCompletion</phrase></literal> and <literal><phrase role="code">onError</phrase></literal> callbacks are optional. In the unlikely case that your application doesn&#8217;t
care if a data sync request completed successfully, you can pass <literal><phrase role="code">null</phrase></literal> for either callback.</simpara>
</important>
<simpara>Once your <literal><phrase role="code">onCompletion</phrase></literal> callback has been notified, the server and client will have the same entities stored in
their respective databases for all entities reachable from the given query result.</simpara>
</section>
<section id="sid-71467090_ErraiJPADataSync-DealingWithConflicts">
<title>Dealing With Conflicts</title>
<simpara>When the client sends the sync request to the server, it includes information about the state it expects each entity to be in. If an entity&#8217;s state on the server does not match this expected state on the client, the server ignores the client&#8217;s change request and includes a <literal><phrase role="code">ConflictResponse</phrase></literal> object in the sync reply.</simpara>
<simpara>When the client processes the sync responses from the server, it applies the new state from the server to the local data store. This overwrites the change that was initially requested from the client. In short, you could call this the "server wins" conflict resolution policy.</simpara>
<simpara>In some cases, your application may be able to do something smarter: apply domain-specific knowledge to merge the conflict automatically, or prompt the user to perform a manual merge. In order to do this, you will have to examine the server response from inside the <literal><phrase role="code">onCompletion</phrase></literal> callback you provided to the <literal><phrase role="code">coldSync()</phrase></literal> method:</simpara>
<programlisting language="java" linenumbering="unnumbered">    RemoteCallback&lt;List&lt;SyncResponse&lt;GroceryList&gt;&gt;&gt; onCompletion = new RemoteCallback&lt;List&lt;SyncResponse&lt;GroceryList&gt;&gt;&gt;() {
      @Override
      public void callback(List&lt;SyncResponse&lt;GroceryList&gt;&gt; responses) {
        for (SyncResponse&lt;GroceryList&gt; response : responses) {
          if (response instanceof ConflictResponse) {
            ConflictResponse&lt;GroceryList&gt; cr = (ConflictResponse&lt;GroceryList&gt;) response;
            List&lt;Item&gt; expectedItems = cr.getExpected().getItems();
            List&lt;Item&gt; serverItems = cr.getActualNew().getItems();
            List&lt;Item&gt; clientItems = cr.getRequestedNew().getItems();

            // merge the list of items by comparing each to expectedItems
            List&lt;Item&gt; merged = ...;

            // update local storage with the merged list
            em.find(GroceryList.class, cr.getActualNew().getId()).setItems(merged);
            em.flush();
          }
        }
      }
    };</programlisting>
<simpara>Remember, because of Errai&#8217;s default "server wins" resolution policy, the call to <literal><phrase role="code">em.find(GroceryList.class, cr.getActualNew().getId())</phrase></literal> will return a GroceryList object that has already been updated to match the state present in <literal><phrase role="code">serverItems</phrase></literal>.</simpara>
<note>
<simpara>Searching for ConflictResponse objects in the <literal><phrase role="code">onCompletion</phrase></literal> callback is the only way to recover client data that was clobbered in a conflict. If you do not merge this data back into local storage, or at least retain a reference to the <literal><phrase role="code">cr.getRequestedNew()</phrase></literal> object, this conflicting client data will be lost forever.</simpara>
<simpara>In a future release of Errai JPA, we plan to provide a client-side callback mechanism for custom conflict handling. If such a callback is registered, it will override the default behaviour.</simpara>
</note>
</section>
</section>
</section>
</chapter>
<chapter id="sid-51282340">
<title>Data Binding</title>
<simpara>Errai&#8217;s data binding module provides the ability to bind model objects to UI components. The bound properties of the model and the UI components will automatically be kept in sync for as long as they are bound. With Errai Data Binding there is no need to write code for UI updates in response to model changes and no need to register listeners to update the model in response to UI changes.</simpara>
<section id="sid-51282340_DataBinding-GettingStarted">
<title>Getting Started</title>
<simpara>The data binding module is directly integrated with <link linkend="sid-51806600">Errai UI</link> and <link linkend="sid-54493688">Errai JPA</link> but can also be used as a standalone project in any GWT client application:</simpara>
<note>
<title>Manual Setup</title>
<simpara>Checkout the <link linkend="Manual-Setup-Section">Manual Setup Section</link> for instructions on how to manually add Errai Data Binding to your project.</simpara>
</note>
<section id="sid-51282340_DataBinding-BindableObjects">
<title>Bindable Objects</title>
<simpara>Objects that should participate in data bindings have to be marked as <literal><phrase role="code">@Bindable</phrase></literal> and must follow Java bean conventions. All editable properties of these objects are then bindable to UI widgets.</simpara>
<example>
<title>Customer.java</title>
<programlisting language="java" linenumbering="unnumbered">@Bindable
public class Customer {
  ...
  private String name;

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }
  ...
}</programlisting>
</example>
<important>
<simpara>If you cannot or prefer not to annotate your classes with <literal><phrase role="code">@Bindable</phrase></literal>, you can alternatively specify bindable types in your ErraiApp.properties using a whitespace-separated list of fully qualified class names: <literal><phrase role="code">errai.ui.bindableTypes=org.example.Model1 org.example.Model2</phrase></literal></simpara>
</important>
</section>
<section id="sid-51282340_DataBinding-InitializingaDataBinder">
<title>Initializing a DataBinder</title>
<simpara>An instance of <literal><phrase role="code">DataBinder</phrase></literal> is required to create bindings. It can either be</simpara>
<simpara>injected into a client-side bean:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class CustomerView {
  @Inject
  private DataBinder&lt;Customer&gt; dataBinder;
}</programlisting>
<simpara>or created manually:</simpara>
<programlisting language="java" linenumbering="unnumbered">DataBinder&lt;Customer&gt; dataBinder = DataBinder.forType(Customer.class);</programlisting>
<simpara>In both cases above, the <literal><phrase role="code">DataBinder</phrase></literal> instance is associated with a new instance of the model (e.g. a new <literal><phrase role="code">Customer</phrase></literal> object). A <literal><phrase role="code">DataBinder</phrase></literal> can also be associated with an already existing object:</simpara>
<programlisting language="java" linenumbering="unnumbered">DataBinder&lt;Customer&gt; dataBinder = DataBinder.forModel(existingCustomerObject);</programlisting>
<simpara>In case there is existing state in either the model object or the UI components before the they are bound, initial state synchronization can be carried out to align the model and the corresponding UI fields.</simpara>
<simpara>For using the model object&#8217;s state to set the initial values in the UI:</simpara>
<programlisting language="java" linenumbering="unnumbered">DataBinder&lt;Customer&gt; dataBinder = DataBinder.forModel(existingCustomerObject, InitialState.FROM_MODEL);</programlisting>
<simpara>For using the UI values to set the initial state in the model object:</simpara>
<programlisting language="java" linenumbering="unnumbered">DataBinder&lt;Customer&gt; dataBinder = DataBinder.forModel(existingCustomerObject, InitialState.FROM_UI);</programlisting>
</section>
</section>
<section id="sid-51282340_DataBinding-CreatingBindings">
<title>Creating Bindings</title>
<simpara>Bindings can be created by calling the <literal><phrase role="code">bind</phrase></literal> method on a <literal><phrase role="code">DataBinder</phrase></literal> instance, thereby specifying which widgets should be bound to which properties of the model. It is possible to use property chains for bindings, given that all nested properties are of bindable types. When binding to <literal><phrase role="code">customer.address.streetName</phrase></literal>, for example, both <literal><phrase role="code">customer</phrase></literal> and <literal><phrase role="code">address</phrase></literal> have to be of a type annotated with <literal><phrase role="code">@Bindable</phrase></literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">import elemental2.dom.HTMLInputElement;
...

public class CustomerView {
  @Inject private DataBinder&lt;Customer&gt; dataBinder;

  @Inject private HTMLInputElement nameInput; <co id="CO1-1"/>
  @Inject private HTMLInputElement ageInput; <co id="CO1-2"/>
  // more fields...

  @PostConstruct
  private void init() {

    nameInput.type = "text";
    ageInput.type = "number";

    Customer customer = dataBinder
        .bind(nameInput, "name") <co id="CO1-3"/>
        .bind(ageInput, "age") <co id="CO1-4"/>
        .getModel();
  }
}</programlisting>
<note>
<title>Elemental 2 API</title>
<simpara><literal>nameInput</literal> and <literal>ageInput</literal> are of type <literal>HTMLInputElement</literal>, which is provided by Elemental 2 [1] as a representation of the actual DOM. Every Elemental 2 class or interface is  <literal>@JsType(isNative=true)</literal>. More on this later.</simpara>
<simpara>[1] <ulink url="https://github.com/google/elemental2">https://github.com/google/elemental2</ulink></simpara>
</note>
<note>
<title>Errai DOM wrappers at <literal>org.jboss.errai.common.client.dom</literal> are still supported.</title>
<simpara>Since Elemental 2 API became the standard DOM API in Errai, using Errai DOM wrappers became deprecated, but their use is still supported, <emphasis role="strong">though not recommended</emphasis>.</simpara>
</note>
<calloutlist>
  
  <callout arearefs="CO1-1 CO1-3">
    <para>As <literal>nameInput</literal> is an <literal>input[type='text']</literal> element, Errai will correctly infer that it stores a String.</para>
    
  </callout>
  
  <callout arearefs="CO1-2 CO1-4">
    <para><literal>ageInput</literal> is an <literal>input[type='number']</literal> element. Errai will also be able to infer that this stores a number.</para>
    
  </callout>
  
</calloutlist>
<simpara>After the call to <literal><phrase role="code">dataBinder.bind()</phrase></literal> in the example above, the customer object&#8217;s name property and the <literal><phrase role="code">nameInput</phrase></literal> are kept in sync until either the <literal><phrase role="code">dataBinder.unbind()</phrase></literal> method is called or the <literal><phrase role="code">CustomerView</phrase></literal> bean is destroyed.</simpara>
<simpara>That means that a call to <literal><phrase role="code">customer.setName()</phrase></literal> will automatically update the value of the HTMLInputElement and any change to the <literal>nameInput</literal> value in the browser will update the customer object&#8217;s name property. So, <literal><phrase role="code">customer.getName()</phrase></literal> will always reflect the currently displayed value of the <literal><phrase role="code">nameInput</phrase></literal>.</simpara>
<note>
<simpara>It&#8217;s important to retrieve the model instance using dataBinder.getModel() before making changes to it as the data binder will provide a proxy to the model to ensure that changes will update the corresponding UI components.</simpara>
</note>
<tip>
<simpara>Errai also provides a <link linkend="sid-51282340_DataBinding-DeclarativeBinding">declarative binding API</link> that can be used to create bindings automatically based on matching field and model property names.</simpara>
</tip>
</section>
<section id="sid-51282340_DataBinding-SpecifyingConverters">
<title>Specifying Converters</title>
<simpara>Errai has built-in conversion support for all Number types as well as Boolean and Date to java.lang.String and vice versa. However, in some cases it will be necessary to provide custom converters (e.g. if a custom date format is desired). This can be done on two levels.</simpara>
<section id="sid-51282340_DataBinding-Registeringaglobaldefaultconverter">
<title>Registering a global default converter</title>
<programlisting language="java" linenumbering="unnumbered">@DefaultConverter
public class MyCustomDateConverter implements Converter&lt;Date, String&gt; {

  private static final String DATE_FORMAT = "YY_DD_MM";

  @Override
  public Class&lt;Date&gt; getModelType() {
    return Date.class;
  }

  @Override
  public Date toModelValue(String widgetValue) {
    return DateTimeFormat.getFormat(DATE_FORMAT).parse(widgetValue);
  }

  @Override
  public Class&lt;String&gt; getComponentType() {
    return String.class;
  }

  @Override
  public String toWidgetValue(Date modelValue) {
    return DateTimeFormat.getFormat(DATE_FORMAT).format((Date) modelValue);
  }
}</programlisting>
<simpara>All converters annotated with <literal><phrase role="code">@DefaultConverter</phrase></literal> will be registered as global defaults calling <literal><phrase role="code">Convert.registerDefaultConverter()</phrase></literal>. Note that the <literal><phrase role="code">Converter</phrase></literal> interface specifies two type parameters. The first one represents the type of the model field, the second one the type held by the widget (e.g. <literal><phrase role="code">String</phrase></literal> for widgets implementing <literal><phrase role="code">HasValue&lt;String&gt;</phrase></literal>). These default converters will be used for all bindings with matching model and widget types.</simpara>
</section>
<section id="sid-51282340_DataBinding-Providingabindingspecificconverter">
<title>Providing a binding-specific converter</title>
<simpara>Alternatively, converter instances can be passed to the <literal><phrase role="code">dataBinder.bind()</phrase></literal> calls.</simpara>
<programlisting language="java" linenumbering="unnumbered">dataBinder.bind(textBox, "name", customConverter);</programlisting>
<simpara>Converters specified on the binding level take precedence over global default converters with matching types. Errai will validate that the converter model type matches the actual type of the bound property. If Errai is able to infer the value type in the bound UI component, it will also validate that it matches the component type of the converter.</simpara>
</section>
<section id="_errai_ui_value_inference">
<title>Errai UI Value Inference</title>
<simpara>For many kinds of DOM elements and Widgets Errai can correctly infer the type of value stored. When Errai cannot infer the component type, it will fallback to the component type of any specified converters. If no converters are specified, Errai assumes the UI component stores a String.</simpara>
</section>
<section id="_ui_component_values">
<title>UI Component Values</title>
<simpara>Originally, Errai only supported binding with Widgets implementing <literal>com.google.gwt.user.client.TakesValue</literal>. Now that Errai supports binding with DOM elements directly here are all the binding rules:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>As before, if a component implements <literal>com.google.gwt.user.client.TakesValue</literal> or <literal>com.google.gwt.user.client.ui.HasValue</literal>, it is bound using that interface. The type can only be inferred at runtime for Widgets in gwt-user.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>If a component implements <literal>com.google.gwt.user.client.ui.HasText</literal> it is bound using that interface. The value type can only be <literal>String</literal>.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>If a component is a native DOM element (via JS interop or a <literal>JavaScriptObject</literal>), it is bound by the following rules:</simpara>
      

<itemizedlist>
  
    <listitem>
      <simpara>An <literal>InputElement</literal> stores the bound value in its <literal>value</literal> attribute. The type of the value is determined by the element&#8217;s <literal>type</literal> attribute (<literal>text</literal> has type <literal>String</literal>, <literal>number</literal> has type <literal>Double</literal>, <literal>checkbox</literal> has type <literal>Boolean</literal>, etc.).</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>All other elements store bound values as text content (i.e. the value between the HTML tags). The content is presumed to be a strings.</simpara>
      
    </listitem>
  
</itemizedlist>


      
    </listitem>
  
    <listitem>
      <simpara>If a component implements <literal>org.jboss.errai.common.client.api.IsElement</literal>, binding is performed on the DOM element returned by <literal>IsElement.getElement()</literal> with the above specified rules.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>If a component implements <literal>org.jboss.errai.common.client.api.elemental2.IsElement</literal>, binding is performed on the DOM element returned by <literal>IsElement.getElement()</literal> with the above specified rules.</simpara>
      
    </listitem>
  
</itemizedlist>

<note>
<title>Inference at Run-Time versus Inference at Compile-Time</title>
<simpara>The above rules for inferring values are those used when you directly use the data-binding API. Using the declarative API it is possible create custom JS interop interfaces for DOM elements where you can specify how values are bound to the element (see <link linkend="Customizing-Element-Binding-Behaviour">Customizing Element Binding Behaviour</link>).</simpara>
</note>
</section>
</section>
<section id="sid-51282340_DataBinding-PropertyChangeHandlers">
<title>Property Change Handlers</title>
<simpara>In some cases keeping the model and the UI in sync is not enough. Errai&#8217;s <literal><phrase role="code">DataBinder</phrase></literal> allows for the registration of <literal><phrase role="code">PropertyChangeHandlers</phrase></literal> for specific properties, property expressions or all properties of a bound model. A property expression can be a property chain such as customer.address.street. It can end in a wildcard to indicate that changes of any property of the corresponding bean should be observed (e.g <literal><phrase role="code">"customer.address.*"</phrase></literal>). A double wildcard can be used at the end of a property expression to register a cascading change handler for any nested property (e.g <literal><phrase role="code">"customer.**"</phrase></literal> or just <literal><phrase role="code">"**"</phrase></literal>).</simpara>
<simpara>This provides a uniform notification mechanism for model and UI value changes. <literal><phrase role="code">PropertyChangeHandlers</phrase></literal> can be used to carry out any additional logic that might be necessary after a model or UI value has changed.</simpara>
<programlisting language="java" linenumbering="unnumbered">dataBinder.addPropertyChangeHandler(new PropertyChangeHandler() {
  @Override
  public void onPropertyChange(PropertyChangeEvent event) {
    Window.alert(event.getPropertyName() + " changed to:" + event.getNewValue());
  }
});</programlisting>
<programlisting language="java" linenumbering="unnumbered">dataBinder.addPropertyChangeHandler("name", new PropertyChangeHandler() {
  @Override
  public void onPropertyChange(PropertyChangeEvent event) {
    Window.alert("name changed to:" + event.getNewValue());
  }
});</programlisting>
</section>
<section id="sid-51282340_DataBinding-DeclarativeBinding">
<title>Declarative Binding</title>
<simpara>Programmatic binding as described above (see <link linkend="sid-51282340_DataBinding-CreatingBindings">Creating Bindings</link>) can be tedious when working with UI components that contain a large number of input fields. Errai provides an annotation-driven binding API that can be used to create bindings automatically which cuts a lot of boilerplate code. Additionally the declarative API also supports binding properties to native jsinterop types or <literal><phrase role="code">JavaScriptObjects</phrase></literal> that wrap DOM elements. The declarative API will work in any <link linkend="sid-5931402">Errai IOC</link> managed bean (including <link linkend="sid-51806600">Errai UI</link> templates). Simply inject a data binder or model object and declare the bindings using <literal><phrase role="code">@Bound</phrase></literal>.</simpara>
<simpara>Here is a simple example using an injected model object provided by the <literal><phrase role="code">@Model</phrase></literal> annotation (field injection is used here, but constructor and method injection are supported as well):</simpara>
<programlisting language="java" linenumbering="unnumbered">@Dependent
public class CustomerView {
  @Inject @Model
  private Customer customer;

  @Inject @Bound
  private HTMLInputElement name;

  @Bound
  private Label id = new Label();

  ....
}</programlisting>
<simpara>Here is the same example injecting a <literal><phrase role="code">DataBinder</phrase></literal> instead of the model object. This is useful when more control is needed (e.g. the ability to register property change handlers). The <literal><phrase role="code">@AutoBound</phrase></literal> annotation specifies that this <literal><phrase role="code">DataBinder</phrase></literal> should be used to bind the model to all enclosing widgets annotated with <literal><phrase role="code">@Bound</phrase></literal>. This example uses field injection again but constructor and method injection are supported as well.</simpara>
<programlisting language="java" linenumbering="unnumbered">import static elemental2.dom.DomGlobal.document;
...

@Dependent
public class CustomerView {

  @Inject @AutoBound
  private DataBinder&lt;Customer&gt; customerBinder;

  @Inject @Bound
  private HTMLInputElement name;

  @Bound
  private HTMLLabelElement id = (HTMLLabelElement) document.createElement("label"); (1)

  ...
}</programlisting>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>Casting is necessary here. That is the Elemental 2&#8217;s recommended way to create <literal>HTMLElement</literal> instances without injection. Using <literal>@Inject</literal> would have the exact same effect.</simpara>
      
    </listitem>
  
</orderedlist>
<simpara>In both examples above an instance of the <literal><phrase role="code">Customer</phrase></literal> model is automatically bound to the corresponding UI components based on matching field names. The model object and the UI fields will automatically be kept in sync. UI components from all enclosing fields and methods annotated with <literal><phrase role="code">@Bound</phrase></literal>, of the class that defines the <literal><phrase role="code">@AutoBound DataBinder</phrase></literal> or <literal><phrase role="code">@Model</phrase></literal> and all its super classes, are used.</simpara>
<section id="Customizing-Element-Binding-Behaviour">
<title>Customizing Element Binding Behaviour</title>
<simpara>Since Widget bindings can use the <literal>HasValue</literal> or <literal>TakesValue</literal> interfaces at runtime, these can obviously be used to add customized binding behaviour. But you might well be wondering how this is done when binding directly to elements.</simpara>
<simpara>Custom element binding behaviour can be achieved by creating your own element wrappers with JS interop.</simpara>
<programlisting language="java" linenumbering="unnumbered">@JsType(isNative=true, name="HTMLLabelElement", namespace = JsPackage.GLOBAL) <co id="CO2-1"/>
public class IntegerLabel extends elemental2.dom.HTMLLabelElement <co id="CO2-2"/>
                          implements org.jboss.errai.common.client.ui.HasValue&lt;Integer&gt; <co id="CO2-3"/>
{
  @JsOverlay <co id="CO2-4"/>
  public Integer getValue() {
    return Integer.valueOf(textContent);
  }

  @JsOverlay <co id="CO2-5"/>
  public void setValue(Integer content) {
    textContent = content.toString();
  }
}</programlisting>
<calloutlist>
  
  <callout arearefs="CO2-1">
    <para>In the JS interop API, native JS types are thin wrappers around JavaScript objects.</para>
    
  </callout>
  
  <callout arearefs="CO2-2">
    <para>The type inherits Elemental 2 API&#8217;s <literal>HTMLLabelElement</literal>.</para>
    
  </callout>
  
  <callout arearefs="CO2-3">
    <para>This <literal>HasValue</literal> interface is analogous to the on in gwt-user, but it is <emphasis role="strong">only meant for native JS types</emphasis>.</para>
    
  </callout>
  
  <callout arearefs="CO2-4 CO2-5">
    <para>The overridden methods of <literal>HasValue</literal> are <literal>@JsOverlay</literal> methods. Even though <literal>IntegerLabel</literal> wil be a native JavaScript object at runtime, we can add <literal>@JsOverlay</literal> methods to add some behaviour on top of the JavaScript API.</para>
    
  </callout>
  
</calloutlist>
<simpara>Using declarative binding, you can bind an integer value to this <literal>IntegerLabel</literal>, and Errai will use the <literal>@JsOverlay</literal> implementations of <literal>getValue</literal>/<literal>setValue</literal> to manipulate the value in the underlying label element.</simpara>
<note>
<title>HasValue and other JS interop mappings</title>
<simpara>At <literal>@JsOverlay</literal> is the most powerful way to define custom binding behaviour, but in some cases it can be more convenient to use <literal>@JsProperty</literal> or <literal>@JsMethod</literal> to map the <literal>HasValue</literal> methods to properties or member functions on the underlying JavaScript object.</simpara>
</note>
<warning>
<title>Only supported via declarative API</title>
<simpara>Because of limitations on native JS types, this approach using the native <literal>HasValue</literal> interface only works with declarative binding.</simpara>
</warning>
</section>
<section id="sid-51282340_DataBinding-Default%2CSimple%2CandChainedPropertyBindings">
<title>Default, Simple, and Chained Property Bindings</title>
<simpara>By default, bindings are determined by matching field names to property names on the model object. In the examples above, the field <literal><phrase role="code">name</phrase></literal> was automatically bound to the JavaBeans property <literal><phrase role="code">name</phrase></literal> of the model (<literal><phrase role="code">user</phrase></literal> object). If the field name does not match the model property name, you can use the <literal><phrase role="code">property</phrase></literal> attribute of the <literal><phrase role="code">@Bound</phrase></literal> annotation to specify the name of the property. The property can be a simple name (for example, "name") or a property chain (for example, <literal><phrase role="code">user.address.streetName</phrase></literal>). When binding to a property chain, all properties but the last in the chain must refer to @Bindable values.</simpara>
<simpara>The following example illustrates all three scenarios:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Bindable
public class Address {
  private String line1;
  private String line2;
  private String city;
  private String stateProv;
  private String country;

  // getters and setters
}

@Bindable
public class User {
  private String name;
  private String password;
  private Date dob;
  private Address address;
  private List&lt;Role&gt; roles;

  // getters and setters
}

@Templated
public class UserWidget {
  @Inject @AutoBound DataBinder&lt;User&gt; user;
  @Inject @Bound HTMLInputElement name;
  @Inject @Bound(property="dob") DatePicker dateOfBirth;
  @Inject @Bound(property="address.city") TextBox city;
}</programlisting>
<simpara>In <literal><phrase role="code">UserWidget</phrase></literal> above, the <literal><phrase role="code">name</phrase></literal> text box is bound to <literal><phrase role="code">user.name</phrase></literal> using the default name matching; the <literal><phrase role="code">dateOfBirth</phrase></literal> date picker is bound to <literal><phrase role="code">user.dob</phrase></literal> using a simple property name mapping; finally, the <literal><phrase role="code">city</phrase></literal> text box is bound to <literal><phrase role="code">user.address.city</phrase></literal> using a property chain. Note that the <literal><phrase role="code">Address</phrase></literal> class is required to be <literal><phrase role="code">@Bindable</phrase></literal> in this case.</simpara>
</section>
<section id="sid-51282340_DataBinding-DataConverters">
<title>Data Converters</title>
<simpara>The <literal><phrase role="code">@Bound</phrase></literal> annotation further allows to specify a converter to use for the binding (see <link linkend="sid-51282340_DataBinding-SpecifyingConverters">Specifying Converters</link> for details). This is how a binding specific converter can be specified on a data field:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Inject
@Bound(converter=MyDateConverter.class)
@DataField
private HTMLInputElement date;</programlisting>
</section>
<section id="_updating_model_values_on_ui_text_changes">
<title>Updating model values on UI text changes</title>
<simpara>By default, Errai DataBinding updates model values when the corresponding Widget fires a ValueChangeEvent. For text-based widgets, this means that the model values are updated only once the widget loses focus. However in some cases, you may also need to update a model&#8217;s value as soon as the text changes in the Widget.</simpara>
<simpara>Errai allows you to do this by setting the <literal><phrase role="code">onKeyUp</phrase></literal> flag in the <literal><phrase role="code">@Bound</phrase></literal> annotation. <emphasis role="strong"><emphasis>Note that this parameter can only be used on Widgets that extend GWT&#8217;s ValueBoxBase widget, DOM wrappers backed by input elements and any class or interface of the Elemental 2 API</emphasis></emphasis>. Setting this parameter to <literal><phrase role="code">true</phrase></literal> will cause the model value to update on a KeyUpEvent as well as the default ValueChangeEvent. This will result in the model object being updated as soon as any text is entered/removed from the Widget. You can specify this as follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Inject
@Bound(onKeyUp = true)
private HTMLInputElement name;</programlisting>
<simpara>You can also achieve the same effect using programmatic bindings. To do this, you can use the method <literal><phrase role="code">DataBinder.bind(Widget widget, String property, Converter converter, boolean bindOnKeyUp)</phrase></literal>. As an example, take a look at the following code snippet:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Inject
DataBinder&lt;Model&gt; binder;

@Inject
private HTMLInputElement nameTextBox;

...

@PostConstruct
public void onLoad() {
  binder.bind(nameTextBox, "name", converter, true);
}
</programlisting>
<important>
<title>Text Based Widgets</title>
<simpara>Binding on key events is only valid for text-based Widgets, i.e. those that extend ValueBoxBase. Errai DataBinding will throw an exception if the onKeyUp parameter is set on any non-ValueBoxBased Widgets.</simpara>
</important>
</section>
<section id="sid-51282340_DataBinding-Replacingamodelobject">
<title>Replacing a model object</title>
<simpara>The injected model objects in the examples above are always proxies to the actual model since method invocations on these objects need to trigger additional logic for updating the UI. Special care needs to be taken in case a model object should be replaced.</simpara>
<simpara>When working with an <literal><phrase role="code">@AutoBound DataBinder</phrase></literal>, simply calling <literal><phrase role="code">setModel()</phrase></literal> on the <literal><phrase role="code">DataBinder</phrase></literal> will be enough to replace the underlying model instance. However, when working with <literal><phrase role="code">@Model</phrase></literal> the instance cannot be replaced directly. Errai provides a special method level annotation <literal><phrase role="code">@ModelSetter</phrase></literal> that will allow replacing the model instance. Here&#8217;s an example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Dependent
public class CustomerView {
  @Inject @Model
  private Customer customer;

  @Inject @Bound
  private HTMLInputElement name;

  @Bound
  private HTMLLabelElement id = (HTMLLabelElement) document.createElement("label");

  @ModelSetter
  public void setModel(Customer customer) {
    this.customer = customer;
  }
}</programlisting>
<simpara>The <literal><phrase role="code">@ModelSetter</phrase></literal> method is required to have a single parameter. The parameter type needs to correspond to the type of the managed model.</simpara>
</section>
</section>
<section id="sid-51282340_DataBinding-Beanvalidation">
<title>Bean validation</title>
<simpara>Java bean validation (JSR 303) provides a declarative programming model for validating entities. More details and examples can be found <ulink url="http://docs.jboss.org/hibernate/validator/4.3/reference/en-US/html_single/">here</ulink>. Errai provides a bean validation module that makes <literal><phrase role="code">Validator</phrase></literal> instances injectable and work well with Errai&#8217;s data binding module. The following line needs to be added to the GWT module descriptor to inherit Errai&#8217;s bean validation module:</simpara>
<example>
<title>App.gwt.xml</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;inherits name="org.jboss.errai.validation.Validation" /&gt;

&lt;inherits name="org.hibernate.validator.HibernateValidator" /&gt;</programlisting>
</example>
<simpara>To use Errai&#8217;s bean validation module, you must add the module, the jakarta.validation API and an implementation such as hibernate validator to your classpath. If you are using Maven for your build, add these dependencies:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.errai&lt;/groupId&gt;
      &lt;artifactId&gt;errai-validation&lt;/artifactId&gt;
      &lt;version&gt;${errai.version}&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;javax.validation&lt;/groupId&gt;
      &lt;artifactId&gt;validation-api&lt;/artifactId&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;javax.validation&lt;/groupId&gt;
      &lt;artifactId&gt;validation-api&lt;/artifactId&gt;
      &lt;classifier&gt;sources&lt;/classifier&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;
      &lt;version&gt;4.2.0.Final&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;
      &lt;version&gt;4.2.0.Final&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
      &lt;classifier&gt;sources&lt;/classifier&gt;
    &lt;/dependency&gt;</programlisting>
<simpara>Now it is as simple as injecting a <literal><phrase role="code">Validator</phrase></literal> instance into an <link linkend="sid-5931402">Errai IOC</link> managed bean and calling the <literal><phrase role="code">validate</phrase></literal> method.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Inject
private Validator validator;</programlisting>
<programlisting language="java" linenumbering="unnumbered">Set&lt;ConstraintViolation&lt;Customer&gt;&gt; violations  = validator.validate(customer);
// display violations</programlisting>
<section id="sid-51282340_DataBinding-ExcludingClassesfromValidation">
<title>Excluding Classes from Validation</title>
<simpara>By default, Errai scans the entire classpath for classes with constraints. But sometimes it is necessary or desirable to exclude some shared classes from being validated on the client side. This can be done by adding a list of classes and package masks to the ErraiApp.properties file like so:</simpara>
<programlisting language="ini" linenumbering="unnumbered"># The following denylists the class some.fully.qualified.ClassName and all classes
# in some.package.mask (and subpackages thereof).
errai.validation.denylist = some.fully.qualified.ClassName \
                             some.package.mask.*</programlisting>
</section>
</section>
</chapter>
<chapter id="sid-51806600">
<title>Errai UI</title>
<simpara>One of the primary complaints of GWT to date has been that it is difficult to use "pure HTML" when building and skinning components. Inevitably one must turn to Java-based configuration in order to finish the job. In contrast, Errai strives to remove the need for Java styling. HTML template files are placed in the project source tree and referenced from custom Errai UI components in Java. Since Errai UI depends on Errai IOC and Errai CDI, dependency injection is supported in all custom components. Errai UI provides rapid prototyping and HTML5 templating for GWT.</simpara>
<section id="sid-51806600_ErraiUI-Getstarted">
<title>Get started</title>
<simpara>The Errai UI module is directly integrated with <link linkend="sid-51282340">Data Binding</link> and Errai JPA but can also be used as a standalone project in any GWT client application by simply inheriting the Errai UI GWT module, and ensuring that you have properly using <link linkend="sid-19398999">Errai CDI&#8217;s @Inject</link> to instantiate your components:</simpara>
<note id="sid-51806600_ErraiUI-WorkingDemo">
<title>Manual Setup</title>
<simpara>Checkout the <link linkend="Manual-Setup-Section">Manual Setup Section</link> for instructions on how to manually add Errai UI to your project. If you work better by playing with a finished product, you can see a simple client-server project <ulink url="https://github.com/errai/summit-demo-2013">implemented using Errai UI here</ulink>.</simpara>
</note>
<warning>
<title>Widget-based Components</title>
<simpara>Since Errai 4.0, Errai UI components are no longer required to extend <literal><phrase role="code">Composite</phrase></literal>. In fact, extending <literal><phrase role="code">Composite</phrase></literal> is deprecated.
Though components can still be built with and as widgets, we encourage users to build components using purely native HTML elements.</simpara>
</warning>
</section>
<section id="_use_errai_ui_components">
<title>Use Errai UI Components</title>
<section id="_parts_of_an_errai_ui_component">
<title>Parts of an Errai UI component</title>
<simpara>An Errai UI component consists of a Java class (the <emphasis>templated bean</emphasis>), an HTML file (the <emphasis>template</emphasis>), and an optional CSS file (the <emphasis>template stylesheet</emphasis>).
The template and template stylesheet describe the look of your component. The templated bean uses the <literal>@org.jboss.errai.ui.shared.api.annotations.DataField</literal> annotation
to declare mappings between fields in the templated bean and elements in the template.</simpara>
</section>
</section>
<section id="_creating_a_component">
<title>Creating a component</title>
<simpara>As previously mentioned, Errai UI components are built from a Java class (the <emphasis>templated bean</emphasis>), an HTML file (the <emphasis>template</emphasis>),
and an optional CSS file (the <emphasis>template stylesheet</emphasis>). A Java class is a templated bean if the class is annotated with <literal>@Templated</literal>.</simpara>
<section id="_basic_templated_bean">
<title>Basic templated bean</title>
<simpara>Here is a basic templated bean with no Java fields mapped to UI elements.</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>LoginForm.java</simpara>
      
<programlisting language="java" linenumbering="unnumbered">@Templated
public class LoginForm implements IsElement {
}</programlisting>

      
    </listitem>
  
</itemizedlist>

<simpara>Annotating the type with <literal>@Templated</literal> and no argument declares that this bean should have a template file <literal>LoginForm.html</literal>
and optionally a stylesheet <literal>LoginForm.css</literal> in the same package as <literal>LoginForm.java</literal>.</simpara>
<note>
<title>Optionally implement IsElement for easy access to the component root</title>
<simpara>Implementing <literal>org.jboss.errai.ui.client.local.api.elemental2.IsElement</literal> is optional, but we will use it in all of our examples. The interface contains a single default method, <literal>getElement</literal>, that returns the root element of the template, allowing us to programmatically attach a component to the DOM. Later on we will discuss alternative methods of accessing a component&#8217;s root element.</simpara>
</note>
</section>
<section id="_custom_template_names">
<title>Custom template names</title>
<simpara>When no argument is provided to <literal>@Templated</literal>, Errai UI looks in the current package for a template file having
the simple class name of the templated bean, suffixed with <literal>.html</literal>.
But <literal>@Templated</literal> accepts an argument to define an alternatively named or located template, as in the proceeding example.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated("my-template.html")
public class LoginForm implements IsElement {
   /* Looks for my-template.html in LoginForm's package */
}</programlisting>
<simpara>Fully qualified template paths are also supported, but must begin with a leading <emphasis>/</emphasis>:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated("/org/example/my-template.html")
public class LoginForm implements IsElement {
   /* Looks for my-template.html in package org.example */
}</programlisting>
</section>
<section id="_template_providers">
<title>Template providers</title>
<simpara>The previous examples specify template files at compile time, but it is possible to use templates provided at runtime using a <literal>TemplateProvider</literal>. These providers run asynchronously so that it is possible to fetch templates via HTTP requests. In fact Errai UI contains an implementation, <literal>ServerTemplateProvider</literal>, that fetches templates using the <literal>@Templated</literal> value as a url.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated(value="home.html", provider=ServerTemplateProvider.class)
public class LoginForm implements IsElement {
  /* Makes an HTTP request for the relative path "home.html" */
}</programlisting>
<simpara>Custom implementations can also be used.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated(provider=MyTemplateProvider.class)
public class LoginForm implements IsElement {
  /* Makes an HTTP request for the relative path "home.html" */
}

@Dependent
public class MyTemplateProvider implements TemplateProvider {

  @Override
  public void provideTemplate(String location, TemplateRenderingCallback renderingCallback) {
    String template;

    /*
     * Generate the template String.
     * Note: The location parameter is the value from the @Templated annotation.
     */

    renderingCallback.renderTemplate(template);
  }
}</programlisting>
</section>
</section>
<section id="sid-51806600_ErraiUI-CreateanHTMLtemplate">
<title>Create an HTML template</title>
<simpara>Templates in Errai UI may be designed either as an HTML snippet or as a full HTML document. You can even take an existing HTML page and use it as a template. With either approach, the <literal><phrase role="code">id</phrase></literal>, <literal><phrase role="code">class</phrase></literal>, and <literal><phrase role="code">data-field</phrase></literal> attributes in the template identify elements by name. These elements and their children are used in the component to add behavior, and use additional components to add functionality to the template. There is no limit to how many templated beans may share a given HTML template.</simpara>
<section id="_using_an_html_fragment_as_a_template">
<title>Using an HTML fragment as a template</title>
<simpara>Here is a simple HTML fragment for a login form to accompany our <literal><phrase role="code">@Templated LoginForm</phrase></literal> bean.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;form&gt;
  &lt;legend&gt;Log in to your account&lt;/legend&gt;

  &lt;label for="username"&gt;Username&lt;/label&gt;
  &lt;input id="username" type="text" placeholder="Username"&gt;

  &lt;label for="password"&gt;Password&lt;/label&gt;
  &lt;input id="password" type="password" placeholder="Password"&gt;

  &lt;button&gt;Log in&lt;/button&gt;
  &lt;button&gt;Cancel&lt;/button&gt;
&lt;/form&gt;</programlisting>
<simpara>This fragment can be used with our previous <literal>@Templated LoginForm</literal> declaration as is.</simpara>
</section>
<section id="_select_a_fragment_from_a_larger_html_template">
<title>Select a fragment from a larger HTML template</title>
<simpara>You can also use a full HTML document that is more easily previewed during design. When doing this you must specify the location of the component&#8217;s root DOM Element within the template file using a <literal><phrase role="code">"data-field"</phrase></literal>, <literal><phrase role="code">id</phrase></literal>, or <literal><phrase role="code">class</phrase></literal> attribute matching the value of the @Templated annotation. There is no limit to how many templated beans may share a single HTML template.</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>LoginForm.java</simpara>
      
<programlisting language="java" linenumbering="unnumbered">@Templated("my-template.html#login-form")
public class LoginForm implements IsElement {
   /* Specifies that &lt;... id="login-form"&gt; be used as the root Element of this component */
}</programlisting>

      
    </listitem>
  
    <listitem>
      <simpara>my-template.html</simpara>
      
<programlisting language="xml" linenumbering="unnumbered">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;title&gt;A full HTML document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;
        &lt;form id="login-form"&gt; # <co id="CO3-1"/>
          &lt;legend&gt;Log in to your account&lt;/legend&gt;

          &lt;label for="username"&gt;Username&lt;/label&gt;
          &lt;input id="username" type="text" placeholder="Username"&gt;

          &lt;label for="username"&gt;Password&lt;/label&gt;
          &lt;input id="password" type="password" placeholder="Password"&gt;

          &lt;button&gt;Log in&lt;/button&gt;
          &lt;button&gt;Cancel&lt;/button&gt;
        &lt;/form&gt;
    &lt;/div&gt;

    &lt;hr&gt;
    &lt;footer id="theme-footer"&gt;
        &lt;p&gt;(c) Company 2012&lt;/p&gt;
    &lt;/footer&gt;
&lt;/body&gt;
&lt;/html&gt;</programlisting>
<calloutlist>
  
  <callout arearefs="CO3-1">
    <para>The HTML <literal><phrase role="code">id</phrase></literal> value of this form Element matches the <literal>#login-from</literal> part from the <literal>@Templated("my-template.html#login-from")</literal> declaration.
That means that this element will be used as the root of the component defined by <literal>LoginForm.java</literal>. Note that we could also have used
<literal>class="login-form"</literal> or <literal>data-field="login-form"</literal> to the same effect.</para>
    
  </callout>
  
</calloutlist>

      
    </listitem>
  
</itemizedlist>

<simpara>Multiple components may use the same template, specifying any elements as a their root elements.
In particular, note that two or more components may declare the same DOM element of this template file as their root elements;
there is no conflict because are each components instantiated with a unique copy of the template DOM rooted at the specified element at runtime
(or from the root element if a fragment is not specified.)</simpara>
<simpara>For example, the component below also uses the same template file by referencing the template name, and specifying a fragment.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated("my-template.html#theme-footer")
public class Footer implements IsElement {
   /* Specifies that &lt;... id="theme-footer"&gt; be used as the root Element of this Widget */
}</programlisting>
</section>
<section id="_using_a_single_component_instance">
<title>Using a single component instance</title>
<simpara>As with most other features of Errai, dependency injection with CDI is the programming model of choice, so when interacting with components defined using Errai UI,
you should always <literal><phrase role="code">@Inject</phrase></literal> references to your components.</simpara>
<simpara>In this example we use a single Errai UI component by injecting it and adding it to the DOM using Errai&#8217;s DOM wrappers.</simpara>
<programlisting language="java" linenumbering="unnumbered">@EntryPoint
public class Application {
   @Inject
   private Document document; <co id="CO4-1"/>

   @Inject
   private TemplatedBean component;

   @PostConstruct
   public void init() {
     document.getBody().appendChild(component.getElement()); <co id="CO4-2"/>
   }
}</programlisting>
<calloutlist>
  
  <callout arearefs="CO4-1">
    <para><literal>org.jboss.errai.common.client.dom.Document</literal> is a thin wrapper around the DOM document provided by Errai. More on this later.</para>
    
  </callout>
  
  <callout arearefs="CO4-2">
    <para>This line assumes that <literal>TemplatedBean</literal> implements <literal>org.jboss.errai.ui.client.local.api.elemental2.IsElement</literal>. The default implementation of <literal>IsElement.getElement</literal> returns the root element of the component as an Errai DOM wrapper, which is compatible with the injected <literal>Document</literal>.</para>
    
  </callout>
  
</calloutlist>
</section>
<section id="_using_multiple_instances_for_iteration">
<title>Using multiple instances (for iteration)</title>
<simpara>In some cases you may need to display multiple instances of a component.
Here we create and add many components to the DOM using an injected <literal><phrase role="code">org.jboss.errai.ioc.client.api.ManagedInstance&lt;T&gt;</phrase></literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">import static elemental2.dom.DomGlobal.document;

@EntryPoint
public class Application {
   private String[] colors = new String[]{"Blue", "Yellow", "Red"};

   @Inject
   private ManagedInstance&lt;ColorComponent&gt; provider;

   @Inject
   private Document document;

   @PostConstruct
   public void init() {
      for(String color: colors) {
        ColorComponent component = provider.get(); <co id="CO5-1"/>
        component.setColor(c);
        document.appendChild(component.getElement()); <co id="CO5-2"/>
      }
   }
}</programlisting>
<calloutlist>
  
  <callout arearefs="CO5-1 CO5-2">
    <para>Again, we assume <literal>ColorComponent</literal> implements <literal>org.jboss.errai.ui.client.local.api.elemental2.IsElement</literal>, where <literal>getElement</literal> is defined.</para>
    
  </callout>
  
</calloutlist>
</section>
</section>
<section id="_adding_behaviour_to_your_components">
<title>Adding behaviour to your components</title>
<simpara>Now that we know how to create a <literal>@Templated</literal> bean and an HTML template, we can start wiring in functionality and behavior;
this is done by annotating fields and methods to replace specific sub-elements of the template DOM.
We can even replace portions of the template with other Errai UI components!</simpara>
<section id="_annotate_elements_in_the_template_with_datafield">
<title>Annotate Elements in the template with @DataField</title>
<simpara>In order to substitute elements into the template DOM you must annotate fields in your templated bean with <literal>@DataField</literal>
and mark the HTML template element with a correspondingly named <literal><phrase role="code">data-field</phrase></literal>, <literal><phrase role="code">id</phrase></literal>, or <literal><phrase role="code">class</phrase></literal> attribute.
All replacements happen while the component is being constructed; thus, fields annotated with <literal>@DataField</literal> must either be <literal><phrase role="code">@Inject</phrase></literal>ed
or manually initialized when the templated bean is instantiated.</simpara>
<note>
<title>Uses Elemental 2 API</title>
<simpara>The <literal>@DataField</literal> types used in this example are provided by Elemental 2 in the <literal>elemental2.dom</literal> package. Using Errai DOM wrappers found in the <literal>org.jboss.errai.common.client.dom</literal> package of errai-common or widgets in a <literal>@DataField</literal> is still possible, but this approach is not recommended.</simpara>
</note>
<programlisting language="java" linenumbering="unnumbered">/*
* Here the template file is implicitly LoginForm.html.
* The root element has id, class, or data-field "form".
*/
@Dependent
@Templated("#form")
public class LoginForm implements IsElement {
   // This is the root element of the template, for adding this component to the DOM.
   @Inject
   @DataField
   private HTMLFormElement form;

   // If not otherwise specified, the name to match in the HTML template defaults
   // to the name of the field; in this case, the name would be "username"
   @Inject
   @DataField
   private HTMLInputElement username;

   // The name to reference in the template can also be specified manually
   @Inject
   @DataField("pass")
   private HTMLInputElement password;

   // We can also choose to instantiate our own data fields. Injection is not required.
   @DataField
   private HTMLButtonElement submit = (HTMLButtonElement) document.createElement("button");

   @PostConstruct
   public void init() {
       password.type = "password";
   }
}</programlisting>
<note>
<simpara>Field, method, and constructor injection are all supported by @DataField.</simpara>
</note>
</section>
<section id="_allowed_datafield_types">
<title>Allowed DataField types</title>
<simpara>The previous <literal><phrase role="code">LoginForm</phrase></literal> example uses HTML wrapper elements from Elemental 2, but there are other types that can be used as <literal><phrase role="code">@DataFields</phrase></literal>.
Here is a full list:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>Any native <literal><phrase role="code">@JsType</phrase></literal> that is a wrapper for a DOM element (including those provided in errai-common). (<emphasis>This approach is no longer recommended!</emphasis>).</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Any Errai UI component.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Any <literal><phrase role="code">com.google.gwt.dom.client.Element</phrase></literal> type. (<emphasis>This approach is no longer recommended!</emphasis>).</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Any type implementing <literal><phrase role="code">org.jboss.errai.common.client.api.IsElement</phrase></literal>. (<emphasis>This approach is no longer recommended!</emphasis>).</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Any type implementing <literal><phrase role="code">org.jboss.errai.common.client.api.elemental2.IsElement</phrase></literal>.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Any <literal><phrase role="code">com.google.gwt.user.client.ui.Widget</phrase></literal> type. (<emphasis>This approach is no longer recommended!</emphasis>).</simpara>
      
    </listitem>
  
</orderedlist>
</section>
<section id="_accessing_the_root_element_of_a_component">
<title>Accessing the root element of a component</title>
<simpara>When programmatically adding components to the DOM, it is necessary to access their HTMLElement roots. Errai UI provides two ways of doing this.</simpara>
<section id="_inject_the_root_element_as_a_datafield">
<title>Inject the root element as a DataField</title>
<simpara>Errai UI supports injecting any element in a template html file as a DataField in the templated bean, including the root element. Below is a simple example.</simpara>
<section id="_mybean_html">
<title>MyBean.html</title>
<programlisting language="html" linenumbering="unnumbered">&lt;div class="root"&gt;
  &lt;h1&gt;Hello World!&lt;/h1&gt;
&lt;/div&gt;</programlisting>
</section>
<section id="_mybean_java">
<title>MyBean.java</title>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class MyBean {
  @Inject @DataField HTMLDivElement root;
}</programlisting>
<simpara>This method has the advantage that any valid @DataField type can be used (for example, you can expose your root element as a <literal>com.google.gwt.dom.client.Element</literal> or your own handwritten <literal>@JsType</literal> element wrapper).</simpara>
</section>
</section>
<section id="_implement_org_jboss_errai_ui_client_local_api_elemental2_iselement">
<title>Implement org.jboss.errai.ui.client.local.api.elemental2.IsElement</title>
<simpara>The interface <literal><phrase role="code">org.jboss.errai.common.client.api.elemental2.IsElement</phrase></literal> is analogous to <literal>IsWidget</literal>. It declares a single method <literal>getElement</literal> for accessing a type that is a UI component with a root element.</simpara>
<simpara>The interface <literal><phrase role="code">org.jboss.errai.ui.client.local.api.elemental2.IsElement</phrase></literal> provides a default implementation of <literal><phrase role="code">org.jboss.errai.common.client.api.elemental2.IsElement</phrase></literal> that works for any templated bean. For example:</simpara>
<note>
<simpara>Although using <literal><phrase role="code">org.jboss.errai.ui.client.local.api.elemental2.IsElement</phrase></literal> is the recomended approach, <literal><phrase role="code">org.jboss.errai.ui.client.local.api.IsElement</phrase></literal> is still supported.</simpara>
</note>
<section id="_mybean_html_2">
<title>MyBean.html</title>
<programlisting language="html" linenumbering="unnumbered">&lt;div class="root"&gt;
  &lt;h1&gt;Hello World!&lt;/h1&gt;
&lt;/div&gt;</programlisting>
</section>
<section id="_mybean_java_2">
<title>MyBean.java</title>
<programlisting language="java" linenumbering="unnumbered">import org.jboss.errai.ui.client.local.api.elemental2.IsElement;

@Templated
public class MyBean implements IsElement {
}</programlisting>
</section>
<section id="_usage">
<title>Usage</title>
<programlisting language="java" linenumbering="unnumbered">@EntryPoint
public class Setup {
  @Inject MyBean component;

  @PostConstruct
  public void attachBean() {
    // The default implementation automatically returns
    // the correct root element.
    HTMLElement rootElement = component.getElement();
    document.body.appendChild(rootElement);
  }
}</programlisting>
<note>
<simpara>The <literal>getElement</literal> call in the usage above returns the element as the <literal><phrase role="code">org.jboss.errai.common.client.dom.HTMLElement</phrase></literal> type from errai-common.</simpara>
</note>
</section>
</section>
</section>
<section id="_using_jstype_element_wrappers">
<title>Using JsType element wrappers</title>
<warning>
<title>Jsinterop ahead</title>
<simpara>This section assumes basic familiarity with JS interop in GWT 2.8+.</simpara>
</warning>
<simpara>Since 4.0, Errai UI supports working with JS interop wrappers of DOM elements.
Additionally, Errai provides a concise way of allowing your custom JS interop wrappers to be injected into components.</simpara>
<section id="_loginform_with_a_jsinterop_element">
<title>LoginForm with a jsinterop element</title>
<simpara>Let&#8217;s redo our previous login form, but with a new, custom JS interop form element as the root. First we need our element wrapper.</simpara>
<programlisting language="java" linenumbering="unnumbered">@JsType(isNative = true)
@Element("form")
public interface NativeForm {
  // Element methods and properties go here
}</programlisting>
<simpara>Here we have a defined a JS interop interface that will be backed by a FormElement javascript object at runtime.
The <literal><phrase role="code">org.jboss.errai.ui.shared.api.annotation.Element</phrase></literal> annotation declares this type as injectable with Errai IOC;
at the container will call <literal>document.createElement("form")</literal> in javascript to satisfy injection sites for this type.</simpara>
<simpara>Once you&#8217;ve defined your element wrapper, using it as a <literal><phrase role="code">@DataField</phrase></literal> works exactly as in previous examples.</simpara>
<programlisting language="java" linenumbering="unnumbered">/*
* Like the component from the previous example, but with a custom element wrapper as its root.
*/
@Templated("#form")
public class LoginForm {

   // Now the root element is our custom JsType
   @Inject
   @DataField
   private NativeForm form;

   @Inject
   @DataField
   private HTMLInputElement username;

   @Inject
   @DataField("pass")
   private HTMLInputElement password;

   @DataField
   private HTMLButtonElement submit = (HTMLButtonElement) document.createElement("button");

   @PostConstruct
   public void init() {
      password.type = "password";
   }
}</programlisting>
</section>
</section>
<section id="_injecting_jstypes_and_elements_that_have_multiple_tag_names">
<title>Injecting JsTypes and Elements that have multiple tag names</title>
<simpara>In our previous examples injecting <literal><phrase role="code">Elements</phrase></literal> or native <literal><phrase role="code">JsTypes</phrase></literal>, we did so with types that had a single possible tag name.
But consider the heading tags (h1, h2, &#8230;, h6). In Elemental 2, these are all represented by <literal><phrase role="code">HTMLHeadingElement</phrase></literal>. In gwt-user and errai-common these are all represented by <literal><phrase role="code">HeadingElement</phrase></literal>.
We might also wish to make our own <literal><phrase role="code">@JsType</phrase></literal> wrapper to represent these tags:</simpara>
<programlisting language="java" linenumbering="unnumbered">@JsType(isNative = true)
@Element({ "h1", "h2", "h3", "h4", "h5", "h6" })
public interface NativeHeading {
  // Heading element methods and properties go here
}</programlisting>
<simpara>With the above definition, injecting a <literal>NativeHeading</literal> is ambiguous. Fortunately for both <literal><phrase role="code">Elements</phrase></literal> and native <literal><phrase role="code">JsTypes</phrase></literal> we can use the
<literal><phrase role="code">javax.inject.Named</phrase></literal> annotation to remove this ambgiuity by specifying a tag name at a injection site.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class Component {
  // Injects a Elemental 2 HTMLHeadingElement with tag name "h1"
  @Inject
  @Named("h1")
  @DataField
  private HTMLHeadingElement h1;

  // Injects a gwt-user HeadingElement with tag name "h2"
  @Inject
  @Named("h2")
  @DataField
  private HeadingElement h2;

  // Injects a NativeHeading wrapper for an "h6" element
  @Inject
  @Named("h6")
  @DataField
  private NativeHeading h6;
}</programlisting>
</section>
<section id="sid-51806600_ErraiUI-AddcorrespondingattributestotheHTMLtemplate">
<title>Add corresponding attributes to the HTML template</title>
<simpara>Each <literal>@DataField</literal> reference in the Java class must match an element in the HTML template. The matching of Java references to HTML elements is performed as follows:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>A <emphasis>name</emphasis> for the Java reference is determined. If the <literal><phrase role="code">@DataField</phrase></literal> annotation has a value argument, that is used as the reference name. For fields, the default reference name is the field name. Method and constructor parameters have no default name, so they must always specify a value.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>If there is an element in the HTML template with attribute <literal><phrase role="code">data-field=name</phrase></literal>, the Java reference will point to this element. If there is more than one such element, the Java reference points to the first.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Otherwise, if there is an element in the HTML template with attribute <literal><phrase role="code">id=name</phrase></literal>, the Java reference will point to this element. If there is more than one such element, the Java reference points to the first.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Otherwise, if there is an element in the HTML template with a CSS style class <literal><phrase role="code">name</phrase></literal>, the Java reference will point to this element. If there is more than one such element, the Java reference points to the first. For elements with more than one CSS style, each style name is considered individually. For example:</simpara>
      
<programlisting language="java" linenumbering="unnumbered">   &lt;div class="eat drink be-merry"&gt;</programlisting>
<simpara>matches Java references named <literal><phrase role="code">eat</phrase></literal>, <literal><phrase role="code">drink</phrase></literal>, or <literal><phrase role="code">be-merry</phrase></literal>.</simpara>

      
    </listitem>
  
    <listitem>
      <simpara>If no matching element is found by this point, it is an error.</simpara>
      
    </listitem>
  
</orderedlist>
<simpara>If more than one Java reference matches the same HTML element in the template, it is an error. For example, given a template containing the element <literal><phrase role="code">&lt;div class="eat drink be-merry"&gt;</phrase></literal>, the following Java code is in error:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class ErroneousTemplate {
   @Inject @DataField
   private HTMLDivElement eat;

   @Inject @DataField
   private HTMLDivElement drink;
}</programlisting>
<simpara>because both fields <literal><phrase role="code">eat</phrase></literal> and <literal><phrase role="code">drink</phrase></literal> refer to the same HTML <literal><phrase role="code">div</phrase></literal> element.</simpara>
<simpara>So now we must ensure there are <literal><phrase role="code">data-field</phrase></literal>, <literal><phrase role="code">id</phrase></literal>, or <literal><phrase role="code">class</phrase></literal> attributes in the right places in our template HTML file. This, combined with the @DataField annotation in our component allows Errai UI to determine where and what should be composited when creating component instances.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;form id="form"&gt;
  &lt;legend&gt;Log in to your account&lt;/legend&gt;

  &lt;label for="username"&gt;Username&lt;/label&gt;
  &lt;input id="username" type="text" placeholder="Username"&gt;

  &lt;label for="password"&gt;Password&lt;/label&gt;
  &lt;input data-field="pass" id="password" type="password" placeholder="Password"&gt;

  &lt;button id="submit"&gt;Log in&lt;/button&gt;
  &lt;button&gt;Cancel&lt;/button&gt;
&lt;/form&gt;</programlisting>
<simpara>Now, when we run our application, we will be able to interact with these fields in our component.</simpara>
</section>
</section>
<section id="sid-51806600_ErraiUI-HowHTMLtemplatesaremergedwithComponents">
<title>How HTML templates are merged with Components</title>
<simpara>Three things are merged or modified when Errai UI creates a new component instance:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>By default, element attributes are merged from the template to the templated bean <literal>@DataFields</literal> (this behaviour can be configured with attributes of the <literal>@DataField</literal> annotation&#8201;&#8212;&#8201;see the javadoc for details).</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Template element inner text and inner HTML are preserved when the given <literal><phrase role="code">@DataField</phrase></literal> is a <literal><phrase role="code">Widget</phrase></literal> that implements <literal><phrase role="code">HasText</phrase></literal> or <literal><phrase role="code">HasHTML</phrase></literal>
or if it is a DOM element that has no children.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>If (2) is not applicable then child DOM Elements are merged from the templated bean <literal>@DataField</literal> to the template.</simpara>
      
    </listitem>
  
</orderedlist>
<section id="_example">
<title>Example</title>
<section id="_templated_bean">
<title>Templated bean:</title>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class StyledComponent implements IsElement {

    @Inject
    @DataField("field-1")
    private HTMLDivElement div;

    public StyledComponent() {
      div.style.setProperty("position", "fixed");
      div.style.setProperty("top", "0");
      div.style.setProperty("left", "0");
      this.getElement().id = "outer-id";
    }
}</programlisting>
</section>
<section id="_template">
<title>Template:</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;form&gt;
  &lt;span data-field="field-1" style="display:inline;"&gt; This element will become a div &lt;/span&gt;
&lt;/form&gt;

This text will be ignored.</programlisting>
</section>
<section id="_output_result">
<title>Output / result:</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;form id="outer-id"&gt;
   &lt;div data-field="field-1" style="display:inline;"&gt; This element will become a div &lt;/div&gt;
&lt;/form&gt;</programlisting>
<simpara>But why does the output look the way it does? Some things happened that may be unsettling at first,
but once you understand why these things occur you will find these mechanisms extremely powerful.</simpara>
</section>
</section>
<section id="_element_attributes_template_wins">
<title>Element attributes (template wins)</title>
<simpara>When styling your templates, you should keep in mind that, by default, all attributes defined in the template file will take precedence over any preset attributes in your <literal><phrase role="code">@DataFields</phrase></literal>.
This "attribute merge" occurs only when the components are instantiated; subsequent changes to any attributes after construction will function normally.
In the example we defined a component that applied several styles to a child Widget in its constructor, but we can see from the output that the styles from the template have overridden them.</simpara>
<simpara>If styles must be applied in Java instead of in the template, there are two options:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>Programmatically update the component in a <literal>@PostConstruct</literal> method.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Change the attribute merging strategy with attributes of the <literal>@DataField</literal> annotation (see javadoc for details).</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
<section id="_dom_elements_templated_bean_field_wins">
<title>DOM Elements (templated bean field wins)</title>
<simpara>Element composition, however, functions inversely from the attribute merging default behaviour, and the <literal><phrase role="code">&lt;span&gt;</phrase></literal> defined in our template is actually replaced by the <literal><phrase role="code">&lt;div&gt;</phrase></literal>
because of the <literal>HTMLDivElement</literal> in our component field. This does not, however, change the behavior of the attribute merge - the new <literal><phrase role="code">&lt;div&gt;</phrase></literal> was still be rendered inline,
because we have specified this style in our template, and the template always wins in competition with attributes set programatically before composition occurs.
It is this rule that allows nesting of Errai UI components, since the markup of an Errai UI component <literal>A</literal> used as a <literal>@DataField</literal> in component <literal>B</literal> will override
the markup in the <literal>B</literal> template.
In short, whatever is inside the <literal><phrase role="code">@DataField</phrase></literal> in your class will replace the children of the corresponding element in your template.</simpara>
</section>
<section id="_inner_text_and_inner_html_preserved_when_component_implements_hastext_or_hashtml">
<title>Inner text and inner HTML (preserved when component implements HasText or HasHTML)</title>
<simpara>Additionally, because <literal><phrase role="code">HTMLDivElement</phrase></literal> is a thin Element wrapper, the contents of the &lt;span&gt; "field-1" Element in the template were preserved;
however, this would not have been the case if the <literal><phrase role="code">@DataField</phrase></literal> specified for the element was not an element wrapper (for example if it was another Errai UI component).
In short, if you wish to preserve text or HTML contents of an element in your template, you can do one of two things: do not composite that Element with a <literal><phrase role="code">@DataField</phrase></literal> reference,
or ensure that the UI component being composited implements is a a DOM element with no children.</simpara>
</section>
</section>
<section id="_event_handlers">
<title>Event handlers</title>
<simpara>Dealing with User and DOM Events is a reality in rich web development, and Errai UI provides several approaches for dealing with all types of browser events using its "quick handler" functionality. It is possible to handle:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>JS interop Elemental 2 or wrapped DOM events on Widgets and Elements</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>GWT events on Widgets (Deprecated)</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>GWT events on DOM Elements (Deprecated)</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Native DOM events on Elements (Deprecated)</simpara>
      
    </listitem>
  
</orderedlist>
<important>
<simpara>It is not possible to handle Native DOM events on Widgets because GWT overrides native event handlers when Widgets are added to the DOM. You must programatically configure such handlers after the Widget has been added to the DOM.</simpara>
</important>
<section id="sid-51806600_ErraiUI-Concepts">
<title>Concepts</title>
<simpara>Each of the scenarios mentioned above use the same basic programming model for event handling: Errai UI wires methods annotated with <literal><phrase role="code">@EventHandler("my-data-field")</phrase></literal> (<emphasis>event handler methods</emphasis>) to handle events on the corresponding <literal><phrase role="code">@DataField("my-data-field")</phrase></literal> in the same component. Event handler methods annotated with a bare <literal><phrase role="code">@EventHandler</phrase></literal> annotation (no annotation parameter) are wired to receive events on the @Templated component itself.</simpara>
<simpara>A JS interop wrapped event is a type annotated with <literal>@JsType(isNative=true)</literal> and <literal>@BrowserEvent</literal> and provides an interface to the API of a browser DOM event.</simpara>
</section>
<section id="sid-51806600_ErraiUI-GWTeventsonWidgets">
<title>JS Interop wrapped events on Elements and Widgets</title>
<simpara>This approach can be used to handle events on any kind of <literal>@DataField</literal> or on a <literal>data-field</literal> element in the HTML template.  Since many browser event types share interfaces a quick handler with a JS interop event parameter must sometimes specify the browser event type (i.e. "click", "blur", "focus", etc.).</simpara>
<simpara>Here is an example of a quick handler for "click" events on an element <literal>@DataField</literal> where the <literal>Event</literal> parameter is a JS interop wrapped event type <literal>org.jboss.errai.common.client.dom.Event</literal>. The <literal>Event</literal> interfaces is annotated with <literal>@BrowserEvent</literal>, but does not specify a value of usable browser event types, so the quick handler must specify the event type is listens to with the <literal>@ForEvent</literal> annotation.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class ElementHandlerComponent {

   @Inject
   @DataField("b1")
   private HTMLButtonElement button;

   @EventHandler("b1")
   public void doSomething(@ForEvent("click") Event e) {
     // do something
   }
}</programlisting>
<simpara>For <literal>@BrowserEvent</literal> wrappers that specify event types, <literal>@ForEvent</literal> may be omitted. In this case the quick handler is registered for all supported event types. In the example below, <literal>FocusEvent</literal> is annotated with <literal>@BrowserEvent({"blur", "focus", "focusin", "focusout"})</literal>, so the quick handler is registered for all four event: blur, focus, focusin, and focusout.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class ElementHandlerComponent {

   @Inject
   @DataField
   private HTMLAnchorElement link;

   @EventHandler("link")
   public void doSomething(FocusEvent e) {
     // do something
   }
}</programlisting>
<simpara>This approach can also be used with GWT Widget <literal>@DataFields</literal> and template <literal>data-fields</literal> that do not have a <literal>@DataField</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class WidgetAndElementHandlerComponent {

   @Inject
   @DataField
   private HTMLInputElement input;

   // Handles focus-related events on the
   // underlying HTML element of the HTMLInputElement field.
   @EventHandler("input")
   public void doSomething(FocusEvent e) {
     // do something
   }

   // Handles dblclick events for the element in the
   // template with id/class/data-field="button".
   @EventHandler("button")
   public void onClick(@ForEvent("dblclick") MouseEvent e) {
     // do something
   }
}</programlisting>
</section>
<section id="_gwt_events_on_widgets">
<title>GWT events on Widgets</title>
<simpara>This approach handles GWT Event classes for Widgets that explicitly handle the given event type. If a Widget does not handle the Event type given in the <literal><phrase role="code">@EventHandler</phrase></literal> method&#8217;s signature, the application will fail to compile and appropriate errors will be displayed.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class WidgetHandlerComponent extends Composite {

   @Inject
   @DataField("b1")
   private Button button;

   @EventHandler("b1")
   public void doSomethingC1(ClickEvent e) {
     // do something
   }
}</programlisting>
</section>
<section id="sid-51806600_ErraiUI-GWTeventsonDOMElements">
<title>GWT events on DOM Elements</title>
<simpara>Errai UI also makes it possible to handle GWT events on native Elements which are specified as a <literal><phrase role="code">@DataField</phrase></literal> in the component class. This is useful when a full GWT Widget is not available for a given Element, or for GWT events that might not normally be available on a given Element type. This could occur, for instance, when clicking on a <literal><phrase role="code">&lt;div&gt;</phrase></literal>, which would normally not have the ability to receive the GWT <literal><phrase role="code">ClickEvent</phrase></literal>, and would otherwise require creating a custom DIV Widget to handle such an event.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class ElementHandlerComponent extends Composite {

   @DataField("div-1")
   private DivElement button = DOM.createDiv();

   @EventHandler("div-1")
   public void doSomethingC1(ClickEvent e) {
     // do something
   }
}</programlisting>
<note>
<title>Events with native JsTypes</title>
<simpara>As with previous features, the <literal><phrase role="code">DivElement</phrase></literal> above could be replaced with a native <literal><phrase role="code">JsType</phrase></literal> (for example, <literal>Div</literal> from errai-common).</simpara>
</note>
</section>
<section id="sid-51806600_ErraiUI-NativeDOMeventsonElements">
<title>Native DOM events on Elements</title>
<simpara>The last approach is handles the case where native DOM events must be handled, but no such GWT event handler exists for the given event type. Alternatively, it can also be used for situations where Elements in the template should receive events, but no handle to the Element the component class is necessary (aside from the event handling itself.) Native DOM events do not require a corresponding <literal><phrase role="code">@DataField</phrase></literal> be configured in the class; only the HTML <literal><phrase role="code">data-field</phrase></literal>, <literal><phrase role="code">id</phrase></literal>, or <literal><phrase role="code">class</phrase></literal> template attribute is required.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;div&gt;
   &lt;a id="link" href="/page"&gt;this is a hyperlink&lt;/a&gt;
   &lt;div data-field="div"&gt; Some content &lt;/div&gt;
&lt;/div&gt;</programlisting>
<simpara>The <literal><phrase role="code">@SinkNative</phrase></literal> annotation specifies (as a bit mask) which native events the method should handle; this sink behaves the same in Errai UI as it would with <literal><phrase role="code">DOM.sinkEvents(Element e, int bits)</phrase></literal>. Note that a <literal><phrase role="code">@DataField</phrase></literal> reference in the component class is optional.</simpara>
<important>
<simpara>Only one @EventHandler may be specified for a given template element when @SinkNative is used to handle native DOM events.</simpara>
</important>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class QuickHandlerComponent extends Composite {

  @DataField
  private AnchorElement link = DOM.createAnchor().cast();

  @EventHandler("link")
  @SinkNative(Event.ONCLICK | Event.ONMOUSEOVER)
  public void doSomething(Event e) {
    // do something
  }

  @EventHandler("div")
  @SinkNative(Event.ONMOUSEOVER)
  public void doSomethingElse(Event e) {
    // do something else
  }
}</programlisting>
</section>
</section>
<section id="_html_form_support">
<title>HTML Form Support</title>
<simpara>Using asynchronous Javascript calls often make realizing the benefits of modern browsers difficult when it comes to form submission. But there is now a base class in Errai UI for creating <literal>@Templated</literal> form widgets that are perfect for tasks such as creating a login form.</simpara>
<section id="_a_login_form_that_triggers_browsers_remember_password_feature">
<title>A Login Form that Triggers Browsers' "Remember Password" Feature</title>
<simpara>Here is a sample <literal>@Templated</literal> login form class. This form has:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>a <literal>username</literal> text field</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>a <literal>password</literal> field</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>a button that with a click handler that attempts to login asynchronously</simpara>
      
    </listitem>
  
</itemizedlist>

<programlisting language="java" linenumbering="unnumbered">@Dependent
@Templated
public class LoginForm extends AbstractForm { <co id="CO6-1"/>

  @Inject
  private Caller&lt;AuthenticationService&gt; authenticationServiceCaller;

  @Inject
  @DataField
  private TextBox username;

  @Inject
  @DataField
  private PasswordTextBox password;

  @DataField
  private final FormElement form = DOM.createForm(); <co id="CO6-2"/>

  @Inject
  @DataField
  private Button login; <co id="CO6-3"/>

  @Override
  protected FormElement getFormElement() {
    return form; <co id="CO6-4"/>
  }

  @EventHandler("login")
  private void loginClicked(ClickEvent event) {
    authenticationServiceCaller.call(new RemoteCallback&lt;User&gt;() {

      @Override
      public void callback(User response) {
        // Now that we're logged in, submit the form
        submit(); <co id="CO6-5"/>
      }
    }).login(username.getText(), password.getText());
  }

}</programlisting>
<simpara>The key things that you should take from this example:</simpara>
<calloutlist>
  
  <callout arearefs="CO6-1">
    <para>The class extends <literal>org.jboss.errai.ui.client.widget.AbstractForm</literal>.</para>
    
  </callout>
  
  <callout arearefs="CO6-2">
    <para>The <literal>form</literal> field is a <literal>@DataField</literal> but it is not injected.</para>
    
  </callout>
  
  <callout arearefs="CO6-3">
    <para>The login button is a regular button widget, with a click handling method below.</para>
    
  </callout>
  
  <callout arearefs="CO6-4">
    <para>The <literal>getFormElement</literal> method inherited from <literal>AbstractForm</literal> must return the <literal>FormElement</literal> that will be submitted.</para>
    
  </callout>
  
  <callout arearefs="CO6-5">
    <para>After the user has successfully logged in asynchronously we call <literal>submit()</literal>. This causes form submission to happen in a way that will not cause the page to refresh, but will still properly notify the browser of a form submission.</para>
    
  </callout>
  
</calloutlist>
<simpara>When a user successfully logs in via this example, the web browser should prompt them to remember the username and password (assuming this is a feature of the browser being used).</simpara>
</section>
<section id="_using_the_correct_elements_in_the_template">
<title>Using the Correct Elements in the Template</title>
<simpara>The most likely way to go wrong is to accidentally use the wrong types of elements in your template. It is very important that you use a proper <literal>from</literal> element with <literal>input</literal> elements <emphasis role="strong">with the exception of the submit button</emphasis>. Here is an html template that could accompany the <literal>LoginForm.java</literal> example above:</simpara>
<programlisting language="html" linenumbering="unnumbered">&lt;div&gt;
  &lt;form data-field="form"&gt;
    &lt;input type="text" name="username" data-field="username"&gt;
    &lt;input type="password" name="password" data-field="password"&gt;
    &lt;button data-field="login"&gt;Sign In&lt;/button&gt;
  &lt;/form&gt;
&lt;/div&gt;</programlisting>
<simpara>To reiterate, notice that the <literal>username</literal> and <literal>password</literal> fields are legitimate <literal>input</literal> elements. This is because we want these values to be submitted when <literal>AbstractForm.submit()</literal> is called (so that the browser notices them). However, we do not want there to be any way to submit the form other than calling <literal>AbstractForm.submit()</literal>, so the <literal>button</literal> element is notably missing the <literal>type="submit"</literal> attribute pair.</simpara>
</section>
</section>
<section id="sid-51806600_ErraiUI-DataBinding">
<title>Data Binding</title>
<simpara>A recurring implementation task in rich web development is writing event handler code for updating model objects to reflect input field changes in the user interface. The requirement to update user interface fields in response to changed model values is just as common. These tasks require a significant amount of boilerplate code which can be alleviated by Errai. Errai&#8217;s <link linkend="sid-51282340">data binding module</link> provides the ability to bind model objects to user interface fields, so they will automatically be kept in sync. While the module can be used on its own, it can cut even more boilerplate when used together with Errai UI.</simpara>
<simpara>In the following example, all <literal><phrase role="code">@DataFields</phrase></literal> annotated with <literal><phrase role="code">@Bound</phrase></literal> have their contents bound to properties of the data model (a <literal><phrase role="code">User</phrase></literal> object). The model object is injected and annotated with <literal><phrase role="code">@Model</phrase></literal>, which indicates automatic binding should be carried out. Alternatively, the model object could be provided by an injected <literal><phrase role="code">DataBinder</phrase></literal> instance annotated with <literal><phrase role="code">@AutoBound</phrase></literal>, see <link linkend="sid-51282340_DataBinding-DeclarativeBinding">Declarative Binding</link> for details.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class LoginForm {

   @Inject
   @Model
   private User user;

   @Inject
   @Bound
   @DataField
   private InputElement name;

   @Inject
   @Bound
   @DataField
   private PasswordTextBox password;

   @DataField
   private Button submit = new Button();
}</programlisting>
<simpara>Now the user object and the <literal><phrase role="code">username</phrase></literal> and <literal><phrase role="code">password</phrase></literal> fields in the UI are automatically kept in sync. No event handling code needs to be written to update the user object in response to input field changes and no code needs to be written to update the UI fields when the model object changes. So, with the above annotations in place, it will always be true that <literal><phrase role="code">user.getUsername().equals(username.getText())</phrase></literal> and <literal><phrase role="code">user.getPassword().equals(password.getText())</phrase></literal>.</simpara>
<section id="sid-51806600_ErraiUI-Default%2CSimple%2CandChainedPropertyBindings">
<title>Default, Simple, and Chained Property Bindings</title>
<simpara>By default, bindings are determined by matching field names to property names on the model object. In the example above, the field <literal><phrase role="code">name</phrase></literal> was automatically bound to the JavaBeans property <literal><phrase role="code">name</phrase></literal> of the model (<literal><phrase role="code">user</phrase></literal> object). If the field name does not match the model property name, you can use the <literal><phrase role="code">property</phrase></literal> attribute of the <literal><phrase role="code">@Bound</phrase></literal> annotation to specify the name of the property. The property can be a simple name (for example, "name") or a property chain (for example, <literal><phrase role="code">user.address.streetName</phrase></literal>). When binding to a property chain, all properties but the last in the chain must refer to @Bindable values.</simpara>
<simpara>The following example illustrates all three scenarios:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Bindable
public class Address {
  private String line1;
  private String line2;
  private String city;
  private String stateProv;
  private String country;

  // getters and setters
}

@Bindable
public class User {
  private String name;
  private String password;
  private Date dob;
  private Address address;
  private List&lt;Role&gt; roles;

  // getters and setters
}

@Templated
public class UserComponent {
  @Inject @AutoBound DataBinder&lt;User&gt; user;
  @Inject @Bound InputElement name;
  @Inject @Bound(property="dob") DatePicker dateOfBirth;
  @Inject @Bound(property="address.city") TextBox city;
}</programlisting>
<simpara>In <literal><phrase role="code">UserComponent</phrase></literal> above, the <literal><phrase role="code">name</phrase></literal> input element is bound to <literal><phrase role="code">user.name</phrase></literal> using the default name matching; the <literal><phrase role="code">dateOfBirth</phrase></literal> date picker is bound to <literal><phrase role="code">user.dob</phrase></literal> using a simple property name mapping; finally, the <literal><phrase role="code">city</phrase></literal> text box is bound to <literal><phrase role="code">user.address.city</phrase></literal> using a property chain. Note that the <literal><phrase role="code">Address</phrase></literal> class is required to be <literal><phrase role="code">@Bindable</phrase></literal> in this case.</simpara>
</section>
<section id="sid-51806600_ErraiUI-BindingofLists">
<title>Binding of Lists</title>
<simpara>Often you will need to bind a list of model objects so that every object in the list is bound to a corresponding component. This task can be accomplished using Errai UI&#8217;s <literal><phrase role="code">ListWidget</phrase></literal> class. Here&#8217;s an example of binding a list of users using the <literal><phrase role="code">UserComponent</phrase></literal> class from the previous example. First, we need to enhance <literal><phrase role="code">UserComponent</phrase></literal> to implement <literal><phrase role="code">HasModel</phrase></literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class UserWidget implements HasModel&lt;User&gt; {
  @Inject @AutoBound DataBinder&lt;User&gt; userBinder;
  @Inject @Bound InputElement name;
  @Inject @Bound(property="dob") DatePicker dateOfBirth;
  @Inject @Bound(property="address.city") TextBox city;

  public User getModel() {
    userBinder.getModel();
  }

  public void setModel(User user) {
    userBinder.setModel(user);
  }
}</programlisting>
<simpara>Now we can use <literal><phrase role="code">UserComponent</phrase></literal> to display items in a list.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class MyComponent {

  @Inject @DataField ListWidget&lt;User, UserComponent&gt; userListWidget;

  @PostConstruct
  public void init() {
    List&lt;User&gt; users = .....
    userListWidget.setItems(users);
  }
}</programlisting>
<simpara>Calling <literal><phrase role="code">setItems</phrase></literal> on the <literal><phrase role="code">userListWidget</phrase></literal> causes an instance of <literal><phrase role="code">UserComponent</phrase></literal> to be displayed for each user in the list. The <literal><phrase role="code">UserComponent</phrase></literal> is then bound to the corresponding user object. By default, the widgets are arranged in a vertical panel. However, <literal><phrase role="code">ListWidget</phrase></literal> can also be subclassed to provide alternative behaviour. In the following example, we use a horizontal panel to display the widgets.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class UserListWidget extends ListWidget&lt;User, UserWidget&gt; {

  public UserList() {
    super(new HorizontalPanel());
  }

  @PostConstruct
  public void init() {
    List&lt;User&gt; users = .....
    setItems(users);
  }

  @Override
  public Class&lt;UserWidget&gt; getItemWidgetType() {
    return UserWidget.class;
  }
}</programlisting>
<section id="sid-51806600_ErraiUI-Bindinglistswith@Bound">
<title>Binding lists with @Bound</title>
<simpara>An instance of <literal><phrase role="code">ListWidget</phrase></literal> can also participate in automatic bindings using <literal><phrase role="code">@Bound</phrase></literal>. In this case, <literal><phrase role="code">setItems</phrase></literal> never needs to be called manually. The bound list property and displayed items will automatically be kept in sync. In the example below a list of user roles is bound to a <literal><phrase role="code">ListWidget</phrase></literal> that displays and manages a <literal><phrase role="code">RoleWidget</phrase></literal> for each role in the list. Every change to the list returned by <literal><phrase role="code">user.getRoles()</phrase></literal> will now trigger a corresponding update in the UI.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class UserDetailView {

   @Inject
   @Bound
   @DataField
   private InputElement name;

   @Inject
   @Bound
   @DataField
   private PasswordTextBox password;

   @Inject
   @Bound
   @DataField
   private ListWidget&lt;Role, RoleWidget&gt; roles;

   @DataField
   private Button submit = new Button();

   @Inject @Model
   private User user;
}</programlisting>
</section>
</section>
<section id="sid-51806600_ErraiUI-DataConverters">
<title>Data Converters</title>
<simpara>The <literal><phrase role="code">@Bound</phrase></literal> annotation further allows to specify a converter to use for the binding (see <link linkend="sid-51282340_DataBinding-SpecifyingConverters">Specifying Converters</link> for details). This is how a binding specific converter can be specified on a data field:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Inject
@Bound(converter=MyDateConverter.class)
@DataField
private TextBox date;</programlisting>
<simpara>Errai&#8217;s <literal><phrase role="code">DataBinder</phrase></literal> also allows to register <literal><phrase role="code">PropertyChangeHandlers</phrase></literal> for the cases where keeping the model and UI in sync is not enough and additional logic needs to be executed (see <link linkend="sid-51282340_DataBinding-PropertyChangeHandlers">Property Change Handlers</link> for details).</simpara>
</section>
</section>
<section id="sid-51806600_ErraiUI-NestCompositecomponents">
<title>Nest components</title>
<simpara>Using components to build up a hierarchy of UI componenets functions exactly the same as when building hierarchies of GWT widgets or DOM elements. The only distinction might be that with Errai UI, <literal><phrase role="code">@Inject</phrase></literal> is preferred to manual instantiation.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class ComponentOne {

   @Inject
   @DataField("other-comp")
   private ComponentTwo two;
}</programlisting>
<note>
<simpara>This example works whether <literal><phrase role="code">ComponentTwo</phrase></literal> is a composite or non-composite component.</simpara>
</note>
</section>
<section id="sid-51806600_ErraiUI-ExtendCompositecomponents">
<title>Extend components</title>
<simpara>Templating would not be complete without the ability to inherit from parent templates, and Errai UI also makes this possible using simple Java inheritance. The only additional requirement is that components extending from a parent component must also be annotated with @Templated, and the path to the template file must also be specified in the child component&#8217;s annotation. Child components may specify <literal><phrase role="code">@DataField</phrase></literal> references that were omitted in the parent class, and they may also override <literal><phrase role="code">@DataField</phrase></literal> references (by using the same <literal><phrase role="code">data-field</phrase></literal> name) that were already specified in the parent component.</simpara>
<section id="_template_2">
<title>Template</title>
<simpara>Extension templating is particularly useful for creating reusable page layouts with some shared content (navigation menus, side-bars, footers, etc.) where certain sections will be filled with unique content for each page that extends from the base template; this is commonly seen when combined with the MVP design pattern traditionally used in GWT applications.</simpara>
<programlisting language="html" linenumbering="unnumbered">&lt;div class="container"&gt;
   &lt;div id="header"&gt; Default header &lt;/div&gt;
   &lt;div id="content"&gt; Default content &lt;/div&gt;
   &lt;div id="footer"&gt; Default footer &lt;/div&gt;
&lt;/div&gt;</programlisting>
</section>
<section id="sid-51806600_ErraiUI-Parentcomponent">
<title>Parent component</title>
<simpara>This component provides the common features of our page layout, including header and footer, but does not specify any content. The missing @DataField "content" will be provided by the individual page components extending from this parent component.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class PageLayout {

   @Inject
   @DataField
   private HeaderComponent header;

   @Inject
   @DataField
   private FooterComponent footer;

   @PostConstruct
   public final void init() {
      // do some setup
   }
}</programlisting>
</section>
<section id="sid-51806600_ErraiUI-Childcomponent">
<title>Child component</title>
<simpara>We are free to fill in the missing "content" @DataField with a component of our choosing. Note that it is not required to fill in all omitted @DataField references.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated("PageLayout.html")
public class LoginLayout extends PageLayout {

   @Inject
   @DataField
   private LoginForm content;

}</programlisting>
<simpara>We could also have chosen to override one or more <literal><phrase role="code">@DataField</phrase></literal> references defined in the parent component, simply by specifying a <literal><phrase role="code">@DataField</phrase></literal> with the same name in the child component, as is done with the "footer" data field below.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated("PageLayout.html")
public class LoginLayout extends PageLayout {

   @Inject
   @DataField
   private LoginForm content;

   /* Override footer defined in PageLayout */
   @Inject
   @DataField
   private CustomFooter footer;

}</programlisting>
<simpara>Be aware that templates shouldn&#8217;t all be <literal><phrase role="code">@Singleton</phrase></literal>. Singleton templates will be shared, so you can&#8217;t attach the same template component twice. Duplicated template components should be dependent-scoped, so several instances will be created when they are injected.</simpara>
</section>
</section>
<section id="sid-51806600_ErraiUI-Stylesheetbinding">
<title>Stylesheet binding</title>
<simpara>When developing moderately-complex web applications with Errai, you may find yourself needing to do quite a bit of programmatic style changes. One common case is showing or enabling controls only if a user has the necessary permissions to use them. One part of the problem is securing those features from being used, and the other part which is an important usability consideration is communicating that state to the user.</simpara>
<tip>
<title>RestrictedAccess in Errai Security</title>
<simpara>Errai Security contains a <literal>RestrictedAccess</literal> annotation that uses style sheet binding to implement a feature similar in nature to this example.</simpara>
</tip>
<simpara>Let&#8217;s start with the example case I just described. We have a control that we only want to be visible if the user is an admin. So the first thing we do is create a style binding annotation.</simpara>
<programlisting language="java" linenumbering="unnumbered">@StyleBinding
@Retention(RetentionPolicy.RUNTIME)
public @interface Admin {
}</programlisting>
<simpara>This defines <literal><phrase role="code">Admin</phrase></literal> as a stylebinding now we can use it like this:</simpara>
<programlisting language="java" linenumbering="unnumbered">@EntryPoint
@Templated
public class HelloWorldForm {
  @Inject @Admin @DataField ButtonElement deleteButton;
  @Inject SessionManager sessionManager;


  @EventHandler("deleteButton")
  private void handleSendClick(ClickEvent event) {
    // do some deleting!
  }

  @Admin
  private void applyAdminStyling(Style style) {
    if (!sessionManager.isAdmin()) {
      style.setVisibility(Style.Visibility.HIDDEN);
    }
  }
}</programlisting>
<simpara>Now before the form is shown to the user the <literal><phrase role="code">applyAdminStyling</phrase></literal> method will be executed where the <literal><phrase role="code">sessionManager</phrase></literal> is queried to see if the user is an admin if not the delete button that is also annotated with <literal><phrase role="code">@Admin</phrase></literal> will be hidden from the view.</simpara>
<simpara>The above example took at <literal>Style</literal> object as a parameter, but it is also possible to use an <literal>Element</literal>. So the <literal>applyAdminStyling</literal> method above could have also been written like this:</simpara>
<programlisting language="java" linenumbering="unnumbered">  @Admin
  private void applyAdminStyling(Element element) {
    if (!sessionManager.isAdmin()) {
      element.addClassName("disabled");
    }
  }</programlisting>
<simpara>The CSS class "disabled" could apply the same style as before ("visibility: hidden") or it could have more complex behaviour that is dependent on the element type.</simpara>
<section id="_usage_with_data_binding">
<title>Usage with Data Binding</title>
<simpara>In addition when using this in conjunction with Errai Databinding. Any Errai UI component which uses @AutoBound, will get live updating of the style rules for free, anytime the model changes. Allowing dynamic styling based on user input and other state changes.</simpara>
</section>
</section>
<section id="sid-51806600_ErraiUI-Internationalization%28i18n%29">
<title>Internationalization (i18n)</title>
<simpara>User interfaces often need to be available in different languages. Errai&#8217;s i18n support makes it easier for you to publish your web app in multiple languages. This section explains how to use this feature in your application.</simpara>
<section id="_html_template_translation">
<title>HTML Template Translation</title>
<simpara>To get started with Errai&#8217;s internationalization support, simply put <literal><phrase role="code">@Bundle("bundle.json")</phrase></literal> or <literal><phrase role="code">@Bundle("bundle.properties")</phrase></literal> annotation on your entry point and add an empty <literal><phrase role="code">bundle.json</phrase></literal> or <literal><phrase role="code">bundle.properties</phrase></literal> file to your classpath (e.g. to src/main/java or src/main/resources). Of course, you can name it differently provided the file extension is <literal>.json</literal> or <literal>.properties</literal>.</simpara>
<simpara>Errai will scan your HTML templates and process all text elements to generate key/value pairs for translation. It will generate a file called <literal><phrase role="code">errai-bundle-all.json</phrase></literal> and put it in your <literal><phrase role="code">.errai</phrase></literal> directory. If you used a JSON file in you <literal><phrase role="code">@Bundle</phrase></literal> annotation, you can copy this generated file and use it as a starting point for your custom translation bundles. If the text value is longer than 128 characters the key will get cut off and a hash appended at the end.</simpara>
<simpara>The translation bundle files use the same naming scheme as Java (e.g. <literal><phrase role="code">bundle_nl_BE.json</phrase></literal> or <literal><phrase role="code">bundel_nl_BE.properties</phrase></literal> for Belgian Dutch, and <literal><phrase role="code">bundle_nl.json</phrase></literal> or <literal><phrase role="code">bundle_nl.properties</phrase></literal> for plain Dutch). Errai will also generate a file called <literal><phrase role="code">errai-bundle-missing.json</phrase></literal> in the <literal><phrase role="code">.errai</phrase></literal> folder containing all template values for which no translations have been defined. You can copy the key/value pairs out of this file to create our own translations when you use a JSON file:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">{
"StoresPage.Stores!" : "Stores!",
"WelcomePage.As_you_move_toward_a_more_and_more_declarative_style,_you_allow_the_compiler_and_the_framework_to_catch_more_mistakes_up_front._-734987445" : "As you move toward a more and more declarative style, you allow the compiler and the framework to catch more mistakes up front. Broken links? A thing of the past!"
}</programlisting>
<simpara>Here are the same translations as specified by a properties file:</simpara>
<screen>StoresPage.Stores! = Stores!
WelcomePage.As_you_move_toward_a_more_and_more_declarative_style,_you_allow_the_compiler_and_the_framework_to_catch_more_mistakes_up_front._-734987445 = As you move toward a more and more declarative style, you allow the compiler and the framework to catch more mistakes up front. Broken links? A thing of the past!</screen>
<simpara>If you want to use your own keys instead of these generated ones you can specify them in your templates using the <literal><phrase role="code">data-i18n-key</phrase></literal> attribute:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;html&gt;
&lt;body&gt;
  &lt;div id="content"&gt;
  &lt;p data-i18n-key="welcome"&gt;Welcome to errai-ui i18n.&lt;/p&gt;
&lt;div&gt;
...</programlisting>
<simpara>By adding this attribute in the template you can translate it with the following:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">{
    "TemplatedClassName.welcome": "Willkommen bei Errai-ui i18n."
}</programlisting>
<simpara>or</simpara>
<screen>TemplatedClassName.welcome=Willkommen bei Errai-ui i18n.</screen>
<simpara>These keys are prefixed with the name of the <literal>@Templated</literal> class to which they belong, and as such will only applied to the element with <literal>data-i18n-key="welcome"</literal> in that classes template. You may also declare translations without the prefix that can apply to any template, like so:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">{
    "welcome": "Willkommen bei Errai-ui i18n."
}</programlisting>
<simpara>or</simpara>
<screen>welcome=Willkommen bei Errai-ui i18n.</screen>
<simpara>Either of these translations will apply to elements with <literal>data-i18n-key="welcome"</literal> in any template.</simpara>
<simpara>Because your templates are designer templates and can contain some mock data that doesn&#8217;t need to be translated, Errai has the ability to indicate that with an attribute <literal><phrase role="code">data-role=dummy</phrase></literal>:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;div id=navbar data-role=dummy&gt;
  &lt;div class="navbar navbar-fixed-top"&gt;
    &lt;div class=navbar-inner&gt;
      &lt;div class=container&gt;
        &lt;span class=brand&gt;Example Navbar&lt;/span&gt;
        &lt;ul class=nav&gt;
          &lt;li&gt;&lt;a&gt;Item&lt;/a&gt;
          &lt;li&gt;&lt;a&gt;Item&lt;/a&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</programlisting>
<simpara>Here the template fills out a navbar with dummy elements, useful for creating a design, adding <literal><phrase role="code">data-role=dummy</phrase></literal> will not only exclude it form being translated it will also strip the children nodes from the template that will be used by the application.</simpara>
<simpara>When you have setup a translation of your application Errai will look at the browser locale and select the locale, if it&#8217;s available, if not it will use the default (<literal><phrase role="code">bundle.json</phrase></literal>). If the users of your application need to be able to switch the language manually, Errai offers a pre build component you can easily add to your page: <literal><phrase role="code">LocaleListBox</phrase></literal> will render a Listbox with all available languages. If you want more control of what this language selector looks like there is also a <literal><phrase role="code">LocaleSelector</phrase></literal> that you can use to query and select the locale for example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class NavBar {

  @Inject
  private LocaleSelector selector;

  @Inject @DataField @OrderedList
  ListWidget&lt;Locale, LanguageItem&gt; language;

  @AfterInitialization
  public void buildLanguageList() {
    language.setItems(new ArrayList&lt;Locale&gt;(selector.getSupportedLocales()));
  }

...
// in LanguageItem we add a click handler on a link

  @Inject
  Navigation navigation;

  @Inject
  private LocaleSelector selector;

  link.addClickHandler(new ClickHandler() {
      @Override
      public void onClick(ClickEvent event) {
        selector.select(model.getLocale());
        navigation.goTo(navigation.getCurrentPage().name());
      }
    });</programlisting>
</section>
<section id="_translationkey_and_translationservice">
<title>TranslationKey and TranslationService</title>
<simpara>The <literal><phrase role="code">@TranslationKey</phrase></literal> annotation and <literal><phrase role="code">TranslationService</phrase></literal> class extend Errai&#8217;s i18n support to Java code. They provide a mechanism for developers to declare translation strings from within their GWT application code (as opposed to the HTML templates).</simpara>
<simpara>To do this, developers must annotate a field which represents the translation key with <literal><phrase role="code">@TranslationKey</phrase></literal> annotation. This key will then map to a value in the translation bundle file. Once the field is annotated appropriately, the developer must directly invoke the TranslationService&#8217;s format() method. This method call will perform a lookup in the translation service of the value mapped to the provided key. Note that value substitution using the <literal>{N}</literal> format is supported.</simpara>
<simpara>As an example, consider the following code:</simpara>
<programlisting language="java" linenumbering="unnumbered">package org.example.ui.client.local;

public class AppMessages {

   @TranslationKey(defaultValue = "I guess something happened!")
   public static final String CUSTOM_MESSAGE = "app.custom-message";

   @TranslationKey(defaultValue = "Hey {0}, I just told you something happened!")
   public static final String CUSTOM_MESSAGE_WITH_NAME = "app.custom-message-with-name";
}</programlisting>
<programlisting language="java" linenumbering="unnumbered">package org.example.ui.client.local;

@Dependent
@Templated
public class CustomComponent extends Composite {

   @Inject
   private TranslationService translationService;

   @Inject
   @DataField
   private Button someAction;

   @EventHandler("someAction")
   private void doLogin(ClickEvent event) {

      // do some action that may require a notification sent to the user

      String messageToUser = translationService.format(AppMessages.CUSTOM_MESSAGE);
      Window.alert(messageToUser);

      String username = getCurrentUserName();
      String messageToUserWithName = translationService.format(AppMessages.CUSTOM_MESSAGE_WITH_NAME, username);
      Window.alert(messageToUserWithName);
   }
}</programlisting>
</section>
</section>
<section id="sid-51806600_ErraiUI-ExtendedstylingwithLESS">
<title>Extended styling with LESS</title>
<simpara>Errai also supports <ulink url="http://lesscss.org">LESS</ulink> stylesheets for <literal>@Templated</literal>. You can specify a CSS or LESS stylesheet path for a component with the <literal>stylesheet</literal> attribute of <literal>@Templated</literal>, as in the example below:</simpara>
<programlisting language="java" linenumbering="unnumbered">package org.jboss.errai.example;

@Templated(stylesheet = "main.less")
public class StyledComponent {
}</programlisting>
<simpara>For the above example, during GWT compilation Errai will load the LESS stylesheet from the classpath (in this case with the path <literal>org/jboss/errai/example/main.less</literal>) and compile it. At runtime the compiled CSS will be loaded.</simpara>
<simpara>You can omit the <literal>stylesheet</literal> attribute if your LESS stylsheet follows the standard Errai UI naming conventions. For example:</simpara>
<programlisting language="java" linenumbering="unnumbered">package org.jboss.errai.example;

@Templated
public class StyledComponent {
}</programlisting>
<simpara>Errai will automatically find and compile a LESS stylesheet for this template if it exists on the classpath at this path: <literal>org/jboss/errai/example/StyledComponent.less</literal></simpara>
<note>
<title>Precedence of CSS and LESS</title>
<simpara>When the <literal>stylesheet</literal> attribute is not specified, Errai will only find a LESS stylesheet as described above if no CSS stylesheet exists at the default path.</simpara>
</note>
</section>
</chapter>
<chapter id="sid-54493676">
<title>Errai UI Navigation</title>
<simpara>Starting in version 2.1, Errai offers a system for creating applications that have multiple bookmarkable pages. This navigation system has the following features:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>Declarative, statically-analyzable configuration of pages and links</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Compile time referential safety (i.e. &ldquo;no broken links&rdquo;)</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Generates a storyboard of the application&rsquo;s navigation flow at compile time</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Decentralized configuration</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Create a new page by creating a new annotated class. No need to edit a second file.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Make navigational changes in the natural place in the code</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Integrates cleanly with Errai UI templates, but also works well with other view technologies</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Builds on Errai IoC &amp; CDI</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Provides support for HTML5 pushState and path-parameter based URLs</simpara>
      
    </listitem>
  
</itemizedlist>

<section id="sid-54493676_ErraiUINavigation-GettingStarted">
<title>Getting Started</title>
<note>
<title>Manual Setup</title>
<simpara>Checkout the <link linkend="Manual-Setup-Section">Manual Setup Section</link> for instructions on how to manually add Errai Navigation to your project.</simpara>
</note>
</section>
<section id="sid-54493676_ErraiUINavigation-HowitWorks">
<title>How it Works</title>
<simpara>Errai Navigation has these main parts:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>The <literal><phrase role="code">@Page</phrase></literal> annotation marks any widget or Errai UI component as a page.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The <literal><phrase role="code">TransitionTo&lt;P&gt;</phrase></literal>, <literal><phrase role="code">TransitionAnchor&lt;P&gt;</phrase></literal>, and <literal><phrase role="code">TransitionToRole&lt;R&gt;</phrase></literal> classes are injectable types that provide links to other pages.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The <literal><phrase role="code">Navigation</phrase></literal> singleton offers control over the navigation system as a whole.</simpara>
      
    </listitem>
  
</itemizedlist>

<simpara>The <literal><phrase role="code">Navigation</phrase></literal> singleton owns a GWT Panel called the <emphasis>navigation panel</emphasis>. This panel always contains a widget or component corresponding to the fragment ID (the part after the # symbol) in the browser&#8217;s location bar. Whenever the fragment ID changes for any reason (for example, because the user pressed the back button, navigated to a bookmarked URL, or simply typed a fragment ID by hand), the widget in the navigation panel is replaced by the widget associated with that fragment ID. Likewise, when the application asks the navigation system to follow a link, the fragment ID in the browser&#8217;s location bar is updated to reflect the new current page.</simpara>
<section id="sid-54493676_ErraiUINavigation-DeclaringaPage">
<title>Declaring a Page</title>
<simpara>To declare a page, annotate any subclass of Widget or Errai UI templated component with the <literal><phrase role="code">@Page</phrase></literal> annotation:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Page
public class ItemListPage extends Composite {
  // Anything goes...
}</programlisting>
<programlisting language="java" linenumbering="unnumbered">@Page
@Templated
public class ComponentPage {
  // Anything goes...
}</programlisting>
<simpara>By default, the name of a page is the simple name of the class that declares it. In the above examples, the <literal><phrase role="code">ItemListPage</phrase></literal> will fill the navigation panel whenever the browser&#8217;s location bar ends with <literal><phrase role="code">#ItemListPage</phrase></literal> and similarly <literal><phrase role="code">ComponentPage</phrase></literal> will be displayed when the location bar ends with <literal><phrase role="code">#ComponentPage</phrase></literal>. If you prefer a different page name, use the <literal><phrase role="code">@Page</phrase></literal> annotation&#8217;s <literal><phrase role="code">path</phrase></literal> attribute:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Page(path="items")
public class ItemListPage extends Composite {
  // Anything goes...
}</programlisting>
<section id="sid-54493676_ErraiUINavigation-TheStartingPage">
<title>The Default (Starting) Page</title>
<simpara>Each application must have exactly one <emphasis>default page</emphasis>. This requirement is enforced at compile time. This default page is displayed when there is no fragment ID present in the browser&#8217;s location bar.</simpara>
<simpara>Use the <literal><phrase role="code">role = DefaultPage.class</phrase></literal> attribute to declare the default starting page, like this:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Page(role = DefaultPage.class)
public class WelcomePage extends Composite {
  // Anything goes...
}</programlisting>
<simpara>Pages are looked up as CDI beans, so you can inject other CDI beans into fields or a constructor. Pages can also have <literal><phrase role="code">@PostConstruct</phrase></literal> and <literal><phrase role="code">@PreDestroy</phrase></literal> CDI methods.</simpara>
</section>
<section id="_page_roles">
<title>Page Roles</title>
<simpara><literal>DefaultPage</literal> is just one example of a page role. A page role is simply an interface used to mark <literal>@Page</literal> types. The main uses for page roles:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>Using the <literal>Navigation</literal> singleton, you can look up all pages that have a specific role.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>If a role is unique (as is the case with <literal>DefaultPage</literal>) then it should extend <literal>UniquePageRole</literal>, making it possible to navigate to the page by its role.</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
</section>
<section id="sid-54493676_ErraiUINavigation-PageLifecycle">
<title>Page Lifecycle</title>
<simpara>There are four annotations related to page lifecycle events: <literal><phrase role="code">@PageShowing</phrase></literal>, <literal><phrase role="code">@PageShown</phrase></literal>, <literal><phrase role="code">@PageHiding</phrase></literal>, and <literal><phrase role="code">@PageHidden</phrase></literal>. These annotations designate methods so a page widget can be notified when it is displayed or hidden:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Page
public class ItemPage extends VerticalPanel {

  @PageShowing
  private void preparePage() {
  }

  @PageHiding
  private void unpreparePage() {
  }

  // Anything goes...
}</programlisting>
<section id="_lifecycle_phases">
<title>Lifecycle Phases</title>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>The fragment identifier in the URL changes</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The <literal><phrase role="code">@PageHiding</phrase></literal> method on the current (about-to-be-navigated-away-from) page is invoked</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The current page is removed from the browser&#8217;s DOM</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The <literal><phrase role="code">@PageHidden</phrase></literal> method on the just-removed page is invoked</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The navigation system looks up the corresponding <literal><phrase role="code">@Page</phrase></literal> bean in the client-side bean manager (we&#8217;ll call this bean "the new page")</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The navigation system writes to all <literal><phrase role="code">@PageState</phrase></literal> fields in the new page bean (more on this in the next section)</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The <literal><phrase role="code">@PageShowing</phrase></literal> method of the new page is invoked</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The new page widget is added to the DOM (as a direct child of the navigation content panel)</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The <literal><phrase role="code">@PageShown</phrase></literal> method of the new page is invoked.</simpara>
      
    </listitem>
  
</orderedlist>
</section>
<section id="_optional_parameters">
<title>Optional Parameters</title>
<simpara>The <literal><phrase role="code">@PageShowing</phrase></literal> and <literal><phrase role="code">@PageShown</phrase></literal> methods are permitted one optional parameter of type <literal><phrase role="code">HistoryToken</phrase></literal>&#8201;&#8212;&#8201;more on this in the next section.</simpara>
<simpara>The <literal><phrase role="code">@PageHiding</phrase></literal> and <literal><phrase role="code">PageShowing</phrase></literal> methods are also permitted one optional parameter of type <literal><phrase role="code">NavigationControl</phrase></literal>. If the parameter is present, the page navigation will not be carried out until <literal>NavigationControl.proceed()</literal> is invoked, or <literal>NavigationControl.redirect(Class)</literal> may be called to redirect to another page with the given class. In <literal><phrase role="code">PageHiding</phrase></literal> methods this is useful for interrupting page navigations and then resuming at a later time (for example, to prompt the user to save their work before transitioning to a new page). In <literal><phrase role="code">PageShowing</phrase></literal> methods, this is useful for redirecting a user before a page is shown based on business logic.</simpara>
</section>
<section id="_page_instance_lifespan">
<title>Page Instance Lifespan</title>
<simpara>The lifespan of a Page instance is governed by CDI scope: Dependent and implict-scoped page beans are instantiated each time the user navigates to them, whereas Singleton and ApplicationScoped beans are created only once over the lifetime of the application. If a particular page is slow to appear because its UI takes a lot of effort to build, try marking it as a singleton.</simpara>
</section>
</section>
<section id="sid-54493676_ErraiUINavigation-PageStateParameters">
<title>Page State Parameters</title>
<simpara>A page widget will often represent a view on on instance of a class of things. For example, there might be an ItemPage that displays a particular item available at a store. In cases like this, it&#8217;s important that the bookmarkable navigation URL includes not only the name of the page but also an identifier for the particular item being displayed.</simpara>
<simpara>This is where page state parameters come in. Consider the following page widget:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Page
public class ItemPage extends VerticalPanel {

  @PageState
  private int itemId;

  // Anything goes...
}</programlisting>
<simpara>This page would be reachable at a URL like <literal>http://www.company.com/store/#ItemPage;itemId=4</literal>, assuming <literal>www.company.com</literal> was the host address and <literal>store</literal> was the application context. Before the page was displayed, the Errai UI Navigation framework would write the <literal><phrase role="code">int</phrase></literal> value <literal><phrase role="code">4</phrase></literal> into the <literal><phrase role="code">itemId</phrase></literal> field.</simpara>
<simpara>Page state parameters can also be accessed using URLs with path parameters. In this case, you have to declare the template of the page&#8217;s path in the <literal><phrase role="code">path</phrase></literal> field of the <literal><phrase role="code">@Page</phrase></literal> annotation. As an example, consider the following code:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Page(path="item/{itemID}/{customerID}")
public class ItemPage extends VerticalPanel {

  @PageState
  private int itemID;

  @PageState
  private String customerID;

  // Anything goes...
}</programlisting>
<simpara></simpara>
<simpara>There are three ways to pass state information to a page: by passing a Multimap to <literal><phrase role="code">TransitionTo.go()</phrase></literal>; by passing a Multimap to <literal><phrase role="code">Navigation.goTo()</phrase></literal>; or by including the state information in the path parameter or fragment identifier of a hyperlink as illustrated in the previous paragraph (use the <literal><phrase role="code">HistoryToken</phrase></literal> class to construct such a URL properly.)</simpara>
<simpara>A page widget can have any number of <literal><phrase role="code">@PageState</phrase></literal> fields. The fields can be of any primitive or boxed primitive type (except <literal><phrase role="code">char</phrase></literal> or <literal><phrase role="code">Character</phrase></literal>), <literal><phrase role="code">String</phrase></literal>, or a <literal><phrase role="code">Collection</phrase></literal>, <literal><phrase role="code">List</phrase></literal>, or <literal><phrase role="code">Set</phrase></literal> of the allowable scalar types. Nested collections are not supported.</simpara>
<simpara><literal><phrase role="code">@PageState</phrase></literal> fields can be private, protected, default access, or public. They are always updated by direct field access; never via a setter method. The updates occur just before the <literal><phrase role="code">@PageShowing</phrase></literal> method is invoked.</simpara>
<simpara>In addition to receiving page state information via direct writes to <literal><phrase role="code">@PageState</phrase></literal> fields, you can also receive the whole Multimap in the <literal><phrase role="code">@PageShowing</phrase></literal> and <literal><phrase role="code">@PageShown</phrase></literal> methods through a parameter of type <literal><phrase role="code">HistoryToken</phrase></literal>. Whether or not a lifecycle method has such a parameter, the <literal><phrase role="code">@PageState</phrase></literal> fields will still be written as usual.</simpara>
<simpara>Page state values are represented in the URL in place of the corresponding parameter variables declared in the URL template (the <literal><phrase role="code">path</phrase></literal> field of the <literal><phrase role="code">@Page</phrase></literal> annotation. See <link linkend="sid-54493676_ErraiUINavigation-DeclaringaPage">Declaring a Page</link>). If a parameter variable is declared in the URL template and is missing from the actual typed URL, it will cause a navigation error as Errai will not be able to match the typed URL to any template.</simpara>
<simpara>Any additional path parameters not found in the URL template are appended as key=value pairs separated by the ampersand (<literal><phrase role="code">&amp;</phrase></literal>) character. Multi-valued page state fields are represented by repeated occurrences of the same key. If a key corresponding to a <literal><phrase role="code">@PageState</phrase></literal> field is absent from the state information passed to the page, the framework writes a default value: <literal><phrase role="code">null</phrase></literal> for scalar Object fields, the JVM default (0 or false) for primitives, and an empty collection for collection-valued fields. To construct and parse state tokens programmatically, use the <literal><phrase role="code">HistoryToken</phrase></literal> class.</simpara>
<simpara>To illustrate this further, consider the following example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Page(path="item/{itemID}/{customerID}")
public class ItemPage extends VerticalPanel {

  @PageState
  private int itemID;

  @PageState
  private String customerID;

  @PageState
  private int storeID;

  // Anything goes...
}</programlisting>
<simpara>Given the host <literal><phrase role="code">"www.company.com"</phrase></literal>, the context <literal>store</literal>, and a state map with the values <literal><phrase role="code">itemID=4231</phrase></literal>, <literal><phrase role="code">customerID=9364</phrase></literal>, and <literal><phrase role="code">storeID=0032</phrase></literal>, the following URL will be generated:
<literal><phrase role="code">www.company.com/store/#item/4231/9364;storeID=0032</phrase></literal></simpara>
<simpara>If the value for storeID is undefined, the URL will be <literal>www.company.com/store/#item/4231/9364;storeID=0</literal>.</simpara>
<simpara>If the URL typed into the browser is <literal>www.company.com/store/#item/4231;storeID=0032</literal>, it will cause a navigation error (assuming there is no other page by this url) because there is a missing path parameter.</simpara>
</section>
<section id="_pushstate_functionality">
<title>PushState Functionality</title>
<simpara>Errai now comes with support for pushState and path-parameter-based URLs. If HTML5 pushState is enabled Errai Navigation urls will not use the fragment-identifier (#). Thus the non-pushState url from the previous section, <literal>www.company.com/store/#item/4231/9364</literal>, would become <literal>www.company.com/store/item/4231/9364</literal>.</simpara>
<simpara>HTML5 pushState can be enabled by adding the following lines to your GWT host page:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;script type="text/javascript"&gt;
    var erraiPushStateEnabled = true;
&lt;/script&gt;</programlisting>
<simpara>The application context must be the same as the application&#8217;s servlet web context deployed on the server. Errai attempts to infer the application context upon the first page load, but it can also be set manually. To explicitly declare the application context, you can use the <literal><phrase role="code">setApplicationContext</phrase></literal> method in the Navigation class, or set the <literal><phrase role="code">erraiApplicationWebContext</phrase></literal> variable in your GWT host page as follows:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;script type="text/javascript"&gt;
    var erraiApplicationWebContext = "store";
&lt;/script&gt;</programlisting>
<simpara>In the event that the browser does not support HTML5, Errai automatically disables pushState functionality and reverts to a <emphasis>#</emphasis>-based URL format. That is, Errai uses fragment identifiers to refer to particular resources.</simpara>
<simpara>If the page that the user is trying to navigate to cannot be found, a 404 - Not Found page is displayed. You can override this functionality and display a custom page in the case of a page not found error. For example, to navigate to the GWT host page by default, add the following lines to your web.xml file:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;error-page&gt;
    &lt;error-code&gt;404&lt;/error-code&gt;
    &lt;location&gt;/&lt;/location&gt;
&lt;/error-page&gt;</programlisting>
</section>
<section id="sid-54493676_ErraiUINavigation-DeclaringaLinkwithTransitionAnchor">
<title>Declaring a Link with TransitionAnchor</title>
<simpara>The easiest way to declare a link between pages is to inject an instance of <literal><phrase role="code">TransitionAnchor&lt;P&gt;</phrase></literal>, where <literal><phrase role="code">P</phrase></literal> is the class of the target page.</simpara>
<simpara>Here is an example declaring an anchor link from the templated welcome page to the item list page. The first code sample would go in WelcomePage.java while the second would go in the WelcomePage.html, the associated html template.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Page(role = DefaultPage.class)
@Templated
public class WelcomePage {

  @Inject @DataField TransitionAnchor&lt;ItemListPage&gt; itemLink;

}</programlisting>
<programlisting language="xml" linenumbering="unnumbered">&lt;div&gt;
  &lt;a data-field="itemLink"&gt;Go to Item List Page&lt;/a&gt;
&lt;/div&gt;</programlisting>
<simpara>You can inject any number of links into a page. The only restriction is that the target of the link must be a Widget type or Errai UI component that is annotated with <literal><phrase role="code">@Page</phrase></literal>. When the user clicks the link Errai will transition to the item list page.</simpara>
</section>
<section id="sid-54493676_ErraiUINavigation-DeclaringaManualLink">
<title>Declaring a Manual Link</title>
<simpara>Sometimes it is necessary to manually transition between pages (such as in response to an event being fired). To declare a manual link from one page to another, inject an instance of <literal><phrase role="code">TransitionTo&lt;P&gt;</phrase></literal>, where <literal><phrase role="code">P</phrase></literal> is the class of the target page.</simpara>
<simpara>This code declares a manual transition from the welcome page to the item list page:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Page(role = DefaultPage.class)
public class WelcomePage extends Composite {

  @Inject TransitionTo&lt;ItemListPage&gt; startButtonClicked;

}</programlisting>
<simpara>You do not need to implement the <literal><phrase role="code">TransitionTo</phrase></literal> interface yourself; the framework creates the appropriate instance for you.</simpara>
<simpara>As with <literal><phrase role="code">TransitionAnchor</phrase></literal>, the only restriction is that the target of the link must be a Widget type or Errai UI component that is annotated with <literal><phrase role="code">@Page</phrase></literal>.</simpara>
</section>
<section id="sid-54493676_ErraiUINavigation-FollowingaManualLink">
<title>Following a Manual Link</title>
<simpara>To follow a manual link, simply call the <literal><phrase role="code">go()</phrase></literal> method on an injected <literal><phrase role="code">TransitionTo</phrase></literal> object. For example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Page(role = DefaultPage.class)
public class WelcomePage extends Composite {

  @Inject TransitionTo&lt;ItemListPage&gt; startButtonClicked;

  public void onStartButtonPressed(ClickEvent e) {
    startButtonClicked.go();
  }
}</programlisting>
</section>
<section id="_declaring_a_link_by_uniquepagerole">
<title>Declaring a Link By UniquePageRole</title>
<simpara>For convenience, it is also possible to transition to a page by its role using an injected <literal>TransitionToRole&lt;R&gt;</literal> where <literal>R</literal> is an interface extending <literal>UniquePageRole</literal>. This type is used exactly as the <literal>TransitionTo</literal>: just inject a parameterized instance and invoke the <literal>go()</literal> method.</simpara>
<simpara>By injecting a <literal>TransitionToRole</literal> into a <literal>@Page</literal>, Errai will verify the existence of a single page with this role at compile-time.</simpara>
</section>
<section id="sid-54493676_ErraiUINavigation-InstallingtheNavigationPanelintotheUserInterface">
<title>Installing the Navigation Panel into the User Interface</title>
<simpara>Beginning in version 2.4, Errai will automatically attach the Navigation Panel to the Root Panel, but it is possible to override this behaviour by simply adding the Navigation Panel to another component manually. The best time to do this is during application startup, for example in the <literal><phrase role="code">@PostConstruct</phrase></literal> method of your <literal><phrase role="code">@EntryPoint</phrase></literal> class. By using the default behaviour you can allow Errai Navigation to control the full contents of the page, or you can opt to keep some parts of the page (headers, footers, and sidebars, for example) away from Errai Navigation by choosing an alternate location for the Navigation Panel.</simpara>
<simpara>The following example reserves space for header and footer content that is not affected by the navigation system:</simpara>
<programlisting language="java" linenumbering="unnumbered">@EntryPoint
public class Bootstrap {

  @Inject
  private Navigation navigation;

  @PostConstruct
  public void clientMain() {
    VerticalPanel vp = new VerticalPanel();
    vp.add(new HeaderWidget());
    vp.add(navigation.getContentPanel());
    vp.add(new FooterWidget());

    RootPanel.get().add(vp);
  }
}</programlisting>
<simpara>This last example demonstrates a simple approach to defining the page structure with an Errai UI template. The final product is identical to the above example, but in this case the overall page structure is declared in an HTML template rather than being defined programmatically in procedural logic:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated("#root")
@EntryPoint
public class OverallPageStructure {

  @Inject
  private Navigation navigation;

  @Inject @DataField
  private DivElement root;

  @Inject @DataField
  private Header header;

  @Inject @DataField
  private SimplePanel content;

  @Inject @DataField
  private Footer footer;

  @PostConstruct
  public void clientMain() {

    // give over the contents of this.content to the navigation panel
    content.add(navigation.getContentPanel());

    // add this whole component to the DOM
    Document.get().getBody().appendChild(root);
  }

}</programlisting>
</section>
<section id="sid-54493676_ErraiUINavigation-OverridingthedefaultNavigatingPaneltype">
<title>Overriding the default Navigating Panel type</title>
<simpara>By default Errai uses <literal><phrase role="code">com.google.gwt.user.client.ui.SimplePanel</phrase></literal> as a container for navigation panel. Sometimes this is not sufficient and users would prefer using another implementation. For example a <literal><phrase role="code">com.google.gwt.user.client.ui.SimpleLayoutPanel</phrase></literal> that manages child size state.</simpara>
<simpara>To provide your own implementation of the navigation panel you must implement <literal><phrase role="code">org.jboss.errai.ui.nav.client.local.NavigatingContainer</phrase></literal>. For example:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class NavigatingPanel implements NavigatingContainer {

  SimplePanel panel = new SimpleLayoutPanel();

  public void clear() {
    this.panel.clear();
  }

  public Widget asWidget() {
    return panel.asWidget();
  }

  public Widget getWidget() {
    return panel.getWidget();
  }

  public void setWidget(Widget childWidget) {
    panel.add(childWidget);
  }

  public void setWidget(IsWidget childWidget) {
    panel.add(childWidget);
  }

}</programlisting>
<simpara>Then in your GWT module descriptor you need to override the default navigation panel (<literal><phrase role="code">org.jboss.errai.ui.nav.client.local.NavigatingContainer</phrase></literal>) by adding:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;replace-with class="com.company.application.client.NavigatingPanel"&gt;
  &lt;when-type-is class="org.jboss.errai.ui.nav.client.local.NavigatingContainer"/&gt;
&lt;/replace-with&gt;</programlisting>
</section>
<section id="_handling_navigation_errors">
<title>Handling Navigation Errors</title>
<simpara>When a user enters a url for an Errai page that does not exist an error is logged and the app navigates to the <literal>DefaultPage</literal>. It is possible to override this behaviour by setting an error handler on <literal>Navigation</literal>.</simpara>
<simpara>Here is an example of a class that registers a navigation error handler that redirects the user to a special <literal>PageNotFound</literal> page:</simpara>
<programlisting language="java" linenumbering="unnumbered">@ApplicationScoped
public class NavigationErrorHandlerSetter {

  @Inject
  private Navigation navigation;

  @PostConstruct
  public void setErrorHandler() {
    navigation.setErrorHandler(new PageNavigationErrorHandler() {

      @Override
      public void handleError(Exception exception, String pageName) {
        navigation.goTo("PageNotFound");
      }

      @Override
      public void handleError(Exception exception, Class&lt;? extends PageRole&gt; pageRole) { <co id="CO7-1"/>
        navigation.goTo("PageNotFound");
      }
    });
  }

}</programlisting>
<calloutlist>
  
  <callout arearefs="CO7-1">
    <para>Note that this method signature is for errors that occur from calls to <literal>Navigation.goToWithRole(Class&lt;? extends UniquePageRole&gt;)</literal>. These kinds of errors can be avoided at compile-time by injecting <literal>TransitionToRole</literal> instances into your <literal>@Page</literal> classes instead of directly calling that method.</para>
    
  </callout>
  
</calloutlist>
</section>
<section id="sid-54493676_ErraiUINavigation-ViewingtheGeneratedNavigationGraph">
<title>Viewing the Generated Navigation Graph</title>
<simpara>Because the pages and links in an Errai Navigation application are declared structurally, the framework gets a complete picture of the app&#8217;s navigation structure at compile time. This knowledge is saved out during compilation (and at page reload when in Dev Mode) to the file <literal><phrase role="code">.errai/navgraph.gv</phrase></literal>. You can view the navigation graph using any tool that understands the GraphViz (also known as DOT) file format.</simpara>
<simpara>One popular open source tool that can display GraphViz/DOT files is <ulink url="http://www.graphviz.org/">GraphViz</ulink>. Free downloads are available for all major operating systems.</simpara>
<simpara>When rendered, a navigation graph looks like this:</simpara>
<figure>
<title>Navigation Graph</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493676/example_errai_nav_graph.png"/>
    </imageobject>
    <textobject><phrase>example_errai_nav_graph</phrase></textobject>
  </mediaobject>
</figure>
<simpara>In the rendered graph, the pages are nodes (text surrounded by an ellipse). The starting page is drawn with a heavier stroke. The links are drawn as arrows from one page to another. The labels on these arrows come from the Java field names the TransitionTo objects were injected into.</simpara>
</section>
</section>
</chapter>
<chapter id="_errai_security">
<title>Errai Security</title>
<simpara>Errai Security provides a lightweight security API for declaring RPC services and client-side UI elements which require authentication or authorization.</simpara>
<warning>
<title>PicketLink support deprecated</title>
<simpara>The Errai Security support for Picket Link is deprecated. Users should use Keycloak with Errai or provide their own implementations for Errai&#8217;s AuthenticationService.</simpara>
</warning>
<note>
<title>Manual Setup</title>
<simpara>Checkout the <link linkend="Manual-Setup-Section">Manual Setup Section</link> for instructions on how to manually add Errai Security to your project.</simpara>
</note>
<section id="_basic_model">
<title>Basic Model</title>
<simpara>Errai Security provides two main concepts:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara><emphasis role="strong">Users</emphasis></simpara>
      

<itemizedlist>
  
    <listitem>
      <simpara>A User corresponds to a single person.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>It is usually associated with a username, full name, and email address.</simpara>
      
    </listitem>
  
</itemizedlist>


      
    </listitem>
  
    <listitem>
      <simpara><emphasis role="strong">Roles</emphasis></simpara>
      

<itemizedlist>
  
    <listitem>
      <simpara>A Role represents a priveleged group within your system.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>A User can have several roles, and a role can be had by many users.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Roles are the primary way of defining authorization in Errai Security.</simpara>
      
    </listitem>
  
</itemizedlist>


      
    </listitem>
  
</itemizedlist>

<simpara>By default the server-side Errai Security module uses <ulink url="http://www.picketlink.org/">PicketLink</ulink> for authentication. Later on we will explain how to use an alternative backend.</simpara>
</section>
<section id="_getting_started">
<title>Getting Started</title>
<section id="_making_users">
<title>Making Users</title>
<simpara>The simplest way to begin experimenting with Errai Security is to add Users and Roles to PicketLink programmatically. Here is some sample server-side code from the <ulink url="https://github.com/errai/errai/blob/main/errai-demos/errai-security-demo/src/main/java/org/jboss/errai/security/demo/server/PicketLinkDefaultUsers.java">Errai Security Demo</ulink>.</simpara>
<programlisting language="java" linenumbering="numbered">@Singleton
@Startup
public class PicketLinkDefaultUsers {

  @Inject
  private PartitionManager partitionManager; <co id="CO8-1"/>

  /**
   * &lt;p&gt;Loads some users during the first construction.&lt;/p&gt;
   */
  @PostConstruct
  public void create() {
    final IdentityManager identityManager = partitionManager.createIdentityManager();
    final RelationshipManager relationshipManager = partitionManager.createRelationshipManager();

    User john = new User("john");

    john.setEmail("john@doe.com");
    john.setFirstName("John");
    john.setLastName("Doe");

    User hacker = new User("hacker");

    hacker.setEmail("hacker@illegal.ru");
    hacker.setFirstName("Hacker");
    hacker.setLastName("anonymous");

    identityManager.add(john); <co id="CO8-2"/>
    identityManager.add(hacker);
    final Password defaultPassword = new Password("123");
    identityManager.updateCredential(john, defaultPassword);
    identityManager.updateCredential(hacker, defaultPassword);

    Role roleDeveloper = new Role("simple");
    Role roleAdmin = new Role("admin");

    identityManager.add(roleDeveloper);
    identityManager.add(roleAdmin);

    relationshipManager.add(new Grant(john, roleDeveloper)); <co id="CO8-3"/>
    relationshipManager.add(new Grant(john, roleAdmin));
  }

}</programlisting>
<simpara>Here are the important things that are happening here:</simpara>
<calloutlist>
  
  <callout arearefs="CO8-1">
    <para>PicketLink uses the concept of partitions, which are sections that can contain different users and roles. What we really need to make users and roles are the <literal>IdentityManager</literal> and <literal>RelationshipManager</literal>, but these objects are <literal>@RequestScoped</literal> so in order to access them when the application starts we must <literal>@Inject</literal> the <literal>PartitionManager</literal>.</para>
    
  </callout>
  
  <callout arearefs="CO8-2">
    <para>Here we add are new users to the <literal>IdentityManager</literal>. It is also used below to give passwords to the new users, and to add the <emphasis>simple</emphasis> and <emphasis>admin</emphasis> roles.</para>
    
  </callout>
  
  <callout arearefs="CO8-3">
    <para>The <literal>RelationshipManager</literal> defines relationships between entities. In this case, it is used to specify that a user belongs to a role.</para>
    
  </callout>
  
</calloutlist>
</section>
<section id="_authentication_from_the_client">
<title>Authentication from the Client</title>
<simpara>Once you&#8217;ve created some users and roles, you&#8217;re ready to write some client-side code. Authentication is performed with the <literal>org.jboss.errai.security.shared.service.AuthenticationService</literal> via Errai RPC.</simpara>
<simpara>Here is some sample code involving the user <emphasis>john</emphasis> from the previous Security Demo excerpt.</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>Injecting the <literal>Caller&lt;AuthenticationService&gt;</literal>:</simpara>
      
<programlisting language="java" linenumbering="unnumbered">@Inject Caller&lt;AuthenticationService&gt; authServiceCaller;</programlisting>

      
    </listitem>
  
    <listitem>
      <simpara>Logging in:</simpara>
      
<programlisting language="java" linenumbering="unnumbered">authServiceCaller.call(new RemoteCallback&lt;User&gt;() {

    @Override
    public void callback(User user) {
      // handle successful login
    }
  }, new ErrorCallback&lt;Message&gt;() {

    @Override
    public boolean error(Message message, Throwable t) {
      if (t instanceof AuthenticationException) {
        // handle authentication failure
      }

      // Returning true causes the error to propogate to top-level handlers
      return true;
    }
  }).login("john", "123");</programlisting>

      
    </listitem>
  
    <listitem>
      <simpara>Getting the currently authenticated User:</simpara>
      
<programlisting language="java" linenumbering="unnumbered">authServiceCaller.call(new RemoteCallback&lt;User&gt;() {

    @Override
    public void callback(User user) {
      if (!user.equals(User.ANONYMOUS)) {
        // Do something because we're logged in.
      }
      else {
        // Do something else because we're not logged in.
      }
    }
  }).getUser();</programlisting>

      
    </listitem>
  
    <listitem>
      <simpara>Logging out:</simpara>
      
<programlisting language="java" linenumbering="unnumbered">authServiceCaller.call().logout();</programlisting>

      
    </listitem>
  
</itemizedlist>

<note>
<title>AuthenticationService Caching</title>
<simpara>Client-side interceptors are used for caching so that generally only calls to <literal>login</literal> and <literal>logout</literal> must be sent over the wire. The cache is automatically invalidated when a service throws an <literal>UnauthenticatedException</literal>, but it can also be invalidated manually via the <literal>SecurityContext</literal>.</simpara>
</note>
</section>
</section>
<section id="_restrictedaccess">
<title>RestrictedAccess</title>
<simpara>The annotation <literal>@RestrictedAccess</literal> is the only annotation necessary to secure a resource or UI element. In general, <literal>@RestrictedAccess</literal> blocks a resource from users who are either not logged in or who lack required roles. Roles are defined through the <literal>@RestrictedAccess</literal> annotation in one of the following two ways.</simpara>
<section id="_simple_roles_as_strings">
<title>Simple Roles as Strings</title>
<simpara>Simple roles are roles that can be directly mapped to Strings (the String value being the role name). Simple roles are defined by defining an array of Strings in the <literal>roles</literal> parameter of <literal>@RestrictedAccess</literal>. Two simple roles are equivalent if they have the same name.</simpara>
<simpara>Here is an example usage of <literal>@RestrictedAccess</literal> with two simple roles, "user" and "admin":</simpara>
<programlisting language="java" linenumbering="unnumbered">@RestrictedAccess(roles = { "user", "admin" })</programlisting>
</section>
<section id="_provided_roles">
<title>Provided Roles</title>
<simpara>Conceptually, a provided can be used to implement a more complex security system. In practice, a provided role is some concrete type that implements the <literal>Role</literal> interface and overrides <literal>Object.equals(Object)</literal>. Provided roles are declared on a resource by creating a <literal>RequiredRolesProvider</literal> that produces these roles and assigning the type to the <literal>providers</literal> parameter of <literal>@RestrictedAccess</literal>.</simpara>
<simpara>Here is an sample of a <literal>RequireRolesProvider</literal> and its usage with <literal>@RestrictedAccess</literal>. This example defines equivalent roles to the above example using simple roles.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Dependent <co id="CO9-1"/>
public class AdminRolesProvider implements RequiredRolesProvider {

  @Override
  public Set&lt;Role&gt; getRoles() {
    return new HashSet&lt;Role&gt;(Arrays.asList(
      new RoleImpl("user"), <co id="CO9-2"/>
      new RoleImpl("admin")
    ));
  }
}</programlisting>
<programlisting language="java" linenumbering="unnumbered">@RestrictedAccess(providers = { AdminRolesProvider.class })</programlisting>
<calloutlist>
  
  <callout arearefs="CO9-1">
    <para>The role provider implementation must be a CDI bean so that it can be looked up dynamically on the client and server.</para>
    
  </callout>
  
  <callout arearefs="CO9-2">
    <para><literal>RoleImpl</literal> is the internal implementation used for simple roles. A <literal>RoleImpl</literal> equals another role if they are both instances of <literal>RoleImpl</literal> and have matching names.</para>
    
  </callout>
  
</calloutlist>
</section>
<section id="_rpc_services">
<title>RPC Services</title>
<simpara>To secure an Errai RPC service, simply annotate the RPC interface (either the entire type or just a method) with one of the security annotations.</simpara>
<simpara>For example:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>All methods on this interface require an authenticated user to access:</simpara>
      
<programlisting language="java" linenumbering="unnumbered">@Remote
@RestrictedAccess
public interface UserOnlyStuff {
  public void someMethod();
  public void otherMethod();
}</programlisting>

      
    </listitem>
  
    <listitem>
      <simpara>Here the first method requires an authenticated user, and the second requires a user with the <emphasis>admin</emphasis> role:</simpara>
      
<programlisting language="java" linenumbering="unnumbered">@Remote
public interface MixedService {

  @RestrictedAccess
  public void userService();

  @RestrictedAccess(roles = {"admin"})
  public void adminService();
}</programlisting>

      
    </listitem>
  
</itemizedlist>

<note>
<title>Using Role Providers with RPC Services</title>
<simpara>If a <literal>RequiredRolesProvider</literal> is used on an RPC interface, the provider type must be located in a shared package. Security checks for RPCs are performed on the client and the server, so placing the type in a client- or server-only package will result in run-time errors.</simpara>
</note>
<section id="_error_callbacks">
<title>Error Callbacks</title>
<simpara>When access to a secured RPC service is denied an <literal>UnauthenticatedException</literal> or <literal>UnauthorizedException</literal> is thrown. This error is then transmitted back to the client, where it can be caught with an <literal>ErrorCallback</literal> (provided when the RPC is invoked).</simpara>
<simpara>Here is how we would invoke the previous <literal>MixedService</literal> example with error handling:</simpara>
<programlisting language="java" linenumbering="unnumbered">MessageBuilder.createCall(new RemoteCallback&lt;Void&gt;() {

    @Override
    public void callback(Void response) {
      // ...
    }
  }, new ErrorCallback&lt;Message&gt;() { <co id="CO10-1"/>

    @Override
    public boolean error(Message message, Throwable t) {
      if (t instanceof UnauthenticatedException) {
        // User is not logged in.
        return false;
      }
      else if (t instanceof UnauthorizedException) {
        // User is logged in but lacked sufficient roles.
        return false;
      }
      else {
        // Some other error has happened. Let it propogate.
        return true;
      }
    }
  }, MixedService.class).adminService();</programlisting>
<calloutlist>
  
  <callout arearefs="CO10-1">
    <para>This <literal>ErrorCallback</literal> is parameterized with the type <literal>Message</literal> because it is an Errai Bus RPC. In the next section we will demonstrate the use of a JAX-RS RPC.</para>
    
  </callout>
  
</calloutlist>
<important>
<title>DefaultBusSecurityErrorCallback</title>
<simpara>Errai Security provides a default global Bus RPC handler that catches any thrown <literal>UnauthenticatedException</literal> or <literal>UnauthorizedException</literal> and navigates to the page with the <literal>LoginPage</literal> or <literal>SecurityError</literal> role respectively.</simpara>
</important>
</section>
<section id="_jax_rs_rpc">
<title>JAX-RS RPC</title>
<simpara>JAX-RS RPCs are secured exactly as bus RPCs. Here is the first example from the previous section, but converted to use JAX-RS instead of the Errai Bus.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Path("/rest-endpoint")
@RestrictedAccess
public interface UserOnlyStuff {

  @Path("/some-method")
  @GET
  public void someMethod();

  @Path("/other-method")
  @GET
  public void otherMethod();
}</programlisting>
<simpara>There are two important differences when calling a secured JAX-RS RPC (in contrast to an Errai Bus RPC):</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>JAX-RS RPC calls use the <literal>RestErrorCallback</literal> (an interface extending <literal>ErrorCallback&lt;Request&gt;</literal>).</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>There is now global error-handling for JAX-RS.</simpara>
      
    </listitem>
  
</itemizedlist>

<simpara>Because there is no global error-handling, you should always pass a <literal>RestErrorCallback</literal> when using a JAX-RS RPC. Errai provides the <literal>DefaultRestSecurityErrorCallback</literal> that provides the same default behaviour as the <literal>DefaultBusSecurityErrorCallback</literal> mentioned above. It can also optionally wrap a provided callback as demonstrated below:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>Injecting a callback <literal>Instance</literal>:</simpara>
      
<programlisting language="java" linenumbering="unnumbered">@Inject
private Instance&lt;DefaultRestSecurityErrorCallback&gt; defaultCallbackInstance;</programlisting>

      
    </listitem>
  
    <listitem>
      <simpara>Wrapping a custom callback in a default callback:</simpara>
      
<programlisting language="java" linenumbering="unnumbered">void callSomeService() {
  userOnlyStuffService.call(new RemoteCallback&lt;Void&gt;() {

    @Override
    public void callback(Void response) {
      // Handle success...
    }
  }, defaultCallbackInstance.get()
        .setWrappedErrorCallback(new RestErrorCallback() {

          @Override
          public boolean error(Request request, Throwable t) {
            // Handle error...

            // Returning true means the default navigation behaviour will occur
            return true;
          }
        }
  )).someMethod();
}</programlisting>

      
    </listitem>
  
    <listitem>
      <simpara>Using the default callback without a wrapped callback:</simpara>
      
<programlisting language="java" linenumbering="unnumbered">void callSomeService() {
  userOnlyStuffService.call(new RemoteCallback&lt;Void&gt;() {

    @Override
    public void callback(Void response) {
      // Handle success...
    }
  }, defaultCallbackInstance.get()).someMethod();
}</programlisting>

      
    </listitem>
  
</itemizedlist>

</section>
</section>
<section id="_page_navigation">
<title>Page Navigation</title>
<simpara>Any class annotated with <literal>@Page</literal> can also be marked with <literal>@RestrictedAccess</literal>. By doing so, users will be prevented from navigating to the given page if they are not logged in or lack authorization.</simpara>
<simpara>Here are two simple examples:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>This page is only for logged in users:</simpara>
      
<programlisting language="java" linenumbering="unnumbered">@Page
@RestrictedAccess
public class UserProfilePage extends SimplePanel {

  @Inject private Caller&lt;AuthenticationService&gt; authServiceCaller;
  private User user;

  @PageShowing
  private void setupPage() {
    authServiceCaller.call(new RemoteCallback&lt;User&gt;() {
        @Override
        public void callback(User response) {
          // We don't have to check if this is a valid user, since the page requires authentication.
          user = response;
          // do setup...
        }
    }).getUser();
  }

}</programlisting>

      
    </listitem>
  
    <listitem>
      <simpara>This page requires the <emphasis>user</emphasis> and <emphasis>admin</emphasis> roles:</simpara>
      
<programlisting language="java" linenumbering="unnumbered">@Page
@RestrictedAccess(roles = {"admin", "user"})
public class AdminManagementPage extends SimplePanel {
}</programlisting>

      
    </listitem>
  
</itemizedlist>

<important>
<title>Redirection</title>
<simpara>When a user is denied access to a page they will be redirected to a <literal>LoginPage (@Page(role = LoginPage.class))</literal> or <literal>SecurityError (@Page(role = SecurityError.class))</literal> page. To direct a user to the page they were trying to reach after successful login, <literal>@Inject</literal> the <literal>SecurityContext</literal> and invoke the <literal>navigateBackOrHome</literal> method.</simpara>
</important>
<section id="_page_redirection_and_caching">
<title>Page Redirection and Caching</title>
<simpara>Security checks performed before page navigation do not use any RPC calls, but are instead performed from a cached (in-memory) instance of the <literal>org.jboss.errai.security.shared.api.identity.User</literal>. This prevents the possibility of lengthy delays between page navigation while waiting for RPC return values.</simpara>
<simpara>But the drawback is that any attempts to navigate to a secured <literal>@Page</literal> before the cache is populated will result in redirection to the <literal>LoginPage</literal>&#8201;&#8212;&#8201;even if the user is in fact logged in.</simpara>
<simpara>In practice, this is only likely to happen if a user starts an Errai app with a URL to a secure page while still logged in on the server from a previous session.</simpara>
<simpara>One option offered by Errai is to persist the <literal>org.jboss.errai.security.shared.api.identity.User</literal> object on the GWT host page using a servlet filter. In errai-security-server there is <literal>org.jboss.errai.security.server.servlet.UserHostPageFilter</literal> that uses the <literal>AuthenticationService</literal> to do this. The <literal>UserHostPageFilter</literal> works in a CDI container. Enable the filter by setting <literal>errai.security.user_on_hostpage_enabled=true</literal> in ErraiApp.properties and ensuring the filter is active for your hostpage URL (filters index.html and index.jsp by default).</simpara>
<simpara>With this option enabled the <literal>User</literal> will be persisted to a JavaScript variable on the GWT host page, which is loaded quickly enough to avoid the described navigation issue. This feature can also be used to allow an application to work offline, or allow the server to log in a user on an initial page request.</simpara>
<simpara>If you do not wish to use this feature you will likely want to handle this case in the <literal>@PageShowing</literal> method of your <literal>LoginPage</literal>. Here is an outline of what you might want to do:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Page(role = LoginPage.class)
@Templated
public class ExampleLoginPage extends Composite {

  @Inject
  private SecurityContext securityContext;

  @Inject
  private Caller&lt;AuthenticationService&gt; authService;

  @Inject
  @DataField
  private Label status;

  @PageShowing
  public void checkForPendingCache() {
    // Check if cache is invalid.
    if (!securityContext.isUserCacheValid()) {
      // Update the status.
      status.setText("loading...");

      // Force cache to update by calling getUser
      authService.call(new RemoteCallback&lt;User&gt; {
        @Override
        public void callback(User user) {
          /* An interceptor will have updated the cache by now.
             So check if we are logged in and redirect if necessary.
          */
          if (!user.equals(User.ANONYMOUS)) {
            /* This is a special transition that takes us back to
               a secure page from which we were redirected. */
            securityContext.navigateBackOrHome();
          }
          else {
            status.setText("You are not logged in.");
          }
        }
      }).getUser();
    }
  }

}</programlisting>
</section>
</section>
<section id="_hiding_ui_elements">
<title>Hiding UI Elements</title>
<simpara>Errai Security annotations can also be used to hide Errai UI template fields. When a user is not logged in or lacks required roles the annotated field will have the CSS class "errai-restricted-access-style" added to it. By defining this style (for example with <literal>visibility: none</literal>) you can hide or otherwise modify the display of the element for unautorized users.</simpara>
<simpara>Here is an example of an Errai UI templated class using this feature:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class NavBar extends Composite {

  @Inject
  @DataField
  @RestrictedAccess
  private Button logoutButton;

  @Inject
  @DataField
  @RestrictedAccess(roles = {"admin"})
  private Button dropAllTablesButton;

}</programlisting>
</section>
</section>
<section id="_form_based_login">
<title>Form Based Login</title>
<section id="ErraiUserHostPageFilter">
<title>Errai User Host Page Filter</title>
<simpara>The <literal>errai-security-server</literal> jar contains a servlet filter for encoding the currently authenticated user in an html page. By configuring this filter for your GWT host page, a user will be logged-in as soon as your Errai app loads. Here are the steps for setting this up:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>Add the following to your ErraiApp.properties: <literal>errai.security.user_on_hostpage_enabled=true</literal></simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Create a login page using an html form that posts to a servlet-filter. If you are using Errai Security with PicketLink you will want to use the <literal>org.picketlink.authentication.web.AuthenticationFilter</literal> servlet-filter. Otherwise, you will need to implement one yourself that authenticates the user by calling the <literal>AuthenticationService.login(String, String)</literal> method.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Add this filter-mapping.</simpara>
      
<programlisting language="xml" linenumbering="unnumbered">  &lt;filter-mapping&gt;
    &lt;filter-name&gt;ErraiUserHostPageFilter&lt;/filter-name&gt;
    &lt;url-mapping&gt;/gwt-host-page.html&lt;/url-mapping&gt;
  &lt;/filter-mapping&gt;</programlisting>
<simpara>The mapped URL should be that of your GWT Host Page.</simpara>

      
    </listitem>
  
</orderedlist>
</section>
</section>
<section id="_using_an_alternative_to_picketlink">
<title>Using an Alternative to PicketLink</title>
<simpara>All Errai Security authentication is implemented with Errai Remote Procedure Calls to the <literal>AuthenticationService</literal>. A default implementation of this interface using PicketLink is provided in the <literal>errai-security-picketlink</literal> jar. But it is possible to use a different sever-side security framework by providing your own custom implementation of <literal>AuthenticationService</literal> and annotating it with <literal>@Service</literal>. In that case your project should not depend on <literal>errai-security-picketlink</literal>.</simpara>
</section>
<section id="_using_keycloak_for_authentication">
<title>Using Keycloak for Authentication</title>
<simpara><ulink url="http://keycloak.jboss.org/">Keycloak</ulink> is is a new project that provides integrated SSO and IDM for browser apps and RESTful web services. By using Keycloak it is possible to outsource the responsibility of authentication and account management from your application entirely. Errai Security provides an optional <literal>errai-security-keycloak</literal> jar that provides an implementation of the <literal>AuthenticationService</literal> that works with Keycloak.</simpara>
<section id="_how_it_works_overview">
<title>How It Works (Overview)</title>
<simpara>From the perspective of a visitor, here is what happens when she attempts to log in:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>The visitor is redirected to a Keycloak login page.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The visitor submits her credentials through the Keycloak login page.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Assuming the credentials are valid, the visitor is redirected back to the web app, where she is now logged in.</simpara>
      
    </listitem>
  
</itemizedlist>

<section id="_keycloak_token">
<title>Keycloak Token</title>
<simpara>Behind the scenes, when the visitor successfully submits credentials she is redirected back to the web app with a Keycloak Access Token, which contains information that is configurable from within Keycloak. A servlet filter is used to extract the token from the request and assign it to the <literal>AuthenticationService</literal> implementation. At this point the User is now logged in to your application.</simpara>
</section>
</section>
<section id="_setup">
<title>Setup</title>
<note>
<title>Make sure to check out the Errai Security Demo.</title>
<simpara>This demo can be configured to work with Keycloak in just a few simple steps as outlined in the <ulink url="https://github.com/errai/errai/tree/main/errai-demos/errai-security-demo">README file</ulink>!</simpara>
</note>
<simpara>To start from scratch and add Keycloak integration to your application:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>Setup a Keycloak server. Please consult the <ulink url="http://keycloak.jboss.org/docs.html">Keycloak documentation</ulink> for details on how this is achieved.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Start the Keycloak server.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Go to the <ulink url="https://github.com/errai/errai/tree/main/errai-demos/errai-security-demo">Keycloak Administrative Console</ulink> (i.e. <ulink url="http://localhost:8080/auth/admin/)">http://localhost:8080/auth/admin/)</ulink> (the username and password are both <emphasis role="strong">admin</emphasis> on first use).</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Click <emphasis role="strong">Add Realm</emphasis> and create a custom realm for your application.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Select the <emphasis role="strong">Clients</emphasis> tab and click <emphasis role="strong">Create</emphasis>, then fill in the following to add the client application to this realm:</simpara>
      

<itemizedlist>
  
    <listitem>
      <simpara><literal>Client ID</literal>: the name of your client application (i.e. errai-security-demo)</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal>Access Type</literal>: public</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal>Redirect URI</literal>: the url of your application (i.e. <literal>http://localhost:8080/[your-application]/*</literal>)</simpara>
      
    </listitem>
  
</itemizedlist>


      
    </listitem>
  
    <listitem>
      <simpara>After saving your application, choose the new application in the menu and make sure the following are set:</simpara>
      

<itemizedlist>
  
    <listitem>
      <simpara>In the <emphasis role="strong">Roles</emphasis> tab add your custom roles.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>In the <emphasis role="strong">Installation</emphasis> tab choose the format option <literal>keycloak.json</literal> and copy the contents in your <literal>WEB-INF/keycloak.json</literal> file.</simpara>
      
    </listitem>
  
</itemizedlist>


      
    </listitem>
  
    <listitem>
      <simpara>Click on <emphasis role="strong">Users</emphasis> on the side-panel to add a user:</simpara>
      

<itemizedlist>
  
    <listitem>
      <simpara>Fill out the <literal>Username</literal>, <literal>Email</literal>, <literal>First Name</literal>, and <literal>Last Name</literal> with any values.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>After saving go to the <emphasis role="strong">Credentials</emphasis> tab and set a password.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Go to the <emphasis role="strong">Role Mappings</emphasis> tab. Add <literal>at least one</literal> role to the <literal>Assigned Roles</literal> for your application (scroll down to <literal>Application Roles</literal> and select your application to do this).</simpara>
      
    </listitem>
  
</itemizedlist>


      
    </listitem>
  
    <listitem>
      <simpara>Add the <literal>errai-security-keycloak</literal> jar to your project and make sure it&#8217;s being deployed to the server. In maven, the dependency is <literal>org.jboss.errai:errai-security-keycloak</literal>.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Configure the <literal>ErraiUserCookieFilter</literal> in your <literal>web.xml</literal>. All that is necessary is adding a filter-mapping for your GWT host page like so:</simpara>
      
<programlisting language="xml" linenumbering="unnumbered">  &lt;filter-mapping&gt;
    &lt;filter-name&gt;ErraiUserCookieFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/index.html&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;</programlisting>

      
    </listitem>
  
    <listitem>
      <simpara>Configure the <literal>ErraiLoginRedirectFilter</literal> in your <literal>web.xml</literal>.</simpara>
      

<itemizedlist>
  
    <listitem>
      <simpara>Create a filter-mapping of this filter onto a path that will act as a url to the Keycloak login page. For example, if your deployed app is called <literal>my-app</literal> and you wanted <literal>&lt;server-uri&gt;/my-app/app-login</literal> as your login url then you would add the following:</simpara>
      
<programlisting language="xml" linenumbering="unnumbered">  &lt;filter-mapping&gt;
    &lt;filter-name&gt;ErraiLoginRedirectFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/app-login&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;</programlisting>

      
    </listitem>
  
    <listitem>
      <simpara>Add a security-constraint to login url. This is what actually causes the redirection to Keycloak. All the filter does is redirect back to your app (which happens after the login completes). For the previous example, the constraint would look like this:</simpara>
      
<programlisting language="xml" linenumbering="unnumbered">  &lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
      &lt;web-resource-name&gt;Login&lt;/web-resource-name&gt;
      &lt;url-pattern&gt;/app-login&lt;/url-pattern&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;
      &lt;role-name&gt;*&lt;/role-name&gt;
    &lt;/auth-constraint&gt;
  &lt;/security-constraint&gt;</programlisting>

      
    </listitem>
  
    <listitem>
      <simpara>Optionally configure the URL that the <literal>ErraiLoginRedirectFilter</literal> redirects to. You can do this with the <literal>redirectLocation</literal> param, which takes a path relative to the app context:</simpara>
      
<programlisting language="xml" linenumbering="unnumbered">  &lt;filter&gt;
    &lt;filter-name&gt;ErraiLoginRedirectFilter&lt;/filter-name&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;redirectLocation&lt;/param-name&gt;
      &lt;param-value&gt;/index.jsp&lt;/param-value&gt;
    &lt;/init-param&gt;
  &lt;/filter&gt;</programlisting>

      
    </listitem>
  
</itemizedlist>


      
    </listitem>
  
    <listitem>
      <simpara>Set the login method to use Keycloak in you <literal>web.xml</literal>:</simpara>
      
<programlisting language="xml" linenumbering="unnumbered">  &lt;login-config&gt;
    &lt;auth-method&gt;KEYCLOAK&lt;/auth-method&gt;
    &lt;realm-name&gt;[your-realm-name]&lt;/realm-name&gt;
  &lt;/login-config&gt;</programlisting>

      
    </listitem>
  
    <listitem>
      <simpara>Add roles available to users in your application to the <literal>web.xml</literal>. Here is an example declaration of a "user" role:</simpara>
      
<programlisting language="xml" linenumbering="unnumbered">  &lt;security-role&gt;
    &lt;role-name&gt;user&lt;/role-name&gt;
  &lt;/security-role&gt;</programlisting>

      
    </listitem>
  
</itemizedlist>

<important>
<title>All users must have at least one role</title>
<simpara>With this configuration all users must have at least a single role, or else they will not be redirected propertly. Unfortunately, there is no way to define a security-constraint that only requires authentication. The simplest solution is to add a default role to your realm.</simpara>
</important>
</section>
</section>
</chapter>
<chapter id="sid-74908675">
<title>Logging</title>
<simpara>Errai now supports using the <ulink url="http://www.slf4j.org/">slf4j</ulink> logging api on the server and client. This gives you the flexibility of choosing your own logging back-end for your server-side code, while still allowing a uniform logging interface that can be used in shared packages.</simpara>
<section id="sid-74908675_Logging-Whatisslf4j%3F">
<title>What is slf4j?</title>
<simpara>sl4j is logging abstraction. Using the slf4j api, you can add log statements to your code using a fixed api while maintaining the ability to switch the logging implementation at run-time. For example, the slf4j api can be used with java.util.logging (JUL) as the back-end.</simpara>
</section>
<section id="sid-74908675_Logging-ClientSideSetup">
<title>Client-Side Setup</title>
<simpara>The client-side slf4j code uses the <ulink url="http://www.gwtproject.org/doc/latest/DevGuideLogging.html">GWT Logging</ulink> as the back-end. Using slf4j in client-side code has three steps:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>Add the errai-common artifact as a maven dependency to your project</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Inherit the GWT module <literal><phrase role="code">org.jboss.errai.common.ErraiCommon</phrase></literal></simpara>
      
<programlisting language="xml" linenumbering="unnumbered">  &lt;inherits name="org.jboss.errai.common.ErraiCommon" /&gt;</programlisting>

      
    </listitem>
  
    <listitem>
      <simpara>Enable logging and configure the log level in your gwt.xml module descriptor:</simpara>
      
<programlisting language="xml" linenumbering="unnumbered">  &lt;set-property name="gwt.logging.enabled" value="TRUE"/&gt;
  &lt;set-property name="gwt.logging.logLevel" value="ALL"/&gt;</programlisting>

      
    </listitem>
  
</itemizedlist>

<section id="sid-74908675_Logging-ErraiClientSideLogHandlers">
<title>Errai Client-Side Log Handlers</title>
<simpara>In the ErraiCommon module, we have disabled the built-in GWT log handlers and provided four handlers of our own:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara><emphasis>ErraiSystemLogHandler</emphasis>: prints log statements to the terminal in Development Mode</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>ErraiConsoleLogHandler</emphasis>: prints statements to the web console in the browser</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>ErraiDevelopmentModeLogHandler</emphasis>: prints statements in the Development Mode window</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>ErraiFirebugLogHandler</emphasis>: prints statements to the console in Firefox These loggers are all enabled by default and set to handle all log levels.</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
<section id="sid-74908675_Logging-ConfiguringErraiClientSideLogHandlers">
<title>Configuring Errai Client-Side Log Handlers</title>
<simpara>Log handler levels can be changed at run-time through Java or Javascript. To do so through Java, use the <literal><phrase role="code">LoggingHandlerConfigurator</phrase></literal> in Errai Common. Here&#8217;s an example:</simpara>
<example>
<title>HandlerLevelAdjuster.java</title>
<programlisting language="java" linenumbering="unnumbered">import org.jboss.errai.common.client.logging.LoggingHandlerConfigurator;
import org.jboss.errai.common.client.logging.handlers.ErraiSystemLogHandler;
import java.util.logging.Level;

public class HandlerLevelAdjuster {

  public static void logAll() {
    LoggingHandlerConfigurator config = LoggingHandlerConfigurator.get();
    ErraiSystemLogHandler handler = config.getHandler(ErraiSystemLogHandler.class);
    handler.setLevel(Level.ALL);
  }

  public static void disableLogging() {
    LoggingHandlerConfigurator config = LoggingHandlerConfigurator.get();
    ErraiSystemLogHandler handler = config.getHandler(ErraiSystemLogHandler.class);
    handler.setLevel(Level.OFF);
  }

}</programlisting>
</example>
<simpara>Each handler has a native Javascript variable associated with its log level:</simpara>
<informaltable frame="all"
    rowsep="1" colsep="1">
  
  <tgroup cols="2">
    
    <colspec colname="col_1" colwidth="50*"/>
    
    <colspec colname="col_2" colwidth="50*"/>
    
    
    <thead>
      
      <row>
        
        <entry align="left" valign="top">Handler</entry>
        
        <entry align="left" valign="top">Variable Name</entry>
        
      </row>
      
    </thead>
    
    <tbody>
      
      <row>
        
        <entry align="left" valign="top"><simpara>ErraiSystemLogHandler</simpara></entry>
        
        <entry align="left" valign="top"><simpara>erraiSystemLogHandlerLevel</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara>ErraiConsoleLogHandler</simpara></entry>
        
        <entry align="left" valign="top"><simpara>erraiConsoleLogHandlerLevel</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara>ErraiDevelopmentModeLogHandler</simpara></entry>
        
        <entry align="left" valign="top"><simpara>erraiDevelopmentModeLogHandlerLevel</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara>ErraiFirebugLogHandler</simpara></entry>
        
        <entry align="left" valign="top"><simpara>erraiFirebugLogHandlerLevel</simpara></entry>
        
      </row>
      
    </tbody>
    
  </tgroup>
</informaltable>
<simpara>Since these are native Javascript variables, they can easily be set in a script tag on your host page:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;script type="text/javascript"&gt;
  erraiSystemLoghandlerLevel = "INFO";
&lt;/script&gt;</programlisting>
<simpara>The possible log levels correspond to those in <literal><phrase role="code">java.util.logging.Level</phrase></literal>.</simpara>
<important>
<title>Logging Levels</title>
<simpara>If you are increasing the logging level of an Errai log handler, you will also need to increase the <literal>gwt.logging.logLevel</literal> (set in your <literal>*.gwt.xml</literal>). Handlers will not receive log records that are lower than the GWT log level, which is set to <emphasis role="strong">INFO</emphasis> in <literal>ErraiCommon.gwt.xml</literal>.</simpara>
</important>
</section>
<section id="sid-74908675_Logging-FormatString">
<title>Format String</title>
<simpara>The Errai log handlers use <literal><phrase role="code">ErraiSimpleFormatter</phrase></literal> to format log output. The format string is similar to that used in by <literal><phrase role="code">java.util.SimpleFormatter</phrase></literal> (for precise differences please see the javadocs for <literal><phrase role="code">ErraiSimpleFormatter</phrase></literal> and <literal><phrase role="code">StringFormat</phrase></literal>).</simpara>
<simpara>As with handler settings, these can be configured in Java or Javascript. To do so in Java, use <literal><phrase role="code">ErraiSimpleFormmater.setSimpleFormatString(String)</phrase></literal>. In Javascript, just set the variable <literal><phrase role="code">erraiSimpleFormatString</phrase></literal> to the desired value.</simpara>
</section>
</section>
<section id="sid-74908675_Logging-ServerSideSetup">
<title>Server-Side Setup</title>
<simpara>On the server you are free to use any logging back-end that has slf4j bindings (or to make your own). Just make sure to add dependencies for the slf4j-api artifact and the slf4j binding you choose. <emphasis>Note:</emphasis> Some application servers provide their own slf4j bindings (such as JBoss AS), in which case you should add your binding dependency as provided scope.</simpara>
<simpara>To learn more about how to setup slf4j for your server-side code, see <ulink url="http://www.slf4j.org/">their website</ulink>.</simpara>
</section>
<section id="sid-74908675_Logging-ExampleUsage">
<title>Example Usage</title>
<simpara>Here is sample usage of the slf4j code (which with the above setup can be run on the client or server):</simpara>
<example>
<title>LogExample.java</title>
<programlisting language="java" linenumbering="unnumbered">import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import javax.inject.Inject;

public class LogExample {

  public void logStuff() {
    // Get a logger for this class
    @Inject Logger logger;

    // Logging going from most to least detailed
    logger.trace("this is extremely specific!");
    logger.debug("this is still pretty specific");
    logger.info("this is an average log message");
    logger.warn("there might be something fishy here...");
    logger.error("uh oh... abandon ship!", new Exception("I am a logged exception"));
  }
}</programlisting>
</example>
</section>
<section id="sid-74908675_Logging-LoggerNames">
<title>Logger Names</title>
<simpara>By default, the above example with provide a logger with the fully qualified class name of the enclosing class. To inject a logger with an alternate name, use the <literal><phrase role="code">NamedLogger</phrase></literal> annotation:</simpara>
<example>
<title>NamedLogExample.java</title>
<programlisting language="java" linenumbering="unnumbered">import org.slf4j.Logger;
import javax.inject.Inject;
import org.jboss.errai.common.client.api.NamedLogger;

public class NamedLogExample {

  // Get a logger with the name "Logger!"
  @Inject @NamedLogger("Logger!") logger;

  // Get the root logger
  @Inject @NamedLogger rootLogger;

}</programlisting>
</example>
</section>
</chapter>
<chapter id="Manual-Setup-Section">
<title>Configuration</title>
<simpara>This section contains information on manually setting up Errai and describes additional configurations and settings which may be adjusted.</simpara>
<section id="_errai_development_mode_configuration">
<title>Errai Development Mode Configuration</title>
<section id="sid-5931501_DeployingErraiCDI-DeploymentinDevelopmentMode">
<title>Deployment in Development Mode</title>
<simpara>In development mode we need to bootstrap the CDI environment on our own and make both Errai and CDI available through JNDI (common denominator across all runtimes). GWT by default uses Jetty, that only supports read only JNDI. The current solution for this is to use a custom launcher to control a JBoss AS 7 or Wildfly 8 instance instead of GWT&#8217;s built-in Jetty.</simpara>
<simpara>To do this, requires the following configurations in the gwt-maven-plugin configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;plugin&gt;
  &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
  &lt;artifactId&gt;gwt-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;${gwt.version}&lt;/version&gt;

  &lt;configuration&gt;
  ...
    &lt;extraJvmArgs&gt;-Derrai.jboss.home=$JBOSS_HOME&lt;/extraJvmArgs&gt;
    &lt;noServer&gt;false&lt;/noServer&gt;
    &lt;server&gt;org.jboss.errai.cdi.server.gwt.EmbeddedWildFlyLauncher&lt;/server&gt;
  &lt;/configuration&gt;
  &lt;executions&gt;
  ...
  &lt;/executions&gt;
&lt;/plugin&gt;</programlisting>
<simpara>What does all this mean?</simpara>

<itemizedlist>
  
    <listitem>
      <simpara><literal>&lt;noServer&gt;false&lt;/noServer&gt;</literal>: Tells GWT to lauch a server for us.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal>&lt;server&gt;org.jboss.errai.cdi.server.gwt.EmbeddedWildFlyLauncher&lt;/server&gt;</literal>: Tells GWT to use a custom launcher instead of it&#8217;s default JettyLauncher.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal>&lt;extraJvmArgs&gt;-Derrai.jboss.home=$JBOSS_HOME&lt;/extraJvmArgs&gt;</literal>: Tells the launcher the location of the Wildfly instance to use. Note that <literal>$JBOSS_HOME</literal> should be replaced with a literal path (or pom property) to a Wildfly instance you have installed.</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
<section id="_additional_launcher_arguments">
<title>Additional Launcher Arguments</title>
<simpara>Here are some additional JVM arguments that can be passed to the JBossLauncher:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara><literal>errai.dev.context</literal>: Sets the context under which your app will be deployed (defaults to "webapp").</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal>errai.jboss.args</literal>: For supplying any command arguments for the WildFly instance being launched.</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
<section id="sid-5931501_DeployingErraiCDI-DeploymenttoanApplicationServer">
<title>Deployment to an Application Server</title>
<simpara>We provide integration with the <ulink url="http://jboss.org/jbossas">JBoss Application Server</ulink>, but the requirements are basically the same for other vendors. When running a GWT client app that leverages CDI beans on a Java EE 6 application server, CDI is already part of the container and accessible through JNDI (<literal><phrase role="code">java:/BeanManager</phrase></literal>).</simpara>
</section>
</section>
<section id="_server_side_class_generation">
<title>Server-Side Class Generation</title>
<simpara>Errai Marshalling and Errai CDI generate class files that should be packaged in your server-side war (usually in WEB-INF/classes). Errai will attempt to discover where these files should be written, but in some project configurations you may need to specify this manually. You can add this system property to your gwt-maven-plugin configuration to explicitly set the target folder to <literal>src/main/webapp/WEB-INF/classes</literal>:</simpara>
<screen>-Derrai.server.classOutput=src/main/webapp/WEB-INF/classes</screen>
</section>
<section id="Offline-Mode">
<title>Errai Offline Mode Configuration</title>
<simpara>Errai provides special support for HTML5&#8217;s application caching mechanism that enables applications to work offline. If you&#8217;re
not familiar with the HTML5 application cache you can find all the details <ulink url="https://developer.mozilla.org/en-US/docs/Web/HTML/Using_the_application_cache">here</ulink>.</simpara>
<simpara>As GWT compiles separate browser-specific JavaScript permutations for your application, it is not enough to manually create a cache manifest file and simply list all generated JavaScript files. This would cause every browser to download and cache JavaScript files that it doesn&#8217;t need in the first place (i.e. Safari would download and cache JavaScript files that were generated for Internet Explorer only). Errai solves this problem by using a custom linker to generate user-agent specific cache manifest files.</simpara>
<simpara>The following steps are necessary to activate this linker:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>Define the linker in your gwt.xml module descriptor:</simpara>
      
    </listitem>
  
</itemizedlist>

<programlisting language="xml" linenumbering="unnumbered">&lt;define-linker name="offline" class="org.jboss.errai.offline.linker.DefaultCacheManifestLinker" /&gt;
&lt;add-linker name="offline" /&gt;</programlisting>

<itemizedlist>
  
    <listitem>
      <simpara>Add the manifest (<literal>your_module_name</literal>/errai.appcache) to the <literal>html</literal> tag in your host page:</simpara>
      
    </listitem>
  
</itemizedlist>

<programlisting language="xml" linenumbering="unnumbered">&lt;html manifest="your_module_name/errai.appcache"&gt;</programlisting>

<itemizedlist>
  
    <listitem>
      <simpara>Add a mime-mapping to your web.xml file (you can skip this step if you deploy the errai-javaee-all.jar as part of your application):</simpara>
      
    </listitem>
  
</itemizedlist>

<programlisting language="xml" linenumbering="unnumbered">&lt;mime-mapping&gt;
  &lt;extension&gt;manifest&lt;/extension&gt;
  &lt;mime-type&gt;text/cache-manifest&lt;/mime-type&gt;
&lt;/mime-mapping&gt;</programlisting>

<itemizedlist>
  
    <listitem>
      <simpara>Make sure the <literal>errai-common.jar</literal> file is deployed as part of your application. It contains a servlet that will provide the correct user-agent specific manifest file in response to requests to your_module_name/errai.appcache</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>To obtain manifests that contain other files in addition to those generated by the <literal>DefaultCacheManifestLinker</literal>, create a subclass that overrides <literal>otherCachedFiles()</literal>, and use this subclass as a linker instead:</simpara>
      
    </listitem>
  
</itemizedlist>

<programlisting language="java" linenumbering="unnumbered">@Shardable
@LinkerOrder(Order.POST)
public class MyCacheManifestLinker extends DefaultCacheManifestLinker {
  @Override
  protected String[] otherCachedFiles() {
    return new String[] {"/my-app/index.html","/my-app/css/application.css"};
  }
}</programlisting>
</section>
<section id="sid-5931354">
<title>ErraiApp.properties</title>
<simpara>ErraiApp.properties acts both as a marker file for JARs that contain Errai-enabled GWT modules, and as a place to put configuration settings for those modules in the rare case that non-default configuration is necessary.</simpara>
<section id="sid-5931354_ErraiApp.properties-AsaMarkerFile">
<title>As a Marker File</title>
<simpara><emphasis>An</emphasis> <literal><phrase role="code">ErraiApp.properties</phrase></literal> <emphasis>file must appear at the META-INF directory of each classpath location that contains an Errai module.</emphasis> The contents of JAR and directory classpath entries that do not contain an <literal><phrase role="code">ErraiApp.properties</phrase></literal> are effectively invisible to Errai&#8217;s classpath scanner. . (Placing ErraiApp.properties in the root of the classpath is still supported for compatibility reasons but may not be in future versions.)</simpara>
</section>
<section id="sid-5931354_ErraiApp.properties-AsaConfigurationFile">
<title>As a Configuration File</title>
<simpara>ErraiApp.properties is usually left empty, but it can contain configuration settings for both the core of Errai and any of its extensions. Configuration properties defined and used by Errai components have keys that start with " <literal><phrase role="code">errai.</phrase></literal> ". Third party extensions should each choose their own prefix for keys in ErraiApp.properties.</simpara>
<section id="sid-5931354_ErraiApp.properties-ConfigurationMerging">
<title>Configuration Merging</title>
<simpara>In a non-trivial application, there will be several instances of ErraiApp.properties on the classpath (one per JAR file that contains Errai modules, beans, or portable classes).</simpara>
<simpara>Before using the configuration information from ErraiApp.properties, Errai reads the contents of every ErraiApp.properties on the classpath. The configuration information in all these files is merged together to form one set of key=value pairs.</simpara>
<simpara>If the same key appears in more than one ErraiApp.properties file, only one of the values will be associated with that key. The other values will be ignored. In future versions of Errai, this condition may be made into an error. It&#8217;s best to avoid specifying the same configuration key in multiple ErraiApp.properties files.</simpara>
</section>
<section id="sid-5931354_ErraiApp.properties-ErraiMarshallingConfiguration">
<title>Errai Marshalling Configuration</title>

<itemizedlist>
  
    <listitem>
      <simpara><emphasis>errai.marshalling.use_static_marshallers</emphasis> when set to <literal><phrase role="code">false</phrase></literal>, Errai will not use the precompiled server-side marshallers even if the generated <literal><phrase role="code">ServerMarshallingFactoryImpl</phrase></literal> class is found on the classpath. This is useful when using Dev Mode in conjunction with an external server such as JBoss AS 7 or EAP 6.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>errai.marshalling.force_static_marshallers</emphasis> when set to <literal><phrase role="code">true</phrase></literal>, Errai will not use dynamic marshallers. If the generated <literal><phrase role="code">ServerMarshallingFactoryImpl</phrase></literal> cannot be loaded (possibly after an attempt to generate it on-the-fly), the Errai web app will fail to start.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>errai.marshalling.short_names</emphasis> when set to true (the default value), Errai will shorten the names of generated marshaller classes (rather than using the long names which encode the fully qualified class names of the types being marshalled). This was added to avoid issues with path length limitations on certain platforms.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>errai.marshalling.very_short_names</emphasis> when set to true, Errai will shorten the names of generated marshaller classes to a 7 character long hash. This was added to avoid issues with path length limitations on certain platforms.</simpara>
      
    </listitem>
  
</itemizedlist>

<simpara>Errai also supports configuring portable types in <literal><phrase role="code">ErraiApp.properties</phrase></literal> as an alternative to the <literal><phrase role="code">@Portable</phrase></literal> annotation. See <link linkend="sid-5931328_Marshalling-ManualMapping">the Errai Marshalling section on Manual Mapping</link> for details.</simpara>
</section>
<section id="sid-5931354_ErraiApp.properties-ErraiIoCConfiguration">
<title>Errai IoC Configuration</title>

<itemizedlist>
  
    <listitem>
      <simpara><emphasis>errai.ioc.QualifyingMetaDataFactory</emphasis> specifies the fully-qualified class name of the QualifyingMetadataFactory implementation to use with Errai IoC.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>errai.ioc.enabled.alternatives</emphasis> specifies a whitespace-separated list of fully-qualified class names for <emphasis>alternative beans</emphasis>. See <link linkend="sid-22872133">Alternatives and Mocks</link> for details.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>errai.ioc.async_bean_manager</emphasis> a boolean property that when set to true (defaults to false) will activate asynchronous IOC to allow for <ulink url="http://www.gwtproject.org/doc/latest/DevGuideCodeSplitting.html">code splitting</ulink>. The code of types annotated with <literal><phrase role="code">@LoadAsync</phrase></literal> will be downloaded the first time it is needed. <literal><phrase role="code">@LoadAsync</phrase></literal> also allows to specify a fragment name using a class literal. Using GWT 2.6.0 or higher, all types with the same fragment name will be part of the same split point.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>errai.ioc.denylist</emphasis> specifies a whitespace-separated list of classes that should be hidden from Errai IOC and that will be excluded when generating the bean graph and wiring components. Wildcards are supported to exclude all types underneath a package e.g. org.jboss.myapp.exclude.* (all types under the exclude package will be hidden from ERRAI IOC).</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>errai.ioc.allowlist</emphasis> when this property is present all types in your application are hidden from Errai IOC by default. It specifies a whitespace-separated list of classes that should be visible to IOC and that will be included when generating the bean graph and wiring components. Wildcards are supported to include all types underneath a package e.g. org.jboss.myapp.include.* (all types under the include package will be visible to ERRAI IOC).</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
<section id="_errai_jpa_configuration">
<title>Errai JPA Configuration</title>

<itemizedlist>
  
    <listitem>
      <simpara><emphasis>errai.jpa.allowlist</emphasis> specifies a whitespace-separated list of fully-qualified class names that should be included in Errai JPA&#8217;s scanning and in the Entity Manager. Any entities that are not part of the allowlist are ignored by Errai JPA. This property supports wildcards to exclude everything within a package (e.g. org.jboss.myapp.exclude.*).</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>errai.jpa.denylist</emphasis> specifies a whitespace-separated list of fully-qualified class names that should be excluded from Errai JPA&#8217;s scanning. This can be used for client-side entities that do not use Errai JPA. This property supports wildcards to exclude everything within a package (e.g. org.jboss.myapp.exclude.*). The denylist has priority over the allowlist. This means that if a class is part of both the denylist and the allowlist, the class will be denylisted, i.e. ignored by Errai JPA.</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
</section>
</section>
<section id="sid-5931338">
<title>Messaging (Errai Bus) Configuration</title>
<section id="_compile_time_dependencies">
<title>Compile-time Dependencies</title>
<simpara>The following compile-time dependency is required for Errai Messaging:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;dependency&gt;
    &lt;groupId&gt;org.jboss.errai&lt;/groupId&gt;
    &lt;artifactId&gt;errai-bus&lt;/artifactId&gt;
    &lt;version&gt;${errai.version}&lt;/version&gt;
  &lt;/dependency&gt;</programlisting>
<simpara>Or if you are not using Maven, have <literal><phrase role="code">errai-bus-${errai.version}.jar</phrase></literal> on the classpath.</simpara>
<simpara>If you are also using Errai IOC or Errai CDI and wish to use inject Errai Messaging dependencies, you will also want this dependency:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;dependency&gt;
    &lt;groupId&gt;org.jboss.errai&lt;/groupId&gt;
    &lt;artifactId&gt;errai-ioc-bus-support&lt;/artifactId&gt;
    &lt;version&gt;${errai.version}&lt;/version&gt;
  &lt;/dependency&gt;</programlisting>
<simpara>Or if you are not using Maven, have <literal><phrase role="code">errai-ioc-bus-support-${errai.version}.jar</phrase></literal> on the classpath.</simpara>
</section>
<section id="sid-5931338_Messaging%28ErraiBus%29Configuration-Disablingremotecommunication">
<title>Disabling remote communication</title>
<simpara>In some cases it might be desirable to prevent the client bus from communicating with the server. One use case for this is when all communication with the server is handled using JAX-RS and the constant long polling requests for message exchange are not needed.</simpara>
<simpara>To turn off remote communication in the client bus the following JavaScript variable can be set in the HTML host page:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;script type="text/javascript"&gt;
  erraiBusRemoteCommunicationEnabled = false;
&lt;/script&gt;</programlisting>
</section>
<section id="sid-5931338_Messaging%28ErraiBus%29Configuration-Configuringanalternativeremoteremotebusendpoint">
<title>Configuring an alternative remote remote bus endpoint</title>
<simpara>By default the remote bus is expected at the GWT web application&#8217;s context path. In case the remote bus is part of a different web application or deployed on a different server, the following configuration can be used in the HTML host page to configure the remote bus endpoint used on the client.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;script type="text/javascript"&gt;
  erraiBusApplicationRoot = "/MyRemoteMessageBusEnpoint";
&lt;/script&gt;</programlisting>
</section>
<section id="sid-5931338_Messaging%28ErraiBus%29Configuration-ErraiService.properties">
<title>ErraiService.properties</title>
<simpara>The ErraiService.properties file contains basic configuration for the bus itself. Unlike ErraiApp.properties, there should be at most one ErraiService.properties file on the classpath of a deployed application. If you do not need to set any properties to their non-default values, this file can be omitted from the deployment entirely.</simpara>
<section id="sid-5931338_Messaging%28ErraiBus%29Configuration-MessageDispatching">
<title>Message Dispatching</title>
<simpara>Dispatchers encapsulate the strategy for taking messages that need to be delivered somewhere and seeing that they are delivered to where they need to go. There are two primary implementations that are provided with Errai, depending on your needs.</simpara>
<simpara id="sid-5931338_Messaging%28ErraiBus%29Configuration-SimpleDispatcher">SimpleDispatcher:</simpara>
<simpara>SimpleDispatcher is basic implementation that provides no asychronous delivery mechanism. Rather, when you configure the Errai to use this implementation, messages are delivered to their endpoints synchronously. The incoming HTTP thread will be held open until the messages are delivered.</simpara>
<simpara>While this sounds like it has almost no advantages, especially in terms of scalablity. Using the SimpleDispatcher can be far preferable when you&#8217;re developing your application, as any errors and stack traces will be far more easily traced and some cloud services may not permit the use of threads in any case.</simpara>
<simpara id="sid-5931338_Messaging%28ErraiBus%29Configuration-AsyncDispatcher">AsyncDispatcher:</simpara>
<simpara>The AsyncDispatcher provides full asynchronous delivery of messages. When this dispatcher is used, HTTP threads will have control immediately returned upon dispatch of the message. This dispatcher provides far more efficient use of resources in high-load applications, and will significantly decrease memory and thread usage overall.</simpara>

<itemizedlist>
  
    <listitem>
      <simpara><emphasis>errai.dispatcher.implementation</emphasis> specifies the dispatcher implementation to be used by the bus. There are two implementations which come with Errai out of the box: the <literal><phrase role="code">SimpleDispatcher</phrase></literal> and the <literal><phrase role="code">AsyncDispatcher</phrase></literal>. See ERRAI:Dispatcher Implementations for more information about the differences between the two.</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
<section id="sid-5931338_Messaging%28ErraiBus%29Configuration-Threading">
<title>Threading</title>

<itemizedlist>
  
    <listitem>
      <simpara><emphasis>errai.async_thread_pool_size</emphasis> specifies the total number of worker threads in the worker pool for handling and delivering messages. Adjusting this value does not have any effect if you are using the SimpleDispatcher.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>errai.async.worker_timeout</emphasis> specifies the total amount of time (in seconds) that a service is given to finish processing an incoming message before the pool interrupts the thread and returns an error. Adjusting this value has no effect if you are using the SimpleDispatcher.</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
<section id="sid-5931338_Messaging%28ErraiBus%29Configuration-Buffering">
<title>Buffering</title>

<itemizedlist>
  
    <listitem>
      <simpara><emphasis>errai.bus.buffer_size</emphasis> The total size of the transmission buffer, in megabytes. If this attribute is specified along with <literal><phrase role="code">errai.bus.buffer_segment_count</phrase></literal>, then the segment count is inferred by the calculation <literal><phrase role="code">buffer_segment_count / buffer_size</phrase></literal>. If <literal><phrase role="code">errai.bus.buffer_segment_count</phrase></literal> is also defined, it will be ignored in the presence of this property. Default value: 32.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>errai.bus.buffer_segment_size</emphasis> The transmission buffer segment size in bytes. This is the minimum amount of memory each message will consume while stored within the buffer. Defualt value: 8.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>errai.bus.buffer_segment_count</emphasis> The number of segments in absolute terms. If this attribute is specified in the absence of <literal><phrase role="code">errai.bus.buffer_size</phrase></literal>, the buffer size is inferred by the calculation <literal><phrase role="code">buffer_segment_size / buffer_segment_count</phrase></literal>.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>errai.bus.buffer_allocation_mode</emphasis> Buffer allocation mode. Allowed values are <literal><phrase role="code">direct</phrase></literal> and <literal><phrase role="code">heap</phrase></literal>. Direct allocation puts buffer memory outside of the JVM heap, while heap allocation uses buffer memory inside the Java heap. For most situations, heap allocation is preferable. However, if the application is data intensive and requires a substantially large buffer, it is preferable to use a direct buffer. From a throughput perspective, current JVM implementations pay about a 20% performance penalty for direct-allocated memory access. However, your application may show better scaling characteristics with direct buffers. Benchmarking under real load conditions is the only way to know the optimal setting for your use case and expected load. Default value: <literal><phrase role="code">direct</phrase></literal>.</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
<section id="sid-5931338_Messaging%28ErraiBus%29Configuration-Clustering">
<title>Clustering</title>

<itemizedlist>
  
    <listitem>
      <simpara><emphasis>errai.bus.enable_clustering</emphasis> A boolean indicating whether or not Errai&#8217;s server side bus should attempt to orchestrate with its peers. The orchestration mechanism is dependent on the configured clustering provider (e.g. UDP based multicast discovery in case of the default JGroups provider). The default value is <literal><phrase role="code">false</phrase></literal>.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>errai.bus.clustering_provider</emphasis> The fully qualified class name of the clustering provider implementation. A class that implements <literal><phrase role="code">org.jboss.errai.bus.server.cluster.ClusteringProvider</phrase></literal>. Currently the only build-in provider is the <literal><phrase role="code">org.jboss.errai.bus.server.cluster.jgroups.JGroupsClusteringProvider</phrase></literal>.</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
<section id="_csrf_protection_2">
<title>CSRF Protection</title>

<itemizedlist>
  
    <listitem>
      <simpara><emphasis>errai.bus.enable_csrf_token</emphasis> A boolean indicating whether or not a Cross Site Request Forgery (CSRF) protection is enabled. When enabled, the Errai Bus servlet generates a CSRF token for every HTTP session; all bus requests for a session must include the token in an HTTP header. The client-bus can negotiate with the server for a token when connecting, or else the <literal>org.jboss.errai.bus.server.servlet.CSRFTokenFilter</literal> can be configured to inject it into the host page as a JavaScript variable. The default value is <literal><phrase role="code">false</phrase></literal>.</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
<section id="sid-5931338_Messaging%28ErraiBus%29Configuration-StartupConfiguration">
<title>Startup Configuration</title>

<itemizedlist>
  
    <listitem>
      <simpara><emphasis>errai.auto_discover_services</emphasis> A boolean indicating whether or not the Errai bootstrapper should automatically scan for services. <emphasis>This property must be set to true if and only if Errai CDI is not on the classpath</emphasis>. The default value is <literal><phrase role="code">false</phrase></literal>.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>errai.auto_load_extensions</emphasis> A boolean indicating whether or not the Errai bootstrapper should automatically scan for extensions. The default value is <literal><phrase role="code">true</phrase></literal>.</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
<section id="sid-5931338_Messaging%28ErraiBus%29Configuration-ExampleConfiguration">
<title>Example Configuration</title>
<programlisting language="ini" linenumbering="unnumbered">##
## Request dispatcher implementation (default is SimpleDispatcher)
##
#errai.dispatcher_implementation=org.jboss.errai.bus.server.SimpleDispatcher
errai.dispatcher_implementation=org.jboss.errai.bus.server.AsyncDispatcher

##
## Worker pool size. This is the number of threads the asynchronous worker pool should
## provide for processing incoming messages. This option is only valid when using
## the AsyncDispatcher implementation.
##
errai.async.thread_pool_size=5

##
## Worker timeout (in seconds). This defines the time that a single asychronous process
## may run, before the worker pool terminates it and reclaims the thread. This option
## is only valid when using the AsyncDispatcher implementation.
##
errai.async.worker.timeout=5</programlisting>
</section>
</section>
<section id="sid-5931338_Messaging%28ErraiBus%29Configuration-ServletConfiguration">
<title>Servlet Configuration</title>
<simpara>Errai has several different implementations for HTTP traffic to and from the bus. We provide a universally-compatible blocking implementation that provides fully synchronous communication to/from the server-side bus. Where this introduces scalability problems, we have implemented many webserver-specific implementations that take advantage of the various proprietary APIs to provide true asynchrony.</simpara>
<simpara>These included implementations are packaged at: <literal><phrase role="code">org.jboss.errai.bus.server.servlet</phrase></literal>.</simpara>
<important>
<title>One is Enough!</title>
<simpara>You should use just one of the options below. Configuring multiple ErraiServlet implementations in the same application will lead to unpredictable behaviour!</simpara>
<simpara>Remember that all Errai demos and archetypes are preconfigured with DefaultBlockingServlet as a servlet. You will need to remove this default setup if you choose to use a different ErraiServlet implementation in your app.</simpara>
</important>
<note>
<title>Rolling your own security? Beware!</title>
<simpara>All of the following examples use a wildcard mapping for <literal><phrase role="code">*.erraiBus</phrase></literal> with no path prefix. This allows Errai Bus to communicate from any point in your application&#8217;s URI hierarchy, which allows bus communication to work properly no matter where you choose to put your GWT host page.</simpara>
<simpara>For example, all of the following are equivalent from Errai&#8217;s point of view:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>/in.erraiBus</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>/foo/bar/in.erraiBus</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>/long/path/to/get/to.erraiBus</simpara>
      
    </listitem>
  
</itemizedlist>

<simpara>If you rely on your own security rules or a custom security filter to control access to Errai Bus (rather than the security framework within Errai Bus,) ensure you use the same mapping pattern for that <literal><phrase role="code">filter-mapping</phrase></literal> or <literal><phrase role="code">security-constraint</phrase></literal> as you do for the Errai Servlet itself.</simpara>
</note>
<section id="sid-5931338_Messaging%28ErraiBus%29Configuration-DefaultBlockingServlet">
<title>DefaultBlockingServlet</title>
<simpara>This ErraiServlet implementation should work in virtually any servlet container that supports Java Servlets 2.0 or higher. It provides purely synchronous request handling. The one scenario where this servlet will not work is in servers that put restrictions on putting threads into sleep states.</simpara>
<simpara>The default DefaultBlockingServlet which provides the HTTP-protocol gateway between the server bus and the client buses.</simpara>
<simpara>As its name suggests, DefaultBlockingServlet is normally configured as an HTTP Servlet in the <literal><phrase role="code">web.xml</phrase></literal> file:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;servlet&gt;
  &lt;servlet-name&gt;ErraiServlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;org.jboss.errai.bus.server.servlet.DefaultBlockingServlet&lt;/servlet-class&gt;
  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;ErraiServlet&lt;/servlet-name&gt;
  &lt;url-pattern&gt;*.erraiBus&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</programlisting>
</section>
<section id="sid-5931338_Messaging%28ErraiBus%29Configuration-DefaultBlockingServletconfiguredasFilter">
<title>DefaultBlockingServlet configured as Filter</title>
<simpara>Alternatively, the DefaultBlockingServlet can be deployed as a Servlet Filter. This may be necessary in cases where an existing filter is configured in the web application, and that filter interferes with the Errai Bus requests. In this case, configuring DefaultBlockingServlet to handle <literal><phrase role="code">*.erraiBus</phrase></literal> requests ahead of other filters in web.xml will solve the problem:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;filter&gt;
  &lt;filter-name&gt;ErraiServlet&lt;/filter-name&gt;
  &lt;filter-class&gt;org.jboss.errai.bus.server.servlet.DefaultBlockingServlet&lt;/filter-class&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
  &lt;filter-name&gt;ErraiServlet&lt;/filter-name&gt;
  &lt;url-pattern&gt;*.erraiBus&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</programlisting>
</section>
<section id="sid-5931338_Messaging%28ErraiBus%29Configuration-JettyContinuationsServlet">
<title>JettyContinuationsServlet</title>
<simpara>The Jetty implementation leverages Jetty&#8217;s continuations support, which allows for threadless pausing of port connections. This servlet implementation should work without any special configuration of Jetty.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;servlet&gt;
  &lt;servlet-name&gt;ErraiServlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;org.jboss.errai.bus.server.servlet.JettyContinuationsServlet&lt;/servlet-class&gt;
  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;ErraiServlet&lt;/servlet-name&gt;
  &lt;url-pattern&gt;*.erraiBus&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</programlisting>
</section>
<section id="sid-5931338_Messaging%28ErraiBus%29Configuration-StandardAsyncServlet">
<title>StandardAsyncServlet</title>
<simpara>This implementation leverages asynchronous support in Servlet 3.0 to allow for threadless pausing of port connections. Note that <literal><phrase role="code">&lt;async-supported&gt;true&lt;/async-supported&gt;</phrase></literal> has to be added to the servlet definition in <literal><phrase role="code">web.xml</phrase></literal>.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;servlet&gt;
  &lt;servlet-name&gt;ErraiServlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;org.jboss.errai.bus.server.servlet.StandardAsyncServlet&lt;/servlet-class&gt;
  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;async-supported&gt;true&lt;/async-supported&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;ErraiServlet&lt;/servlet-name&gt;
  &lt;url-pattern&gt;*.erraiBus&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</programlisting>
</section>
<section id="_automatic_service_discovery">
<title>Automatic Service Discovery</title>
<simpara>By default Errai relies on a provided CDI container to do server-side service discovery. But if you intend to use Errai Messaging without a CDI container, Errai can scan for services on its own if the following initialization parameter is added to the servlet configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;init-param&gt;
      &lt;param-name&gt;auto-discover-services&lt;/param-name&gt;
      &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;</programlisting>
<warning>
<simpara>This configuration will cause issues (such as duplicate services) if it is set to true <emphasis>and</emphasis> a server-side CDI container is available.</simpara>
</warning>
</section>
</section>
</section>
<section id="sid-19398997_ErraiJAX-RS-GettingStarted">
<title>Errai JAX-RS Setup</title>
<section id="sid-19398997_ErraiJAX-RS-Dependencies">
<title>Compile-time dependency</title>
<simpara>To use Errai JAX-RS, you must include it on the compile-time classpath. If you are using Maven for your build, add this dependency:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;org.jboss.errai&lt;/groupId&gt;
  &lt;artifactId&gt;errai-jaxrs-client&lt;/artifactId&gt;
  &lt;version&gt;${errai.version}&lt;/version&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</programlisting>
<simpara>Or if you are not using Maven for dependency management, add <literal><phrase role="code">errai-jaxrs-client-${errai.version}.jar</phrase></literal> to your classpath.</simpara>
<simpara>If you intend to use Errai&#8217;s JSON format on the wire you will need to add Errai&#8217;s JAX-RS JSON provider to your classpath and make sure it gets deployed to the server.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;org.jboss.errai&lt;/groupId&gt;
  &lt;artifactId&gt;errai-jaxrs-provider&lt;/artifactId&gt;
  &lt;version&gt;${errai.version}&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
<simpara>Or manually add <literal><phrase role="code">errai-jaxrs-provider-${errai.version}.jar</phrase></literal> in case you&#8217;re not using Maven. If your REST service returns Jackson generated JSON you do not need the errai-jaxrs-provider (see <link linkend="sid-19398997_ErraiJAX-RS-Configuration">Configuration</link>).</simpara>
</section>
<section id="sid-19398997_ErraiJAX-RS-GWTModule">
<title>GWT Module</title>
<simpara>Once you have Errai JAX-RS on your classpath, ensure your application inherits the GWT module as well. Add this line to your application&#8217;s <literal><phrase role="code">*.gwt.xml</phrase></literal> file:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;inherits name="org.jboss.errai.enterprise.Jaxrs"/&gt;</programlisting>
</section>
<section id="sid-19398997_ErraiJAX-RS-Configuration">
<title>Configuration</title>
<section id="sid-19398997_ErraiJAX-RS-ConfiguringthedefaultrootpathofJAXRSendpoints">
<title>Configuring the default root path of JAX-RS endpoints</title>
<simpara>All paths specified using the <literal><phrase role="code">@Path</phrase></literal> annotation on JAX-RS interfaces are by definition relative paths. Therefore, by default, it is assumed that the JAX-RS endpoints can be found at the specified paths relative to the GWT client application&#8217;s context path.</simpara>
<simpara>To configure a relative or absolute root path, the following JavaScript variable can be set in either:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>The host HTML page;</simpara>
      
<programlisting language="xml" linenumbering="unnumbered">&lt;script type="text/javascript"&gt;
  erraiJaxRsApplicationRoot = "/MyJaxRsEndpointPath";
&lt;/script&gt;</programlisting>

      
    </listitem>
  
    <listitem>
      <simpara>By using a JSNI method;</simpara>
      
<programlisting language="java" linenumbering="unnumbered">private native void setMyJaxRsAppRoot(String path) /*-{
  $wnd.erraiJaxRsApplicationRoot = path;
}-*/;</programlisting>

      
    </listitem>
  
    <listitem>
      <simpara>Or by simply invoking.</simpara>
      
<programlisting language="java" linenumbering="unnumbered">RestClient.setApplicationRoot("/MyJaxRsEndpointPath");</programlisting>

      
    </listitem>
  
</itemizedlist>

<simpara>The root path will be prepended to all paths specified on the JAX-RS interfaces. It serves as the base URL for all requests sent from the client.</simpara>
</section>
<section id="sid-19398997_ErraiJAX-RS-EnablingJacksonmarshalling">
<title>Enabling Jackson marshalling</title>
<simpara>The following options are available for activating Jackson marshalling on the client. Note that this is a client-side configuration, the JAX-RS endpoint is assumed to already return a Jackson representation (Jackson is supported by all JAX-RS implementations). The <literal><phrase role="code">errai-jaxrs-provider-${errai.version}.jar</phrase></literal> does not have to be deployed on the server in this case!</simpara>
<simpara>To use the Jackson marshaller add on of these configurations:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>Set a Javascript variable in the GWT Host Page;</simpara>
      
<programlisting language="xml" linenumbering="unnumbered">&lt;script type="text/javascript"&gt;
  erraiJaxRsJacksonMarshallingActive = true;
&lt;/script&gt;</programlisting>

      
    </listitem>
  
    <listitem>
      <simpara>Use a JSNI method;</simpara>
      
<programlisting language="java" linenumbering="unnumbered">private native void setJacksonMarshallingActive(boolean active) /*-{
  $wnd.erraiJaxRsJacksonMarshallingActive = active;
}-*/;</programlisting>

      
    </listitem>
  
    <listitem>
      <simpara>Or invoke a method in RestClient.</simpara>
      
<programlisting language="java" linenumbering="unnumbered">RestClient.setJacksonMarshallingActive(true);</programlisting>

      
    </listitem>
  
</itemizedlist>

</section>
</section>
</section>
<section id="_errai_jpa">
<title>Errai JPA</title>
<section id="sid-54493688_ErraiJPA-Compiletimedependency">
<title>Compile-time Dependencies</title>
<simpara>To use Errai JPA, you must include it on the compile-time classpath. If you are using Maven for your build, add this dependency:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;org.jboss.errai&lt;/groupId&gt;
  &lt;artifactId&gt;errai-jpa-client&lt;/artifactId&gt;
  &lt;version&gt;${errai.version}&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
<simpara>If you are not using Maven for dependency management, add <literal><phrase role="code">errai-jpa-client-${errai.version}.jar</phrase></literal>, Hibernate 4.1.1, and Google Guava for GWT 12.0 to your compile-time classpath.</simpara>
</section>
<section id="sid-54493688_ErraiJPA-GWTModuleDescriptor">
<title>GWT Module Descriptor</title>
<simpara>Once you have Errai JPA on your classpath, ensure your application inherits the GWT module as well. Add this line to your application&#8217;s <literal><phrase role="code">*.gwt.xml</phrase></literal> file:</simpara>
<programlisting language="xml" linenumbering="unnumbered"> &lt;inherits name="org.jboss.errai.jpa.JPA"/&gt;</programlisting>
</section>
</section>
<section id="sid-54493688_ErraiJPA-METAINF%2Fpersistence.xml">
<title>Errai JPA Data Sync</title>
<section id="sid-71467090_ErraiJPADataSync-Dependencies">
<title>Compile-time Dependencies</title>
<simpara>First, ensure your <literal><phrase role="code">pom.xml</phrase></literal> includes a dependency on the Data Sync module. This module must be packaged in your application&#8217;s WAR file, so include it with the default scope (compile):</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;org.jboss.errai&lt;/groupId&gt;
  &lt;artifactId&gt;errai-jpa-datasync&lt;/artifactId&gt;
  &lt;version&gt;${errai.version}&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
</section>
<section id="_gwt_module_descriptor">
<title>GWT Module Descriptor</title>
<simpara>Then, ensure your project&#8217;s <literal><phrase role="code">*.gwt.xml</phrase></literal> module descriptor includes a dependency on the Data Sync GWT module:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;inherits name="org.jboss.errai.jpa.sync.DataSync"/&gt;</programlisting>
</section>
</section>
<section id="_errai_data_binding">
<title>Errai Data Binding</title>
<section id="sid-51282340_DataBinding-Compiletimedependency">
<title>Compile-time Dependencies</title>
<simpara>To use Errai&#8217;s data binding module, you must include it on the compile-time classpath. If you are using Maven for your build, add this dependency:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;org.jboss.errai&lt;/groupId&gt;
  &lt;artifactId&gt;errai-data-binding&lt;/artifactId&gt;
  &lt;version&gt;${errai.version}&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
<simpara>If you are not using Maven for dependency management, add <literal><phrase role="code">errai-data-binding-${errai.version}.jar</phrase></literal> to your classpath.</simpara>
</section>
<section id="sid-51282340_DataBinding-GWTmoduledescriptor">
<title>GWT module descriptor</title>
<simpara>You must also inherit the Errai data binding module by adding the following line to your GWT module descriptor (gwt.xml).</simpara>
<example>
<title>App.gwt.xml</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;inherits name="org.jboss.errai.databinding.DataBinding" /&gt;</programlisting>
</example>
</section>
<section id="_bootstrapping_data_binding_without_errai_ioc">
<title>Bootstrapping Data Binding without Errai IOC</title>
<simpara>In case you don&#8217;t want to or cannot use Errai&#8217;s IOC container you will have to manually bootstrap Errai Data Binding and inherit the Errai Common GWT module:</simpara>
<programlisting language="java" linenumbering="unnumbered">BindableProxyLoader proxyLoader = GWT.create(BindableProxyLoader.class);
proxyLoader.loadBindableProxies();</programlisting>
<programlisting language="xml" linenumbering="unnumbered">&lt;inherits name="org.jboss.errai.common.ErraiCommon"/&gt;</programlisting>
</section>
</section>
<section id="_errai_ui">
<title>Errai UI</title>
<section id="sid-51806600_ErraiUI-pom.xml">
<title>Compile-time dependency</title>
<simpara>The easiest way to get Errai UI on your classpath is to depend on the special <literal><phrase role="code">errai-javaee-all</phrase></literal> artifact, which brings in most Errai modules:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;org.jboss.errai&lt;/groupId&gt;
  &lt;artifactId&gt;errai-javaee-all&lt;/artifactId&gt;
  &lt;version&gt;${errai.version}&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
<simpara>Or if you prefer to manage your project&#8217;s dependency in a finer-grained way, you can depend on <literal><phrase role="code">errai-ui</phrase></literal> directly:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;org.jboss.errai&lt;/groupId&gt;
  &lt;artifactId&gt;errai-ui&lt;/artifactId&gt;
  &lt;version&gt;${errai.version}&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
</section>
<section id="sid-51806600_ErraiUI-App.gwt.xml">
<title>GWT Module Descriptor</title>
<simpara>Once you have Errai UI on your classpath, ensure your application inherits the GWT module as well. Add this line to your application&#8217;s <literal><phrase role="code">*.gwt.xml</phrase></literal> file:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;inherits name="org.jboss.errai.ui.UI" /&gt;</programlisting>
</section>
</section>
<section id="_errai_ui_navigation">
<title>Errai UI Navigation</title>
<section id="sid-54493676_ErraiUINavigation-Compiletimedependency">
<title>Compile-time Dependencies</title>
<simpara>To use Errai UI Navigation, you must include it on the compile-time classpath. If you are using Maven for your build, add these dependencies:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;org.jboss.errai&lt;/groupId&gt;
  &lt;artifactId&gt;errai-navigation&lt;/artifactId&gt;
  &lt;version&gt;${errai.version}&lt;/version&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.jboss.errai&lt;/groupId&gt;
  &lt;artifactId&gt;errai-cdi-client&lt;/artifactId&gt;
  &lt;version&gt;${errai.version}&lt;/version&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</programlisting>
<simpara>If you are not using Maven for dependency management, add <literal><phrase role="code">errai-navigation-${errai.version}.jar</phrase></literal> to the compile-time classpath of a project that&#8217;s already set up for Errai UI templating.</simpara>
</section>
<section id="sid-54493676_ErraiUINavigation-GWTModuleDescriptor">
<title>GWT Module Descriptor</title>
<simpara>Once you have Errai UI Navigation on your classpath, ensure your application inherits the GWT module as well. Add this line to your application&#8217;s <literal><phrase role="code">*.gwt.xml</phrase></literal> file:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;inherits name="org.jboss.errai.ui.nav.Navigation"/&gt;</programlisting>
</section>
</section>
<section id="_errai_security_2">
<title>Errai Security</title>
<section id="_compile_time_dependency">
<title>Compile-time dependency</title>
<simpara>Errai Security requires to modules to be included in a project:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;org.jboss.errai&lt;/groupId&gt;
  &lt;artifactId&gt;errai-security-server&lt;/artifactId&gt;
  &lt;version&gt;${errai.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.jboss.errai&lt;/groupId&gt;
  &lt;artifactId&gt;errai-security-client&lt;/artifactId&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
  &lt;version&gt;${errai.version}&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
<simpara>If you are using picketlink for authentication, you should also include this:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;org.jboss.errai&lt;/groupId&gt;
  &lt;artifactId&gt;errai-security-picketlink&lt;/artifactId&gt;
  &lt;version&gt;${errai.version}&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
</section>
<section id="_gwt_module_descriptor_2">
<title>GWT Module Descriptor</title>
<simpara>Once you have Errai Security Client on your classpath, ensure your application inherits the GWT module as well. Add this line to your application&#8217;s <literal><phrase role="code">*.gwt.xml</phrase></literal> file:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;inherits name="org.jboss.errai.security.Security" /&gt;</programlisting>
</section>
<section id="_cdi_and_interceptor_bindings">
<title>CDI and Interceptor Bindings</title>
<simpara>Errai security requires a CDI container to intercept calls to remote services. In particular, the following interceptor must be added to your application&#8217;s <literal>beans.xml</literal>:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;interceptors&gt;
  &lt;class&gt;org.jboss.errai.security.server.ServerSecurityRoleInterceptor&lt;/class&gt;
&lt;/interceptors&gt;</programlisting>
</section>
</section>
</chapter>
<chapter id="sid-32473113">
<title>Troubleshooting &amp; FAQ</title>
<simpara>This section explains the cause of and solution to some common problems that people encounter when building applications with Errai.</simpara>
<simpara>Of course, when lots of people trip over the same problem, it&#8217;s probably because there is a deficiency in the framework! A FAQ list like this is just a band-aid solution. If you have suggestions for permanent fixes to these problems, please get in touch with us: file an issue in our issue tracker, chat with us on IRC, or post a suggestion on our forum.</simpara>
<simpara>But for now, on to the FAQ:</simpara>
<section id="sid-32473113_Troubleshooting%26FAQ-WhydoesitseemthatErraican%27tseemyclassatcompiletime%3F">
<title>Why does it seem that Errai can&#8217;t see my class at compile time?</title>
<simpara>Possible symptoms:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>uncaught exception: java.lang.RuntimeException: No proxy provider found for type: <emphasis>my.fully.qualified.ServiceName</emphasis></simpara>
      
    </listitem>
  
</itemizedlist>

<simpara><emphasis>Answer:</emphasis> Make sure the <link linkend="sid-5931354">ErraiApp.properties</link> file is actually making it into your runtime classpath.</simpara>
<simpara>One common cause of this problem is a &lt;resources&gt; section in pom.xml that includes src/main/java (to expose .java sources to the GWT compiler) that does not also include src/main/resources as a resource path. You must include both explicitly:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;resources&gt;
  &lt;resource&gt;
    &lt;directory&gt;src/main/java&lt;/directory&gt;
  &lt;/resource&gt;
  &lt;resource&gt;
    &lt;directory&gt;src/main/resources&lt;/directory&gt;
  &lt;/resource&gt;
&lt;/resources&gt;</programlisting>
</section>
<section id="sid-32473113_Troubleshooting%26FAQ-WhyamIgetting%22java.lang.ClassFormatError%3AIllegalmethodname%22%3Cinit%3E%24%22inclassorg%2Fxyz%2Fpackage%2FMyClass%22%3F">
<title>Why am I getting "java.lang.ClassFormatError: Illegal method name "&lt;init&gt;$" in class org/xyz/package/MyClass"?</title>
<simpara><emphasis>Answer:</emphasis> This error message means that your project has a (direct or indirect) subclass of JavaScriptObject that lacks a protected no-args constructor. All subtypes of JavaScriptObject (also known as <emphasis>overlay types</emphasis>) must declare a protected no-args constructor, but the error message could be much clearer. There is an issue filed in the GWT project&#8217;s bug tracker for improving the error message: <ulink url="http://code.google.com/p/google-web-toolkit/issues/detail?id=3383">GWT issue 3383</ulink>.</simpara>
</section>
<section id="sid-32473113_Troubleshooting%26FAQ-I%27mgetting%22java.lang.RuntimeException%3ATherearenoproxyprovidersregisteredyet.%22inmy@PostConstructmethod%21">
<title>I&#8217;m getting "java.lang.RuntimeException: There are no proxy providers registered yet." in my @PostConstruct method!</title>
<simpara><emphasis>Answer:</emphasis> You can&#8217;t invoke RPC methods via <literal><phrase role="code">Caller&lt;?&gt;</phrase></literal> or by other means until after the Errai Bus has finished its initial handshake. Try changing your <literal><phrase role="code">@PostConstruct</phrase></literal> annotation to <literal><phrase role="code">@AfterInitialization</phrase></literal>. This will cause your method to be invoked later after the bus handshake has completed.</simpara>
<simpara>If this doesn&#8217;t help, it is also possible that the proxies were never generated in the first place. Check in <literal><phrase role="code">.errai/RpcProxyLoaderImpl.java</phrase></literal> to see if proxy code exists for the <literal><phrase role="code">@Remote</phrase></literal> and/or <literal><phrase role="code">@Path</phrase></literal> interface in question. If not, your <literal><phrase role="code">@Remote</phrase></literal> interfaces were not present on the GWT compiler&#8217;s classpath when your application module was compiled. Double-check your GWT compilation classpath: all <literal><phrase role="code">@Remote</phrase></literal> interfaces must be visible to (in or inherited by) the GWT module that contains the <literal><phrase role="code">Caller&lt;?&gt;</phrase></literal> types. Pay special attention that your <literal><phrase role="code">@Remote</phrase></literal> and <literal><phrase role="code">@Path</phrase></literal> interfaces are not in a package excluded from the GWT module (by default, every subpackage other than <literal><phrase role="code">client</phrase></literal> and <literal><phrase role="code">shared</phrase></literal> is invisible to the GWT compiler).</simpara>
</section>
<section id="_why_do_i_get_a_404_not_found_page_if_i_try_to_navigate_to_my_web_page_by_typing_in_the_url_or_refreshing_the_page">
<title>Why do I get a "404 - Not Found" page if I try to navigate to my web page by typing in the URL or refreshing the page?</title>
<simpara><emphasis>Answer:</emphasis> There are two reasons that could cause this behaviour:</simpara>
<simpara>You may not have declared a default page for Errai pushState to navigate to in the case of a page not found error. For example, to navigate to the GWT host page by default, add the following lines to your web.xml file. See <link linkend="sid-54493676_ErraiUINavigation-HowitWorks">Errai UI Navigation - How it Works &#8594; PushState Functionality</link>.</simpara>
<simpara>If that doesn&#8217;t work, check to see if you have explicitly declared the application web context in your GWT host page. See <link linkend="sid-54493676">Errai UI Navigation - How it Works &#8594; PushState Functionality</link>.</simpara>
</section>
</chapter>
<chapter id="sid-21758202">
<title>Upgrade Guide</title>
<simpara>This chapter contains important information for migrating to newer versions of Errai. If you experience any problems, don&#8217;t hesitate to get in touch with us. See <link linkend="sid-5833089">Reporting problems</link>.</simpara>
<section id="sid-21758204">
<title>Upgrading from 1.* to 2.0</title>
<simpara>The first issues that will arise after replacing the jars or after changing the version numbers in the <literal><phrase role="code">pom.xml</phrase></literal> are unresolved package imports. This is due to refactorings that became necessary when the project grew. Most of these import problems can be resolved automatically by modern IDEs (Organize Imports). So, this should replace <literal><phrase role="code">org.jboss.errai.bus.client.protocols.*</phrase></literal> with <literal><phrase role="code">org.jboss.errai.common.client.protocols.*</phrase></literal> for example.</simpara>
<simpara>The following is a list of manual steps that have to be carried out when upgrading:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>@ExposedEntity became @Portable (<literal><phrase role="code">org.jboss.errai.common.client.api.annotations.Portable</phrase></literal>). See <link linkend="sid-5931328">Marshalling</link> for details.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The @Conversational annotation must now target the event objects themselves, not the observer methods of the events. So an <emphasis>event type</emphasis> is either conversational or not; you no longer specify that listeners receive arbitrary events in a conversational context. See the <link linkend="sid-21758054_Events-Conversationalevents">Conversational Events</link> section of the CDI chapter for details.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Errai CDI projects must now use the <literal><phrase role="code">SimpleDispatcher</phrase></literal> instead of the <literal><phrase role="code">AsynDispatcher</phrase></literal>. This has to be configured in <link linkend="sid-5931338">Messaging (Errai Bus) Configuration</link>.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The bootstrap listener (configured in <literal><phrase role="code">WEB-INF/web.xml</phrase></literal>) for Errai CDI has changed (<literal><phrase role="code">org.jboss.errai.container.DevModeCDIBootstrap</phrase></literal> is now <literal><phrase role="code">org.jboss.errai.container.CDIServletStateListener</phrase></literal>).</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>gwt 2.3.0 or newer must be used and replace older versions.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>mvel2 2.1.Beta8 or newer must be used and replace older versions.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>weld 1.1.5.Final or newer must be used and replace older versions.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>slf4j 1.6.1 or newer must be used and replace older versions.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>This step can be skipped if Maven is used to build the project. If the project is NOT built using Maven, the following jar files have to be added manually to project&#8217;s build/class path: errai-common-2.x.jar, errai-marshalling-2.x.jar, errai-codegen-2.x.jar, netty-4.0.0.Alpha1.errai.r1.jar.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>If the project was built using an early version of an Errai archetype the configuration of the maven-gwt-plugin has to be modified to contain the <literal><phrase role="code">&lt;hostedWebapp&gt;path-to-your-standard-webapp-folder&lt;/hostedWebapp&gt;</phrase></literal>. This is usually either <literal><phrase role="code">war</phrase></literal> or <literal><phrase role="code">src/main/webapp</phrase></literal>.</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
<section id="sid-24838246">
<title>Upgrading from 2.0.Beta to 2.0.*.Final</title>
<simpara>The following is a list of manual steps that have to be carried out when upgrading from a 2.0.Beta version to 2.0.CR1 or 2.0.Final:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>Starting with 2.0.CR1 the default for automatic service discovery has been changed in favour of CDI based applications. That means it has to be explicitly turned on for plain bus applications (Errai applications that do not use Errai-CDI). Not doing so will result in <literal><phrase role="code">NoSubscribersToDeliverTo</phrase></literal> exceptions. The snippet below shows how to activate automatic service discovery:</simpara>
      
    </listitem>
  
</itemizedlist>

<example>
<title>web.xml</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;servlet&gt;
  &lt;servlet-name&gt;ErraiServlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;org.jboss.errai.bus.server.servlet.DefaultBlockingServlet&lt;/servlet-class&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;auto-discover-services&lt;/param-name&gt;
    &lt;param-value&gt;true&lt;/param-value&gt;
  &lt;/init-param&gt;
  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;</programlisting>
</example>

<itemizedlist>
  
    <listitem>
      <simpara>The <literal><phrase role="code">jboss7-support</phrase></literal> module was deleted and is no longer needed as a dependency.</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
<section id="sid-59146804">
<title>Upgrading from Errai 2.2.x to 2.4 or 3.0</title>
<simpara>There are some breaking API changes in the update from Errai 2.2.x to Errai 2.4.x and 3.0.x.</simpara>
<simpara>Here are the steps you&#8217;ll need to take to get your project compiling after you update:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>Starting with Errai 2.3.0, GWT 2.5.0 or higher is required.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Use your IDE to organize imports at the top level. In eclipse, you&#8217;d click in the Project Explorer, press Ctrl-A (select all) and then Ctrl-O (Organize Imports). Other IDEs have similar features.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The <literal><phrase role="code">ErrorCallback</phrase></literal> interface has been made more general so the same type can be shared between Errai modules. This allows you reuse your own generic error handler class for, eg, Errai JAX-RS and ErraiBus callbacks. If you want to use a generic error handler throughout your app, change your <literal><phrase role="code">ErrorCallback</phrase></literal> implementations to <literal><phrase role="code">ErrorCallback&lt;?&gt;</phrase></literal> and change the first argument type of your error() method to Object. Otherwise, if you have use-case-specific error callbacks, implement the interfaces <literal><phrase role="code">RestErrorCallback</phrase></literal> or <literal><phrase role="code">BusErrorCallback</phrase></literal> as appropriate.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal><phrase role="code">IOCBeanManager</phrase></literal> was replaced by two new types <literal><phrase role="code">SyncBeanManager</phrase></literal> and <literal><phrase role="code">AsyncBeanManager</phrase></literal> that need to be used instead. See <link linkend="sid-21627016">Client-side Bean Manager</link> for details.</simpara>
      
    </listitem>
  
</itemizedlist>

<simpara>Note: Errai 3 is still changing rapidly, so this section is a work in progress. Please add any additional steps you had to take in upgrading your own codebase.</simpara>
</section>
<section id="sid-77234301">
<title>Upgrading to Errai 3.0</title>
<simpara>Here are the steps you&#8217;ll need to take to get your project running after you update:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>Errai&#8217;s custom jetty launcher (org.jboss.errai.cdi.erver.gwt.JettyLauncher) is no longer needed and has been deleted. Simply remove the corresponding -server parameter from your GWT launch configuration if you still use it.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The whole artifact errai-cdi-jetty has been deleted and is no longer required. Delete the JAR file from your project or remove the corresponding dependency in your pom.xml.</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
<section id="_upgrading_to_errai_3_1_from_3_0">
<title>Upgrading to Errai 3.1 from 3.0</title>
<simpara>Here are the steps you&#8217;ll need to take to get your project running after you update:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>If you are using Errai to compile LESS/CSS files you will need to declare a <literal>StyleDescriptor</literal> listing the resources to compile in the desired order. This change was made to provide a deterministic and configurable order of styles in the generated CSS.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Errai 3.1+ targets CDI 1.1 containers by default (i.e. WildFly 8+). If you wish to deploy to a CDI 1.0 container (i.e AS7, EAP6) you will have to downgrade the errai-weld-integration.jar to 3.0.4.Final. You can still use all of Errai&#8217;s latest features and use the 3.1+ versions of all other Errai jars.</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
<section id="_upgrading_to_errai_3_2_from_3_1">
<title>Upgrading to Errai 3.2 from 3.1</title>
<simpara>Starting from Errai 3.2.0.Final, Errai Security only supports Keycloak 1.2.0.Final and higher. Errai Security is no longer compatible with earlier versions of Keycloak.</simpara>
</section>
<section id="_upgrading_to_errai_4_0_from_3_2">
<title>Upgrading to Errai 4.0 from 3.2</title>
<simpara>Here are the steps you&#8217;ll need to take to get your project running after you update:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>Rename dependencies on <literal>errai-weld-integration</literal> to <literal>errai-cdi-server</literal>.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Upgrade to GWT 2.8, the supported GWT version for Errai 4.0.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Fix ambigious dependencies on pseudo-dependent beans. For example in the past the following code would correctly compile and execute in Errai:</simpara>
      
<programlisting language="java" linenumbering="unnumbered">public class SuperType {
}</programlisting>
<programlisting language="java" linenumbering="unnumbered">public class SubType extends SuperType {
}</programlisting>
<programlisting language="java" linenumbering="unnumbered">public class Usage {
  @Inject
  private SuperType bean;
}</programlisting>
<simpara>In Errai 4.0 this is ambiguous because both the <literal>SubType</literal> and <literal>SuperType</literal> classes satisfy this injection site, as is the case in CDI. Some ways to fix this problem:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>Make the base class abstract or @Alternative if you are not also using it.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Use different qualifiers on each type (or at least make only one type @Default).</simpara>
      
    </listitem>
  
</itemizedlist>


      
    </listitem>
  
    <listitem>
      <simpara>Make any <literal>@ApplicationScoped</literal> or <literal>@Singleton</literal> beans proxiable. To be proxiable a bean class must:</simpara>
      

<itemizedlist>
  
    <listitem>
      <simpara>Be non-final.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Have a public, no-argument constructor.</simpara>
      
    </listitem>
  
</itemizedlist>


      
    </listitem>
  
    <listitem>
      <simpara>Remove package-private methods from <literal>@ApplicationScoped</literal> and <literal>@Singleton</literal> beans. Because these beans are proxied, the container must be able to override any non-private methods. Private methods are fine as they do not require proxying.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Explicitly enable any <literal>@Alternative</literal> beans used by your application in ErraiApp.properties.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Add explicit scopes to beans that are only looked up through the bean manager. If a type is not injected anywhere and does not have an explicit scope, it will not be available for lookup by the bean manager at runtime.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Replace usages of <literal>@TestMock</literal> with <literal>@Alternative</literal>. Whenever this is done, you will also have to explicitly activate the bean in the ErraiApp.properties for your test.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Remove usages of the <literal>@New</literal> qualifier. This has been removed from Errai and deprecated in CDI. Instead, consider making your bean <literal>@Dependent</literal> scoped.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Remove injection sites of <literal>@LoadAsync</literal> inside types that are no async. In Errai 4.0, it is only possible to inject async types into eachother.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Check your usages of the bean manager. There have been some changes to the <literal>SyncBeanManager</literal> and <literal>SyncBeanDef</literal> interfaces (and their async counter-parts).</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Add an explicit converter for <literal>@Bound</literal> fileds where there is conversion between <literal>java.util.Date</literal> and <literal>String</literal>.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Remove any usage of the <literal>@StyleDescriptor</literal>. LESS and CSS files can be declared in Java code via the <literal>@Templated</literal> annotation.</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
</chapter>
<chapter id="sid-5833087">
<title>Downloads</title>
<simpara>The distribution packages can be downloaded from jboss.org <ulink url="http://jboss.org/errai/Downloads.html">http://jboss.org/errai/Downloads.html</ulink>.</simpara>
</chapter>
<chapter id="sid-5833088">
<title>Sources</title>
<simpara>Errai is currently managed using GitHub. You can clone our repositories from <ulink url="http://github.com/errai">http://github.com/errai</ulink>.</simpara>
</chapter>
<chapter id="sid-5833089">
<title>Reporting problems</title>
<simpara>If you run into trouble don&#8217;t hesitate to get in touch with us:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>JIRA Issue Tracking: <ulink url="https://jira.jboss.org/jira/browse/ERRAI">https://jira.jboss.org/jira/browse/ERRAI</ulink></simpara>
      
    </listitem>
  
    <listitem>
      <simpara>User Forum: <ulink url="http://community.jboss.org/en/errai?view=discussions">http://community.jboss.org/en/errai?view=discussions</ulink></simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Mailing List: <ulink url="http://jboss.org/errai/MailingLists.html">http://jboss.org/errai/MailingLists.html</ulink></simpara>
      
    </listitem>
  
    <listitem>
      <simpara>IRC: <ulink url="irc://irc.freenode.net/errai">irc://irc.freenode.net/errai</ulink></simpara>
      
    </listitem>
  
</itemizedlist>

</chapter>
<chapter id="sid-5833086">
<title>Errai License</title>
<simpara>Errai is distributed under the terms of the Apache License, Version 2.0. See <ulink url="http://www.apache.org/licenses/LICENSE-2.0">the full Apache license text</ulink>.</simpara>
</chapter>
</book>