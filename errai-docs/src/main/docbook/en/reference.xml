<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<?asciidoc-numbered?>

<book lang="en">
  <bookinfo>
    
    <title>Errai Reference Guide</title>
    
    
    <date>2014-01-23</date>
    
    
    
    

    
    

  </bookinfo>
<chapter id="sid-5833084">
<title>Introduction</title>
<section id="sid-5833083">
<title>What is it?</title>
<simpara>Errai is a GWT-based framework for building rich web applications using next-generation web technologies. Built on-top of ErraiBus, the framework provides a unified federation and RPC infrastructure with true, uniform, asynchronous messaging across the client and server.</simpara>
</section>
<section id="sid-5833091">
<title>Required software</title>
<simpara>Errai requires a JDK version 6 or higher and depends on Apache Maven to build and run the examples, and for leveraging the quickstart utilities.</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>JDK 6.0: <ulink url="http://java.sun.com/javase/downloads/index.jsp">http://java.sun.com/javase/downloads/index.jsp</ulink></simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Apache Maven: <ulink url="http://maven.apache.org/download.html">http://maven.apache.org/download.html</ulink></simpara>
      
    </listitem>
  
</itemizedlist>

</section>
<section id="sid-54493220">
<title>Getting Started with Errai</title>
<simpara>Errai is a framework which combines a constellation of web and server-side technologies to assist you in developing large, scaleable rich web applications using a consistent, standardized programming model for client and server development.</simpara>
<section id="sid-54493220_GettingStartedwithErrai-TechnologyPrimer">
<title>Technology Primer</title>
<simpara>Since Errai is an end-to-end framework, in that, parts of the framework run and operate within the client and parts run and operate within the server, there is a set of various technologies upon which Errai relies. This section will detail the basic core technologies which you&#8217;ll need to be familiar with.</simpara>
<section id="sid-54493220_GettingStartedwithErrai-GoogleWebToolkit%28GWT%29">
<title>Google Web Toolkit (GWT)</title>
<simpara>GWT is a toolkit built around a Java-to-JavaScript compiler. It provides a JRE emulation library, abstraction of browser quirks, a development mode runtime, and tools for native JavaScript integration.</simpara>
<simpara>Errai uses GWT to accomplish the translation of concepts such as CDI into the browser, which enables a consisted client and server programming experience.</simpara>
</section>
<section id="sid-54493220_GettingStartedwithErrai-ContextsandDependencyInjection%28CDI%29">
<title>Contexts and Dependency Injection (CDI)</title>
<simpara>CDI is a standard part of the Java EE 6.0 stack, and is specified in the <ulink url="http://jcp.org/en/jsr/detail?id=299">JSR-299</ulink> specification. CDI provides the basis for the programming model that will be explored in this guide. As such, if you are unfamiliar with CDI, basic concepts will be introduced in this guide, and pre-existing knowledge of CDI is not strictly necessary.</simpara>
<simpara>Errai&#8217;s support for CDI is two-fold: For the server-side, Errai currently has integration with Weld, which is the reference implementation (RI) of the JSR-299 specification. The client-side integration for CDI is provided by the Errai CDI extension. Errai CDI implements a subset of the JSR-299 specification to provide the CDI programming model within client code.</simpara>
</section>
<section id="sid-54493220_GettingStartedwithErrai-JavaAPIforRESTfulWebServices%28JAXRS%29">
<title>Java API for RESTful Web Services (JAX-RS)</title>
<simpara>JAX-RS is an API which provides a standardized programming model for specifying web services based around the concept of the Representational State Transfer (REST) architecture. REST has by and far become the preferred way of developing web services, and is used pervasively in modern web applications. Errai provides a set of tools to make working with JAX-RS easier.</simpara>
</section>
<section id="sid-54493220_GettingStartedwithErrai-ErraiBus">
<title>ErraiBus</title>
<simpara>ErraiBus is an underlying transport technology which provides true, bidirectional, asynchronous messaging between the client and the server. It powers a myriad of technologies throughout the Errai framework, from RPC to CDI Events.</simpara>
</section>
</section>
<section id="sid-54493220_GettingStartedwithErrai-Creatingyourfirstproject">
<title>Creating your first project</title>
<important>
<title>Maven Required</title>
<simpara>The first thing you&#8217;ll need to do if you have not already, is <ulink url="http://maven.apache.org/guides/getting-started/maven-in-five-minutes.html">install Maven</ulink> . If you have no already installed Maven, do so now. Otherwise read on.</simpara>
<simpara>Warning: If you use maven2, you will run into this problem: <ulink url="https://community.jboss.org/thread/177645">https://community.jboss.org/thread/177645</ulink></simpara>
</important>
<simpara>You have two options to set up an Errai application. You can start by copying one of our demos or start building an app with a maven archetype:</simpara>
<section id="sid-54493220_GettingStartedwithErrai-Startfromaworkingexampleapplication">
<title>Start from a working example application</title>
<simpara>Simply download and unzip this <ulink url="https://github.com/errai/errai-tutorial/archive/master.zip">demo</ulink> . Check out the README file and continue with running the app in <link linkend="sid-54493220_GettingStartedwithErrai-RunningtheappinGWT%27sdevelopmentmode">GWT&#8217;s development mode</link> and importing the project into <link linkend="sid-54493220_GettingStartedwithErrai-ConfiguringyourprojectforEclipse">Eclipse</link> .</simpara>
</section>
<section id="sid-54493220_GettingStartedwithErrai-Startfromaquickstartarchetype">
<title>Start from a quickstart archetype</title>
<simpara>Open a terminal or command prompt, and navigate to the directory where you would like to create your Errai project.</simpara>
<simpara>Type or paste the following into the terminal:</simpara>
<screen>
mvn archetype:generate -DarchetypeGroupId=org.jboss.errai.archetypes -DarchetypeArtifactId=cdi-quickstart -DarchetypeVersion=2.3.2.Final
</screen>
<simpara>When it is finished downloading all of the dependencies, you will be prompted to specify the <literal><phrase role="code">groupId</phrase></literal> of your project. In practice, the Maven <literal><phrase role="code">groupId</phrase></literal> is usually the same as the base package of your project. For instance, if your project&#8217;s package namespace will be <literal><phrase role="code">org.company.firestorm</phrase></literal> , the Maven <literal><phrase role="code">groupId</phrase></literal> would usually be the same, or perhaps simply <literal><phrase role="code">org.company</phrase></literal> .</simpara>
<simpara>You will next be prompted to specify an <literal><phrase role="code">artifactId</phrase></literal> , which in practice is the name of the application or the application component, in a multi-module Maven project.</simpara>
<simpara>For instance: <literal><phrase role="code">firestorm-app</phrase></literal></simpara>
<simpara>The next thing you&#8217;ll be asked to specify is the initial version of the artifact, which defaults to <literal><phrase role="code">1.0-SNAPSHOT</phrase></literal> . This is usually a sensible starting version if this is the first version of your app. But your milage may vary. To accept the default value, you can just hit enter.</simpara>
<simpara>You&#8217;ll then be prompted to enter the <literal><phrase role="code">package</phrase></literal> of the application. It will default to the same thing you specified for the <literal><phrase role="code">groupId</phrase></literal> . To accept this default, just hit enter.</simpara>
<simpara>You&#8217;ll be prompted to review all of your choices:</simpara>
<example>
<title>Maven Artifact creation prompt</title>
<screen>
Confirm properties configuration:
groupId: org.company.firestorm
artifactId: firestorm-app
version: 1.0-SNAPSHOT
package: org.company.firestorm
 Y: :
</screen>
</example>
<simpara>You can type <literal><phrase role="code">N</phrase></literal> here and hit enter to correct any mistakes. Or simply hit enter to accept these values.</simpara>
<simpara>After accepting the values you will see something like the following:</simpara>
<screen>
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 10:09.469s
[INFO] Finished at: Mon Sep 17 15:40:04 EDT 2012
[INFO] Final Memory: 9M/81M
[INFO] ------------------------------------------------------------------------
</screen>
<simpara>Congratulations! You&#8217;ve created an archetype for Errai. Let&#8217;s make sure that you have everything set up properly.</simpara>
<simpara>A <emphasis>new directory</emphasis> should have been created with the name of the <literal><phrase role="code">artifactId</phrase></literal> (firestorm-app for example) which you specified.</simpara>
</section>
</section>
<section id="sid-54493220_GettingStartedwithErrai-RunningtheappinGWT%27sdevelopmentmode">
<title>Running the app in GWT&#8217;s development mode</title>
<simpara><ulink url="http://www.gwtproject.org/doc/latest/DevGuideCompilingAndDebugging.html#DevGuideDevMode">GWT&#8217;s development mode</ulink> allows for code-refresh development cycles. Simply change a client-side class and refresh the browser to see your changes. You can also debug client and server side code in your IDE of choice.</simpara>
<simpara>Change into the newly created project directory and type the following:</simpara>
<screen>mvn clean gwt:run</screen>
<simpara>This will begin the download of all the dependencies required to develop with and run Errai. It may take a few minutes to complete the download.</simpara>
<simpara>When it is finished, you should see the GWT Development Mode runtime window appear as shown in <emphasis>Figure 1</emphasis> running on Windows.</simpara>
<figure id="img-gwt-dev">
<title>Figure 1: GWT Development Mode running on Windows</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/DevModeWindows.png"/>
    </imageobject>
    <textobject><phrase>DevModeWindows</phrase></textobject>
  </mediaobject>
</figure>
<simpara>Next, click the <emphasis>Launch Default Browser</emphasis> button. If you have have never used GWT before on your computer, you may get an error when your browser loads as shown in <emphasis>Figure 2</emphasis> .</simpara>
<figure id="img-missing-plugin">
<title>Figure 2: Missing plugin error</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/MissingPluginWindows.png"/>
    </imageobject>
    <textobject><phrase>MissingPluginWindows</phrase></textobject>
  </mediaobject>
</figure>
<simpara>Click the blue button that says <emphasis>Download the GWT Developer Plugin</emphasis> to download the plugin. Run the installer to install the plugin for your browser.</simpara>
<important>
<title>Direct download of plugin</title>
<simpara>If you get a 404 Error for Internet Explorer when clicking the link, you can download the latest plugin for your browser directly from these links:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara><ulink url="http://google-web-toolkit.googlecode.com/svn-history/trunk/plugins/ie/prebuilt/gwt-dev-plugin-x86.msi">Internet Explorer 32-bit</ulink></simpara>
      
    </listitem>
  
    <listitem>
      <simpara><ulink url="http://google-web-toolkit.googlecode.com/svn-history/trunk/plugins/ie/prebuilt/gwt-dev-plugin-x64.msi">Internet Explorer 64-bit</ulink></simpara>
      
    </listitem>
  
</itemizedlist>

</important>
<simpara>Once you have configured your browser for development with GWT, and after loading the app with the <emphasis>Launch Default Browser</emphasis> button, you should see the basic skeleton application load. You should see something like what is shown in <emphasis>Figure 3</emphasis> :</simpara>
<figure id="img-blank-app">
<title>Figure 3: The plain archetype app running in the browser</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/RunningAppBlank.png"/>
    </imageobject>
    <textobject><phrase>RunningAppBlank</phrase></textobject>
  </mediaobject>
</figure>
<simpara>If you type something into the box and click <emphasis>Send</emphasis> , you should see the response sent back from the locally-running server in the app, as shown in <emphasis>Figure 4</emphasis> :</simpara>
<figure id="img-testing-the-app">
<title>Figure 4: Testing that the app is working</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/RunningAppTestData.png"/>
    </imageobject>
    <textobject><phrase>RunningAppTestData</phrase></textobject>
  </mediaobject>
</figure>
<simpara>That&#8217;s it! You&#8217;ve got your first Errai Application up and running. In the next section we&#8217;ll setup your IDE.</simpara>
</section>
<section id="sid-54493220_GettingStartedwithErrai-ConfiguringyourprojectforEclipse">
<title>Configuring your project for Eclipse</title>
<note>
<title>Read the previous section!</title>
<simpara>This next section assumes you have followed the instructions in the previous section. As such, we assume you have created an Errai project from the Errai CDI archetype, which we&#8217;ll be importing into your IDE.</simpara>
</note>
<section id="sid-54493220_GettingStartedwithErrai-Prerequisites">
<title>Prerequisites</title>

</section>
<section id="sid-54493220_GettingStartedwithErrai-GooglePluginforEclipse%28GPE%29">
<title>Google Plugin for Eclipse (GPE)</title>
<simpara>If you have not done so already, you should install the <ulink url="https://developers.google.com/eclipse/docs/install-eclipse-4.2">Google Plugin for Eclipse</ulink> (GPE). Click <ulink url="https://developers.google.com/eclipse/docs/install-eclipse-4.2">here</ulink> for instructions at the Google Plugin for Eclipse site on how to install it. <emphasis>Note:</emphasis> You must install <emphasis>at least</emphasis> the GWT SDK.</simpara>
</section>
<section id="sid-54493220_GettingStartedwithErrai-MavenIntegrationforEclipse%28m2e%29">
<title>Maven Integration for Eclipse (m2e)</title>
<simpara>The project that the archetype in the last section generated is a Maven project. Thus, we will be relying on Maven to manage our project model throughout this guide. As such, we will want to install Maven tooling in the IDE. If you have not already installed m2e in Eclipse, you will want to do so now.</simpara>
<simpara>To install the Maven tooling, use the following steps:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>Go to the <emphasis>Eclipse Marketplace</emphasis> under the <emphasis>Help</emphasis> menu in Eclipse.</simpara>
      
    </listitem>
  
</orderedlist>
<figure>
<title>TODO InformalFigure image title empty</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/EclipseM2eStep1.PNG"/>
    </imageobject>
    <textobject><phrase>EclipseM2eStep1</phrase></textobject>
  </mediaobject>
</figure>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>In the <emphasis>Find</emphasis> dialog enter the phrase <emphasis>Maven</emphasis> and hit enter.</simpara>
      
    </listitem>
  
</orderedlist>
<figure>
<title>TODO InformalFigure image title empty</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/EclipseM2eStep2.PNG"/>
    </imageobject>
    <textobject><phrase>EclipseM2eStep2</phrase></textobject>
  </mediaobject>
</figure>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>Find the <emphasis>Maven Integration for Eclipse</emphasis> plugin and click the <emphasis>Install</emphasis> button for that entry.</simpara>
      
    </listitem>
  
</orderedlist>
<figure>
<title>TODO InformalFigure image title empty</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/EclipseM2eStep3.PNG"/>
    </imageobject>
    <textobject><phrase>EclipseM2eStep3</phrase></textobject>
  </mediaobject>
</figure>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>Accept the defaults by clicking <emphasis>Next</emphasis> , and then accept the User License Agreement to begin the installation.</simpara>
      
    </listitem>
  
</orderedlist>
</section>
<section id="sid-54493220_GettingStartedwithErrai-Importingyourproject">
<title>Importing your project</title>
<simpara>Once you have completed the installation of the prerequisites from the previous section, you will now be able to go ahead and import the Maven project you created in the first section of this guide.</simpara>
<simpara>Follow these steps to get the project setup:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>From the <emphasis>File</emphasis> menu, select <emphasis>Import&#8230;</emphasis></simpara>
      
    </listitem>
  
</orderedlist>
<figure>
<title>TODO InformalFigure image title empty</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/Import1.PNG"/>
    </imageobject>
    <textobject><phrase>Import1</phrase></textobject>
  </mediaobject>
</figure>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>You will be presented with the Import dialog box. From here you want to select <emphasis>Maven</emphasis> &#8594; <emphasis>Existing Maven Projects</emphasis></simpara>
      
    </listitem>
  
</orderedlist>
<figure>
<title>TODO InformalFigure image title empty</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/Import2.PNG"/>
    </imageobject>
    <textobject><phrase>Import2</phrase></textobject>
  </mediaobject>
</figure>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>From the <emphasis>Import Maven Projects</emphasis> dialog, you will need to select the directory location of the project you created in the first section of this guide. In the <emphasis>Root Directory</emphasis> field of the dialog, enter the path to the project, or click <emphasis>Browse&#8230;</emphasis> to select it from the file chooser dialog.</simpara>
      
    </listitem>
  
</orderedlist>
<figure>
<title>TODO InformalFigure image title empty</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/Import3.PNG"/>
    </imageobject>
    <textobject><phrase>Import3</phrase></textobject>
  </mediaobject>
</figure>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>Click <emphasis>Finish</emphasis> to begin the import process.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>When the import process has finished, you should see your project imported within the Eclipse <emphasis>Project Explorer</emphasis> . The <literal><phrase role="code">App</phrase></literal> class generated by the archetype should be visible within the <literal><phrase role="code">client</phrase></literal> package under the package root you specified when creating the project.</simpara>
      
    </listitem>
  
</orderedlist>
<figure>
<title>TODO InformalFigure image title empty</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/Import4.PNG"/>
    </imageobject>
    <textobject><phrase>Import4</phrase></textobject>
  </mediaobject>
</figure>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>The next step will be to configure your project as a Google Web Toolkit project in order to enable the GPE plugin features which we will rely on in this guide. You can do this by first right-clicking on the project name within the <emphasis>Project Explorer</emphasis> panel, selecting the <emphasis>Google</emphasis> &#8594; <emphasis>Web Toolkit Settings&#8230;</emphasis> options.</simpara>
      
    </listitem>
  
</orderedlist>
<figure>
<title>TODO InformalFigure image title empty</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/Import5.PNG"/>
    </imageobject>
    <textobject><phrase>Import5</phrase></textobject>
  </mediaobject>
</figure>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>To enable the GWT features of the plugin, check the <emphasis>Use Google Web Toolkit</emphasis> checkbox in the dialog that appears.</simpara>
      
    </listitem>
  
</orderedlist>
<figure>
<title>TODO InformalFigure image title empty</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/Import6.PNG"/>
    </imageobject>
    <textobject><phrase>Import6</phrase></textobject>
  </mediaobject>
</figure>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>Add the GWT module generated by our archetype to your project by clicking the <emphasis>Add&#8230;</emphasis> button in the <emphasis>Web Toolkit</emphasis> options dialog. There should only be one available module in your application, named <emphasis>App</emphasis> . Select and add this.</simpara>
      
    </listitem>
  
</orderedlist>
<figure>
<title>TODO InformalFigure image title empty</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/Import7.PNG"/>
    </imageobject>
    <textobject><phrase>Import7</phrase></textobject>
  </mediaobject>
</figure>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>On the left hand side of the <emphasis>Properties</emphasis> dialog box, you should see a <emphasis>Web Application</emphasis> section under the <emphasis>Google</emphasis> tree item. It should be the option directly above the <emphasis>Web Toolkit</emphasis> menu. Select this.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>In the <emphasis>Properties for firestorm-app</emphasis> window:</simpara>
      

<itemizedlist>
  
    <listitem>
      <simpara>Check the box <emphasis>This project has a WAR directory</emphasis> .</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>In the <emphasis>WAR directory</emphasis> field, enter <literal><phrase role="code">src/main/webapp</phrase></literal> or click <emphasis>Browse&#8230;</emphasis> to navigate to the <literal><phrase role="code">webapp</phrase></literal> directory.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Check the box <emphasis>Launch and deploy from this directory</emphasis> When done, click <emphasis>OK</emphasis> .</simpara>
      
    </listitem>
  
</itemizedlist>


      
    </listitem>
  
</orderedlist>
<figure>
<title>TODO InformalFigure image title empty</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/Import8.PNG"/>
    </imageobject>
    <textobject><phrase>Import8</phrase></textobject>
  </mediaobject>
</figure>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>You may be presented with a dialog warning you that GWT features will require the re-opening of already open editors. Simply click <emphasis>Re-open Java editors</emphasis> .</simpara>
      
    </listitem>
  
</orderedlist>
<figure>
<title>TODO InformalFigure image title empty</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/Import9.PNG"/>
    </imageobject>
    <textobject><phrase>Import9</phrase></textobject>
  </mediaobject>
</figure>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>From the main workspace, click on the <emphasis>Run As&#8230;</emphasis> menu. It is indicated by a green play icon, pictured in the image below. From the menu, select <emphasis>Run As&#8230;</emphasis> &#8594; <emphasis>Web Application</emphasis> .</simpara>
      
    </listitem>
  
</orderedlist>
<figure>
<title>TODO InformalFigure image title empty</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/Import10.PNG"/>
    </imageobject>
    <textobject><phrase>Import10</phrase></textobject>
  </mediaobject>
</figure>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>You will be presented with the <emphasis>HTML Page Selection</emphasis> dialog. This dialog is used for choosing which HTML page to load in order to start the application. Select <literal><phrase role="code">App.html</phrase></literal> , then click <emphasis>OK</emphasis> .</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The application should start and you should see the startup log display the Weld and Errai bootstrapping information. When it is done bootstrapping, which may take a few moments, you should be presented with a panel with a URL link in order to launch your application. Double-click on this link.</simpara>
      
    </listitem>
  
</orderedlist>
<figure>
<title>TODO InformalFigure image title empty</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/Import13.PNG"/>
    </imageobject>
    <textobject><phrase>Import13</phrase></textobject>
  </mediaobject>
</figure>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>Your web browser should load and you should see the same application we launched from the command line in the previous section.</simpara>
      
    </listitem>
  
</orderedlist>
<figure>
<title>TODO InformalFigure image title empty</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493220/Import14.PNG"/>
    </imageobject>
    <textobject><phrase>Import14</phrase></textobject>
  </mediaobject>
</figure>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>That&#8217;s it! You&#8217;ve successfully imported your Errai project into Eclipse. Now, on to <link linkend="sid-54493502">coding</link> !</simpara>
      
    </listitem>
  
</orderedlist>
</section>
</section>
<section id="sid-54493502">
<title>A Gentle Introduction to CDI</title>
<important>
<title>This section is based on the previous guide sections</title>
<simpara>The project you created and setup in the previous two sections (ERRAI:Create your Project and ERRAI:Configuring your project for Eclipse) will be used as the basis for this section. So if you have not read them, do so now.</simpara>
</important>
<simpara>Errai CDI as its namesake implies is based on, and is in fact, a partial implementation of the CDI (Contexts and Dependency Injection) specification. Errai CDI covers <emphasis>most</emphasis> of the programming model but omits the CDI SPI, instead replacing it with it a custom set of APIs which are more appropriate for the client programming model of Errai.</simpara>
<simpara>These differences aside, using Errai CDI in conjunction with CDI on the server will provide you with a uniform programming model across the client and server code of your application.</simpara>
<simpara>This guide does not assume any past experience with CDI. However, you may wish to consider reading the the <ulink url="http://docs.jboss.org/weld/reference/1.1.5.Final/en-US/html/">Weld Documentation</ulink> in addition to this guide.</simpara>
<section id="sid-54493502_AGentleIntroductiontoCDI-YourFirstBean">
<title>Your First Bean</title>
<simpara>A bean in CDI is merely a POJO (Plain Old Java Object), for the most part. In the context of CDI, any plain, default constructable class is a member of the <emphasis>dependent scope</emphasis> . Don&#8217;t worry too much about what that means for now. Let&#8217;s just go ahead and make one:</simpara>
<screen>
public class Foo {
  public String getName() {
    return "Mr. Foo";
  }
}
</screen>
<simpara>That was an easy, if uninteresting, exercise. But despite this class' worthy distinction as a dependent-scoped bean, it&#8217;s actually quite a useless dependent scope beaned. Well, maybe not so much useless as it is unused.</simpara>
<simpara>Well, how would we use this bean? To answer that question we&#8217;re going to need to introduce the concept of scopes in more detail.</simpara>
</section>
<section id="sid-54493502_AGentleIntroductiontoCDI-Scopes">
<title>Scopes</title>
<simpara>Scopes, put simply, are the context within which beans live. Some scopes are short-lived and some are long-lived. For instance, there are beans which you may only want to create during a request, and beans which you want to live for as long as the application is running.</simpara>
<simpara>It turns out that CDI includes a set of default scopes which represent these very things.</simpara>
<simpara>We&#8217;ll start by taking a look at the <emphasis>application scope</emphasis> , which is lovingly represented by the annotation <literal><phrase role="code">@ApplicationScoped</phrase></literal> . An application-scoped bean is a bean which will live for the entire duration of the application. In this sense, it is essentially like a singleton. And it&#8217;s generally okay to think of it in that way.</simpara>
<simpara>So let&#8217;s declare an application-scoped bean:</simpara>
<screen>
@ApplicationScoped
public class Bar {
  public String getName() {
    return "Mr. Bar";
  }
}
</screen>
<simpara>That was <emphasis>almost</emphasis> as easy as making the last bean. The difference between this bean and the last, is <literal><phrase role="code">Bar</phrase></literal> will actually be instantiated by the container automatically, and <literal><phrase role="code">Foo</phrase></literal> will not.</simpara>
<simpara>So what can we do with <literal><phrase role="code">Foo</phrase></literal> ? Well, let&#8217;s go ahead and get familiar with dependency injection, shall we?</simpara>
<screen>
@ApplicationScoped
public class Bar {
  @Inject Foo foo;

  public String getName() {
    return "Mr. Bar";
  }
}
</screen>
<simpara>We have added a field of the type <literal><phrase role="code">Foo</phrase></literal> which we declared earlier, and we have annotated it with <literal><phrase role="code">javax.inject.Inject</phrase></literal> . This tells the container to inject an instance of <literal><phrase role="code">Foo</phrase></literal> into our bean. Since our <literal><phrase role="code">Foo</phrase></literal> bean is of the dependent scope, the bean manager will actually create a <emphasis>new</emphasis> instance of <literal><phrase role="code">Foo</phrase></literal> and pass it in.</simpara>
<simpara>This scope of the newly instantiated <literal><phrase role="code">Foo</phrase></literal> is <emphasis>dependent</emphasis> on the scope that it was injected into. In this case, the application scope. On the other hand, if we were to turn around an inject <literal><phrase role="code">Bar</phrase></literal> into <literal><phrase role="code">Foo</phrase></literal> , the behaviour is quite different.</simpara>
<screen>
public class Foo {
  @Inject Bar bar;

  public String getName() {
    return "Mr. Foo";
  }
}
</screen>
<simpara>Here, every time a new instance of <literal><phrase role="code">Foo</phrase></literal> is created, the <emphasis>same</emphasis> instance of <literal><phrase role="code">Bar</phrase></literal> will be injected. That is to say: this pseudo-code assertion is now always true:</simpara>
<screen>
assert fooInstance.bar.foo == fooInstance
</screen>
<simpara><emphasis>Note</emphasis> : This identity check will not <emphasis>actually</emphasis> be true at runtime due to the need to proxy the class in this scenario. But it is true, that <literal><phrase role="code">fooInstance</phrase></literal> and <literal><phrase role="code">fooInstance.bar.foo</phrase></literal> both point to the same <emphasis>underlying</emphasis> bean instance.</simpara>
<simpara>In the case of an Errai application, there are a bunch of application scoped beans which come built-in for common services like _ <emphasis>ErraiBus</emphasis> _. Thus, in an Errai application which uses the message bus, we can inject a handle to the <literal><phrase role="code">MessageBus</phrase></literal> service into any of our beans. Let&#8217;s go ahead and do that in our <literal><phrase role="code">Bar</phrase></literal> class:</simpara>
<screen>
@ApplicationScoped
public class Bar {
  @Inject Foo foo;
  @Inject MessageBus bus;

  public String getName() {
    return "Mr. Bar";
  }
}
</screen>
<simpara>If working with dependency injection is new to you, then this is where you&#8217;ll start seeing some practical benefit. When you need a common service in your client code, you ask the container for it, by <emphasis>injecting</emphasis> it. This frees you of worrying about the proper APIs to use in order to get access to a service; we need to use the message bus in our <literal><phrase role="code">Bar</phrase></literal> bean, and so we inject it.</simpara>
<simpara>Now that we&#8217;re getting the gist of how dependency injection works, let&#8217;s go back to the sample project we created with the Maven archetype in the last section of this guide.</simpara>
<simpara>In the <literal><phrase role="code">App</phrase></literal> class that was created, there may be two peculiarities sticking out to you:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>The bean&#8217;s scope is <literal><phrase role="code">@EntryPoint</phrase></literal> ; and 2. we&#8217;re injecting the type <literal><phrase role="code">Event&lt;HelloMessage&gt;</phrase></literal> into our bean.</simpara>
      
    </listitem>
  
</orderedlist>
<simpara>The <literal><phrase role="code">@EntryPoint</phrase></literal> annotation is an annotation which provides a an analogue to the GWT EntryPoint concept within the context of CDI in Errai. Basically you want to think of <literal><phrase role="code">@EntryPoint</phrase></literal> beans as the Errai CDI-equalivalent of <literal><phrase role="code">main()</phrase></literal> methods. But as of Errai 2.2., that might actually be going a little far. In fact, you might be asking what is the real difference between <literal><phrase role="code">@ApplicationScoped</phrase></literal> and <literal><phrase role="code">@EntryPoint</phrase></literal> in practice. The short answer is: nothing.</simpara>
<simpara>When Errai IOC, the technology which powers Errai&#8217;s client-side CDI, was first built, it lacked the concept of scopes. To create entry point objects into the application which would automatically run, this annotation was added. The reason it hasn&#8217;t been deprecated is for two reasons: we still support plain old Errai IOC, and further, we intend to add more useful semantics to <literal><phrase role="code">@EntryPoint</phrase></literal> in Errai 3.0.</simpara>
<simpara>The second item brings us to the next concept: CDI Events.</simpara>
</section>
<section id="sid-54493502_AGentleIntroductiontoCDI-CDIEventing">
<title>CDI Eventing</title>
<note>
<title>Launching maven the first time</title>
<simpara>Please note, that when launching maven the first time on your machine, it will fetch all dependencies from a central repository. This may take a while, because it includes downloading large binaries like GWT SDK. However, subsequent builds are not required to go through this step and will be much faster.</simpara>
</note>
</section>
</section>
</section>
</chapter>
<chapter id="sid-5931263">
<title>Messaging</title>
<simpara>This section covers the core messaging concepts of the ErraiBus messaging framework.</simpara>
<simpara>ErraiBus provides a straight-forward approach to a complex problem space. Providing common APIs across the client and server, developers will have no trouble working with complex messaging scenarios from building instant messaging clients, stock tickers, to monitoring instruments. There&#8217;s no more messing with RPC APIs, or unweildy AJAX or COMET frameworks. We&#8217;ve built it all in to one, consice messaging framework. It&#8217;s single-paradigm, and it&#8217;s fun to work with.</simpara>
<section id="sid-5931265">
<title>Messaging Overview</title>
<simpara>It&#8217;s important to understand the concept of how messaging works in ErraiBus. Service endpoints are given string-based names that are referenced by message senders. There is no difference between sending a message to a client-based service, or sending a message to a server-based service. In fact, a service of the same name may co-exist on both the client and the server and both will receive all messages bound for that service name, whether they are sent from the client or from the server.</simpara>
<simpara>Services are lightweight in ErraiBus, and can be declared liberally and extensively within your application to provide a message-based infrastructure for your web application. It can be tempting to think of ErraiBus simply as a client-server communication platform, but there is a plethora of possibilities for using ErraiBus purely with the GWT client context, such as a way to advertise and expose components dynamically, to get around the lack of reflection in GWT.</simpara>
<simpara>In fact, ErraiBus was originally designed to run completely within the client but quickly evolved into having the capabilities it now has today. So keep that in mind when you run up against problems in the client space that could benefit from runtime federation.</simpara>
</section>
<section id="sid-5931280">
<title>Messaging API Basics</title>
<simpara>The MessageBuilder is the heart of the messaging API in ErraiBus. It provides a fluent / builder API, that is used for constructing messages. All three major message patterns can be constructed from the <literal><phrase role="code">MessageBuilder</phrase></literal> .</simpara>
<simpara>Components that want to receive messages need to implement the <literal><phrase role="code">MessageCallback</phrase></literal> interface.</simpara>
<simpara>But before we dive into the details, let&#8217;s look at some use cases first.</simpara>
<section id="sid-5931280_MessagingAPIBasics-SendingMessageswiththeClientBus">
<title>Sending Messages with the Client Bus</title>
<simpara>In order to send a message from a client you need to create a <literal><phrase role="code">Message</phrase></literal> and send it through an instance of <literal><phrase role="code">MessageBus</phrase></literal> . In this simple example we send it to the subject <emphasis>HelloWorldService</emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class HelloWorld implements EntryPoint {

  // Get an instance of the RequestDispatcher
  private RequestDispatcher dispatcher = ErraiBus.getDispatcher();

  public void onModuleLoad() {
    Button button = new Button("Send message");

    button.addClickHandler(new ClickHandler() {
      public void onClick(ClickEvent event) {
        // Send a message to the 'HelloWorldService'.
        MessageBuilder.createMessage()
          .toSubject("HelloWorldService") // (1)
          .signalling() // (2)
          .noErrorHandling() // (3)
          .sendNowWith(dispatcher); // (4)
        });

        [...]
      }
   }
}
</programlisting>
<simpara>In the above example we build and send a message every time the button is clicked. Here&#8217;s an explanation of what&#8217;s going on as annotated above:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>We specify the subject we wish to send a message to. In this case, " <literal><phrase role="code">HelloWorldService</phrase></literal> ".</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>We indicate that we wish to only signal the service, meaning, that we&#8217;re not sending a qualifying command to the service. For information on this, read the section on <emphasis>Protocols</emphasis> .</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>We indicate that we do not want to provide an <literal><phrase role="code">ErrorCallback</phrase></literal> to deal with errors for this message.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>We transmit the message by providing an instance to the <literal><phrase role="code">RequestDispatcher</phrase></literal></simpara>
      
    </listitem>
  
</orderedlist>
<important>
<simpara>An astute observer will note that access to the <literal><phrase role="code">RequestDispatcher</phrase></literal> differs within client code and server code. Because the client code does not run within a container, access to the <literal><phrase role="code">RequestDispatcher</phrase></literal> and <literal><phrase role="code">MessageBus</phrase></literal> is statically accessed using the <literal><phrase role="code">ErraiBus.get()</phrase></literal> and <literal><phrase role="code">ErraiBus.getDispatcher()</phrase></literal> methods. The server-side code, conversely, runs inside a dependency container for managing components. See the section on Errai IOC and Errai CDI for using ErraiBus from a client-side container.</simpara>
<simpara>When using Errai IOC or CDI, you can also use the Sender&lt;T&gt; interface to send messages.</simpara>
</important>
</section>
<section id="sid-5931280_MessagingAPIBasics-ReceivingMessagesontheServerBus%2FServerServices">
<title>Receiving Messages on the Server Bus / Server Services</title>
<simpara>Every message has a sender and at least one receiver. A receiver is as it sounds&#8212;it receives the message and does something with it. Implementing a receiver (also referred to as a service) is as simple as implementing our standard MessageCallback interface, which is used pervasively across, both client and server code. Let&#8217;s begin with server side component that receives messages:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Service
  public class HelloWorldService implements MessageCallback {
    public void callback(Message message) {
      System.out.println("Hello, World!");
    }
  }
</programlisting>
<simpara>He we declare an extremely simple service. The <literal><phrase role="code">@Service</phrase></literal> annotation provides a convenient, meta-data based way of having the bus auto-discover and deploy the service.</simpara>
</section>
<section id="sid-5931280_MessagingAPIBasics-SendingMessageswiththeServerBus">
<title>Sending Messages with the Server Bus</title>
<simpara>In the following example we extend our server side component to reply with a message when the callback method is invoked. It will create a message and address it to the subject ' <literal><phrase role="code">HelloWorldClient</phrase></literal> ':</simpara>
<programlisting language="java" linenumbering="unnumbered">@Service
public class HelloWorldService implements MessageCallback {

  private RequestDispatcher dispatcher;

  @Inject
  public HelloWorldService(RequestDispatcher dispatcher) {
    dispatcher = dispatcher;
  }

  public void callback(CommandMessage message) {
    // Send a message to the 'HelloWorldClient'.
    MessageBuilder.createMessage()
      .toSubject("HelloWorldClient") // (1)
      .signalling()                  // (2)
      .with("text", "Hi There")      // (3)
      .noErrorHandling()             // (4)
      .sendNowWith(dispatcher);      // (5)
    });
  }
}
</programlisting>
<simpara>The above example shows a service which sends a message in response to receiving a message. Here&#8217;s what&#8217;s going on:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>We specify the subject we wish to send a message to. In this case, " <literal><phrase role="code">HelloWorldClient</phrase></literal> ". We are sending this message to all clients which are listening in on this subject. For information on how to communicate with a single client, see Section 2.6.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>We indicate that we wish to only signal the service, meaning that we&#8217;re not sending a qualifying command to the service. For information on this, read the section on Protocols.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>We add a message part called "text" which contains the value "Hi there".</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>We indicate that we do not want to provide an <literal><phrase role="code">ErrorCallback</phrase></literal> to deal with errors for this message.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>We transmit the message by providing an instance of the <literal><phrase role="code">RequestDispatcher</phrase></literal> .</simpara>
      
    </listitem>
  
</orderedlist>
</section>
<section id="sid-5931280_MessagingAPIBasics-ReceivingMessagesontheClientBus%2FClientServices">
<title>Receiving Messages on the Client Bus/ Client Services</title>
<simpara>Messages can be received asynchronously and arbitriraily by declaring callback services within the client bus. As ErraiBus maintains an open COMET channel at all times, these messages are delivered in real time to the client as they are sent. This provides built-in push messaging for all client services.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class HelloWorld implements EntryPoint {

  private MessageBus bus = ErraiBus.get();

  public void onModuleLoad() {
     [...]

     /*
      * Declare a service to receive messages on the subject
      * "BroadcastReceiver".
      */
     bus.subscribe("BroadcastReceiver", new MessageCallback() {
       public void callback(CommandMessage message) {
         /*
          * When a message arrives, extract the "text" field and
          * do something with it
          */
          String messageText = message.get(String.class, "text");
        }
     });

     [...]
  }
}
</programlisting>
<simpara>In the above example, we declare a new client service called <literal><phrase role="code">"BroadcastReceiver"</phrase></literal> which can now accept both local messages and remote messages from the server bus. The service will be available in the client to receive messages as long the client bus is and the service is not explicitly de-registered.</simpara>
</section>
<section id="sid-5931280_MessagingAPIBasics-LocalServices">
<title>Local Services</title>
<simpara>On the client or the server, you can create a local receiver which only receives messages that originated on the local bus. A local server-side service only receives messages that originate on that server, and a local client-side service only receives messages that originated on that client.</simpara>
<simpara>To create a local receiver using the declarative API, use the <literal><phrase role="code">@Local</phrase></literal> annotation in conjunction with <literal><phrase role="code">@Service</phrase></literal> :</simpara>
<programlisting language="java" linenumbering="unnumbered">@Local
@Service
  public class HelloIntrovertService implements MessageCallback {
    public void callback(Message message) {
      System.out.println("Hello, me!");
    }
  }</programlisting>
<simpara>To create a local receiver using through programmatic service registration, use the <literal><phrase role="code">subscribeLocal()</phrase></literal> method in place of <literal><phrase role="code">subscribe()</phrase></literal> :</simpara>
<programlisting language="java" linenumbering="unnumbered">public void registerLocalService(MessageBus bus) {
  bus.subscribeLocal("LocalBroadcastReceiver", new MessageCallback() {
    public void callback(Message message) {
       String messageText = message.get(String.class, "text");
     }
  });
}</programlisting>
<simpara>Both examples above work in client- and server-side code.</simpara>
</section>
</section>
<section id="sid-5931284">
<title>Single-Response Conversations &amp; Pseudo-Synchronous Messaging</title>
<simpara>It is possible to contruct a message and a default response handler as part of the <literal><phrase role="code">MessageBuilder</phrase></literal> API. It should be noted, that multiple replies will not be possible and will result an exception if attempted. Using this aspect of the API is very useful for doing simple psuedo-synchronous conversive things.</simpara>
<simpara>You can do this by specifying a <literal><phrase role="code">MessageCallback</phrase></literal> using the <literal><phrase role="code">repliesTo()</phrase></literal> method in the <literal><phrase role="code">MessageBuilder</phrase></literal> API after specifying the error handling of the message.</simpara>
<programlisting language="java" linenumbering="unnumbered">MessageBuilder.createMessage()
  .toSubject("ConversationalService").signalling()
  .with("SomeField", someValue)
  .noErrorHandling()
  .repliesTo(new MessageCallback() {
    public void callback(Message message) {
      System.out.println("I received a response");
    }
   })</programlisting>
<simpara>See the next section on how to build conversational services that can respond to such messages.</simpara>
</section>
<section id="sid-5931289">
<title>Sender Inferred Subjects</title>
<simpara>It is possible for the sender to infer, to whatever conversational service it is calling, what subject it would like the reply to go to. This is accomplished by utilizing the standard <literal><phrase role="code">MessageParts.ReplyTo</phrase></literal> message part. Using this methodology for building conversations is generally encouraged.</simpara>
<simpara>Consider the following client side code:</simpara>
<programlisting language="java" linenumbering="unnumbered">  MessageBuilder.createMessage()
    .toSubject("ObjectService").signalling()
    .with(MessageParts.ReplyTo, "ClientEndpoint")
    .noErrorHandling().sendNowWith(dispatcher);</programlisting>
<simpara>And the conversational code on the server (for service <emphasis>ObjectService</emphasis> ):</simpara>
<programlisting language="java" linenumbering="unnumbered">  MessageBuilder.createConversation(message)
    .subjectProvided().signalling()
    .with("Records", records)
    .noErrorHandling().reply();</programlisting>
<simpara>In the above examples, assuming that the latter example is inside a service called " <literal><phrase role="code">ObjectService</phrase></literal> " and is referencing the incoming message that was sent in the former example, the message created will automatically reference the <literal><phrase role="code">ReplyTo</phrase></literal> subject that was provided by the sender, and send the message back to the subject desired by the client on the client that sent the message.</simpara>
</section>
<section id="sid-5931291">
<title>Broadcasting</title>
<simpara>Broadcasting messages to all clients listening on a specific subject is quite simple and involves nothing more than forgoing use of the reply API. For instance:</simpara>
<programlisting language="java" linenumbering="unnumbered">MessageBuilder.createMessage().
    .toSubject("MessageListener")
    .with("Text", "Hello, from your overlords in the cloud")
    .noErrorHandling().sendGlobalWith(dispatcher);</programlisting>
<simpara>If sent from the server, all clients currently connected, who are listening to the subject <literal><phrase role="code">"MessageListener"</phrase></literal> will receive the message. It&#8217;s as simple as that.</simpara>
</section>
<section id="sid-5931293">
<title>Client-to-Client Communication</title>
<simpara>Communication from one client to another client is not directly possible within the bus federation, by design. This isn&#8217;t to say that it&#8217;s not possible. But one client cannot see a service within the federation of another client. We institute this limitation as a matter of basic security. But many software engineers will likely find the prospects of such communication appealing, so this section will provide some basic pointers on how to go about accomplishing it.</simpara>
<section id="sid-5931293_Client-to-ClientCommunication-RelayServices">
<title>Relay Services</title>
<simpara>The essential architectural thing you&#8217;ll need to do is create a relay service that runs on the server. Since a service advertised on the server is visible to all clients and all clients are visible to the server, you might already see where we&#8217;re going with this.</simpara>
<simpara>By creating a service on the server which accepts messages from clients, you can create a simple protocol on-top of the bus to enable quasi peer-to-peer communication. (We say quasi, because it still needs to be routed through the server)</simpara>
<simpara>While you can probably imagine simply creating a broadcast-like service which accepts a message from one client and broadcasts it to the rest of the world, it may be less clear how to go about routing from one particular client to another particular client, so we&#8217;ll focus on that problem. This is covered in <link linkend="sid-5931301">the next chapter</link>.</simpara>
</section>
</section>
<section id="sid-5931301">
<title>Message Routing Information</title>
<simpara>Every message that is sent between a local and remote (or server and client) buses contain session routing information. This information is used by the bus to determine what outbound queues to use to deliver the message to, so they will reach their intended recipients. It is possible to manually specify this information to indicate to the bus, where you want a specific message to go.</simpara>
<simpara>You can obtain the <literal><phrase role="code">SessionID</phrase></literal> directly from a <literal><phrase role="code">Message</phrase></literal> by getting the <literal><phrase role="code">QueueSession</phrase></literal> resource:</simpara>
<programlisting language="java" linenumbering="unnumbered">   QueueSession sess = message.getResource(QueueSession.class, Resources.Session.name());
   String sessionId = sess.getSessionId();</programlisting>
<simpara>You can extract the <literal><phrase role="code">SessionID</phrase></literal> from a message so that you may use it for routing by obtaining the <literal><phrase role="code">QueueSession</phrase></literal> resource from the <literal><phrase role="code">Message</phrase></literal> . For example:</simpara>
<programlisting language="java" linenumbering="unnumbered">...
  public void callback(Message message) {
   QueueSession sess = message.getResource(QueueSession.class, Resources.Session.name());
   String sessionId = sess.getSessionId();

    // Record this sessionId somewhere.
    ...
  }</programlisting>
<simpara>The <literal><phrase role="code">SessionID</phrase></literal> can then be stored in a medium, say a Map, to cross-reference specific users or whatever identifier you wish to allow one client to obtain a reference to the specific <literal><phrase role="code">SessionID</phrase></literal> of another client. In which case, you can then provide the <literal><phrase role="code">SessionID</phrase></literal> as a MessagePart to indicate to the bus where you want the message to go.</simpara>
<programlisting language="java" linenumbering="unnumbered">  MessageBuilder.createMessage()
    .toSubject("ClientMessageListener")
    .signalling()
    .with(MessageParts.SessionID, sessionId)
    .with("Message", "We're relaying a message!")
    .noErrorHandling().sendNowWith(dispatcher);</programlisting>
<simpara>By providing the <literal><phrase role="code">SessionID</phrase></literal> part in the message, the bus will see this and use it for routing the message to the relevant queue.</simpara>
<simpara>It may be tempting however, to try and include destination <literal><phrase role="code">SessionIDs</phrase></literal> at the client level, assuming that this will make the infrastructure simpler. But this will not achieve the desired results, as the bus treats <literal><phrase role="code">SessionIDs</phrase></literal> as transient. Meaning, the <literal><phrase role="code">SessionID</phrase></literal> information is not ever transmitted from bus-to-bus, and therefore is only directly relevant to the proximate bus.</simpara>
</section>
<section id="sid-5931306">
<title>Handling Errors</title>
<simpara>Asynchronous messaging necessitates the need for asynchronous error handling. Luckily, support for handling errors is built directly into the <literal><phrase role="code">MessageBuilder</phrase></literal> API, utilizing the <literal><phrase role="code">ErrorCallback</phrase></literal> interface. In the examples shown in previous exceptions, error handing has been glossed over with aubiquitous usage of the <literal><phrase role="code">noErrorHandling()</phrase></literal> method while building messaging. We chose to require the explicit use of such a method to remind developers of the fact that they are responsible for their own error handling, requiring you to explicitly make the decision to forego handling potential errors.</simpara>
<simpara>As a general rule, you should <emphasis>always handle your errors</emphasis> . It will lead to faster and quicker identification of problems with your applications if you have error handlers, and generally help you build more robust code.</simpara>
<programlisting language="java" linenumbering="unnumbered">MessageBuilder.createMessage()
    .toSubject("HelloWorldService")
    .signalling()
    .with("msg", "Hi there!")
    .errorsHandledBy(new ErrorCallback() {
      public boolean error(Message message, Throwable throwable) {
        throwable.printStackTrace();
          return true;
      }
    })
    .sendNowWith(dispatcher);</programlisting>
<simpara>The addition of error handling at first may put off developers as it makes code more verbose and less-readable. This is nothing that some good practice can&#8217;t fix. In fact, you may find cases where the same error handler can appropriately be shared between multiple different calls.</simpara>
<programlisting language="java" linenumbering="unnumbered">ErrorCallback error = new ErrorCallback() {
  public boolean error(Message message, Throwable throwable) {
    throwable.printStackTrace();
    return true;
  }
}

MessageBuilder.createMessage()
  .toSubject("HelloWorldService")
  .signalling()
  .with("msg", "Hi there!")
  .errorsHandledBy(error)
  .sendNowWith(dispatcher);
</programlisting>
<simpara>The error handler is required to return a <literal><phrase role="code">boolean</phrase></literal> value. This is to indicate whether or not Errai should perform the default error handling actions it would normally take during a failure. You will almost always want to return <literal><phrase role="code">true</phrase></literal> here, unless you are trying to explicitly surpress some undesirably activity by Errai, such as automatic subject-termination in conversations. But this is almost never the case.</simpara>
<section id="sid-5931306_HandlingErrors-Handlingglobalmessagetransporterrors">
<title>Handling global message transport errors</title>
<simpara>You may need to detect problems which occur on the bus at runtime. The client bus API provides a facility for doing this in the <literal><phrase role="code">org.jboss.errai.bus.client.framework.ClientMessageBus</phrase></literal> using the <literal><phrase role="code">addTransportErrorHandler()</phrase></literal> method.</simpara>
<simpara>A <literal><phrase role="code">TransportErrorHandler</phrase></literal> is an interface which you can use to define error handling behavior in the event of a transport problem.</simpara>
<simpara>For example:</simpara>
<programlisting language="java" linenumbering="unnumbered">messageBus.addTransportErrorHandler(new TransportErrorHandler() {
  public void onError(TransportError error) {
    // error handling code.
  }
});
</programlisting>
<simpara>The <literal><phrase role="code">TransportError</phrase></literal> interface represents the details of an an error from the bus. It contains a set of methods which can be used for determining information on the initial request which triggered the error, if the error occurred over HTTP or WebSockets, status code information, etc. See the JavaDoc for more information.</simpara>
</section>
</section>
<section id="sid-5931309">
<title>Asynchronous Message Tasks</title>
<simpara>In some applications, it may be necessary or desirable to delay transmission of, or continually stream data to a remote client or group of clients (or from a client to the server). In cases like this, you can utilize the <literal><phrase role="code">replyRepeating()</phrase></literal> , <literal><phrase role="code">replyDelayed()</phrase></literal> , <literal><phrase role="code">sendRepeating()</phrase></literal> and <literal><phrase role="code">sendDelayed()</phrase></literal> methods in the <literal><phrase role="code">MessageBuilder</phrase></literal> .</simpara>
<simpara>Delayed TasksSending a task with a delay is straight forward. Simply utilize the appropriate method (either <literal><phrase role="code">replyDelayed()</phrase></literal> or <literal><phrase role="code">sendDelayed()</phrase></literal> ).</simpara>
<programlisting language="java" linenumbering="unnumbered">  MessageBuilder.createConversation(msg)
    .toSubject("FunSubject")
    .signalling()
    .noErrorHandling()
    .replyDelayed(TimeUnit.SECONDS, 5); // sends the message after 5 seconds.</programlisting>
<simpara>or</simpara>
<programlisting language="java" linenumbering="unnumbered">   MessageBuilder.createMessage()
     .toSubject("FunSubject")
     .signalling()
     .noErrorHandling()
     .sendDelayed(requestDispatcher, TimeUnit.SECONDS, 5); // sends the message after 5 seconds.</programlisting>
</section>
<section id="sid-5931311">
<title>Repeating Tasks</title>
<simpara>A repeating task is sent using one of the MessageBuilder&#8217;s <literal><phrase role="code">repeatXXX()</phrase></literal> methods. The task will repeat indefinitely until cancelled (see next section).</simpara>
<programlisting language="java" linenumbering="unnumbered">  MessageBuilder.createMessage()
    .toSubject("FunSubject")
    .signalling()
    .withProvided("time", new ResourceProvider&lt;String&gt;() {
       SimpleDateFormat fmt = new SimpleDateFormat("hh:mm:ss");

       public String get() {
         return fmt.format(new Date(System.currentTimeMillis());
       }
     }
     .noErrorHandling()
     .sendRepeatingWith(requestDispatcher, TimeUnit.SECONDS, 1); //sends a message every 1 second</programlisting>
<simpara>The above example sends a message very 1 second with a message part called <literal><phrase role="code">"time"</phrase></literal> , containing a formatted time string. Note the use of the <literal><phrase role="code">withProvided()</phrase></literal> method; a provided message part is calculated at the time of transmission as opposed to when the message is constructed.</simpara>
<simpara>Cancelling an Asynchronous TaskA delayed or repeating task can be cancelled by calling the <literal><phrase role="code">cancel()</phrase></literal> method of the <literal><phrase role="code">AsyncTask</phrase></literal> instance which is returned when creating a task. Reference to the AsyncTask object can be retained and cancelled by any other thread.</simpara>
<programlisting language="java" linenumbering="unnumbered">AsyncTask task = MessageBuilder.createConversation(message)
  .toSubject("TimeChannel").signalling()
  .withProvided(TimeServerParts.TimeString, new ResourceProvider&lt;String&gt;() {
     public String get() {
       return String.valueOf(System.currentTimeMillis());
     }
   }).defaultErrorHandling().replyRepeating(TimeUnit.MILLISECONDS, 100);

    ...

  // cancel the task and interrupt it's thread if necessary.
  task.cancel(true);</programlisting>
</section>
<section id="sid-5931315">
<title>Queue Sessions</title>
<simpara>The ErraiBus maintains it&#8217;s own seperate session management on-top of the regular HTTP session management. While the queue sessions are tied to, and dependant on HTTP sessions for the most part (meaning they die when HTTP sessions die), they provide extra layers of session tracking to make dealing with complex applications built on Errai easier.</simpara>
<section id="sid-5931315_QueueSessions-Lifecycle">
<title>Lifecycle</title>
<simpara>The lifescyle of a session is bound by the underlying HTTP session. It is also bound by activity thresholds. Clients are required to send heartbeat messages every once in a while to maintain their sessions with the server. If a heartbeat message is not received after a certain period of time, the session is terminated and any resources are deallocated.</simpara>
</section>
<section id="sid-5931315_QueueSessions-Scopes">
<title>Scopes</title>
<simpara>One of the things Errai offers is the concept of session and local scopes.</simpara>
<section id="sid-5931315_QueueSessions-SessionScope">
<title>Session Scope</title>
<simpara>A session scope is scoped across all instances of the same session. When a session scope is used, any parameters stored will be accessible and visible by all browser instances and tabs.</simpara>
<simpara>The SessionContext helper class is used for accessing the session scope.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class TestService implements MessageCallback {
  public void callback(final Message message) {
    // obtain a reference to the session context by referencing the incoming message.
    SessionContext injectionContext = SessionContext.get(message);

    // set an attribute.
    injectionContext.setAttribute("MyAttribute", "Foo");
  }
}</programlisting>
</section>
<section id="sid-5931315_QueueSessions-LocalScope">
<title>Local Scope</title>
<simpara>A local scope is scoped to a single browser instance. But not to a single session.</simpara>
<simpara>In a browser a local scope would be confined to a tab or a window within a browser. You can store parameters inside a local scope just like with a session by using the <literal><phrase role="code">LocalContext</phrase></literal> helper class.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class TestService implements MessageCallback {
  public void callback(final Message message) {
    // obtain a reference to the local context by referencing the incoming message.
    LocalContext injectionContext = LocalContext.get(message);

   // set an attribute.
    injectionContext.setAttribute("MyAttribute", "Foo");
  }
}</programlisting>
</section>
</section>
</section>
<section id="sid-20938805">
<title>Client Logging and Error Handling</title>

</section>
<section id="sid-23036473">
<title>Wire Protocol (J.REP)</title>
<simpara>ErraiBus implements a JSON-based wire protocol which is used for the federated communication between different buses. The protocol specification encompasses a standard JSON payload structure, a set of verbs, and an object marshalling protocol. The protocol is named J.REP. Which stands for JSON Rich Event Protocol.</simpara>
<section id="sid-23036473_WireProtocol%28J.REP%29-PayloadStructure">
<title>Payload Structure</title>
<simpara>All wire messages sent across are assumed to be JSON arrays at the outermost element, contained in which, there are <emphasis>0..n</emphasis> messages. An empty array is considered a no-operation, but should be counted as activity against any idle timeout limit between federated buses.</simpara>
<example>
<title>Figure 1 - Example J.REP Payload</title>
<programlisting language="java" linenumbering="unnumbered">[
  {"ToSubject" : "SomeEndpoint", "Value" : "SomeValue" },
  {"ToSubject" : "SomeOtherEndpoint", "Value" : "SomeOtherValue"}
]</programlisting>
</example>
<simpara>In <emphasis>Figure 1</emphasis> , we see an example of a J.REP payload containing two messages. One bound for an endpoint named <literal><phrase role="code">"SomeEndpoint"</phrase></literal> and the other bound for the endpoint <literal><phrase role="code">"SomeOtherEndpoint"</phrase></literal> . They both include a payload element <literal><phrase role="code">"Value"</phrase></literal> which contain strings. Let&#8217;s take a look at the anatomy of an individual message.</simpara>
<example>
<title>Figure 2 - An J.REP Message</title>
<programlisting language="java" linenumbering="unnumbered">{
  "ToSubject" : "TopicSubscriber",
  "CommandType" : "Subscribe",
  "Value " : "happyTopic",
  "ReplyTo" : "MyTopicSubscriberReplyTo"
}</programlisting>
</example>
<simpara>The message shown in <emphasis>Figure 2</emphasis> shows a very vanilla J.REP message. The keys of the JSON Object represent individual <emphasis>message parts</emphasis> , with the values representing their corresponding values. The standard J.REP protocol encompasses a set of standard message parts and values, which for the purposes of this specification we&#8217;ll collectively refer to as the protocol verbs.</simpara>
<simpara>The following table describes all of the message parts that a J.REP capable client is expected to understand:</simpara>
<informaltable frame="all"
    rowsep="1" colsep="1">
  
  <tgroup cols="4">
    
    <colspec colname="col_1" colwidth="25*"/>
    
    <colspec colname="col_2" colwidth="25*"/>
    
    <colspec colname="col_3" colwidth="25*"/>
    
    <colspec colname="col_4" colwidth="25*"/>
    
    
    <thead>
      
      <row>
        
        <entry align="left" valign="top">Part</entry>
        
        <entry align="left" valign="top">Required</entry>
        
        <entry align="left" valign="top">JSON Type</entry>
        
        <entry align="left" valign="top">Description</entry>
        
      </row>
      
    </thead>
    
    <tbody>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">ToSubject</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>Yes</simpara></entry>
        
        <entry align="left" valign="top"><simpara>String</simpara></entry>
        
        <entry align="left" valign="top"><simpara>Specifies the subject within the bus, and its federation, which the message should be routed to.</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">CommandType</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>No</simpara></entry>
        
        <entry align="left" valign="top"><simpara>String</simpara></entry>
        
        <entry align="left" valign="top"><simpara>Specifies a command verb to be transmitted to the receiving subject. This is an optional part of a message contract, but is required for using management services</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">ReplyTo</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>No</simpara></entry>
        
        <entry align="left" valign="top"><simpara>String</simpara></entry>
        
        <entry align="left" valign="top"><simpara>Specifies to the receiver what subject it should reply to in response to this message.</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">Value</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>No</simpara></entry>
        
        <entry align="left" valign="top"><simpara>Any</simpara></entry>
        
        <entry align="left" valign="top"><simpara>A recommended but not required standard payload part for sending data to services</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">PriorityProcessing</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>No</simpara></entry>
        
        <entry align="left" valign="top"><simpara>Number</simpara></entry>
        
        <entry align="left" valign="top"><simpara>A processing order salience attribute. Messages which specify priority processing will be processed first if they are competing for resources with other messages in flight. Note: the current version of ErraiBus only supports two salience levels (0 and &gt;1). Any non-zero salience in ErraiBus will be given the same priority relative to 0 salience messages</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">ErrorMessage</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>No</simpara></entry>
        
        <entry align="left" valign="top"><simpara>String</simpara></entry>
        
        <entry align="left" valign="top"><simpara>An accompanying error message with any serialized exception</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">Throwable</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>No</simpara></entry>
        
        <entry align="left" valign="top"><simpara>Object</simpara></entry>
        
        <entry align="left" valign="top"><simpara>If applicable, an encoded object representing any remote exception that was thrown while dispatching the specified service</simpara></entry>
        
      </row>
      
    </tbody>
    
  </tgroup>
</informaltable>
<section id="sid-23036473_WireProtocol%28J.REP%29-BuiltinSubjects">
<title>Built-in Subjects</title>
<simpara>The table contains a list of reserved subject names used for facilitating things like bus management and error handling. A bus should never allow clients to subscribe to these subjects directly.</simpara>
<informaltable frame="all"
    rowsep="1" colsep="1">
  
  <tgroup cols="2">
    
    <colspec colname="col_1" colwidth="50*"/>
    
    <colspec colname="col_2" colwidth="50*"/>
    
    
    <thead>
      
      <row>
        
        <entry align="left" valign="top">Subject</entry>
        
        <entry align="left" valign="top">Description</entry>
        
      </row>
      
    </thead>
    
    <tbody>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">ClientBus</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>The self-hosted message bus endpoint on the client</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">ServerBus</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>The self-hosted message bus endpoint on the server</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">ClientBusErrors</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>The standard error receiving service for clients</simpara></entry>
        
      </row>
      
    </tbody>
    
  </tgroup>
</informaltable>
<simpara>As this table indicates, the bus management protocols in J.REP are accomplished using self-hosted services. See the section on <emphasis>Bus Management and Handshaking Protocols</emphasis> for details.</simpara>
</section>
</section>
<section id="sid-23036473_WireProtocol%28J.REP%29-MessageRouting">
<title>Message Routing</title>
<simpara>There is no real distinction in the J.REP protocol between communication with the server, versus communication with the client. In fact, it assumed from an architectural standpoint that there is no real distinction between a client and a server. Each bus participates in a flat-namespaced federation. Therefore, it is possible that a subject may be observed on both the server and the client.</simpara>
<simpara>One in-built assumption of a J.REP-compliant bus however, is that messages are routed within the auspices of session isolation. Consider the following diagram:</simpara>
<figure>
<title>Figure 3 - Topology of a J.REP Messaging Federation</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/23036473/FederationTopology.png"/>
    </imageobject>
    <textobject><phrase>FederationTopology</phrase></textobject>
  </mediaobject>
</figure>
<simpara>In <emphasis>Figure 3</emphasis> , is is possible for <emphasis>Client A</emphasis> to send messages to the subjects <emphasis>ServiceA</emphasis> and <emphasis>ServiceB</emphasis> . But it is not possible to address messages to <emphasis>ServiceC</emphasis> . Conversely, <emphasis>Client B</emphasis> can address messages to <emphasis>ServiceC</emphasis> and <emphasis>ServiceB</emphasis> , but not <emphasis>ServiceA</emphasis> .</simpara>
</section>
<section id="sid-23036473_WireProtocol%28J.REP%29-BusManagementandHandshakingProtocols">
<title>Bus Management and Handshaking Protocols</title>
<simpara>Federation between buses requires management traffic to negotiate connections and manage visibility of services between buses. This is accomplished through services named <literal><phrase role="code">ClientBus</phrase></literal> and <literal><phrase role="code">ServerBus</phrase></literal> which both implement the same protocol contracts which are defined in this section.</simpara>
<section id="sid-23036473_WireProtocol%28J.REP%29-ServerBusandClientBuscommands">
<title>ServerBus and ClientBus commands</title>
<simpara>Both bus services share the same management protocols, by implementing verbs (or commands) that perform different actions. These are specified in the protocol with the <literal><phrase role="code">CommandType</phrase></literal> message part. The following table describes these commands:</simpara>
<table frame="all"
    rowsep="1" colsep="1">
<title>Message Parts for Bus Commands:</title>
  
  <tgroup cols="3">
    
    <colspec colname="col_1" colwidth="33*"/>
    
    <colspec colname="col_2" colwidth="33*"/>
    
    <colspec colname="col_3" colwidth="33*"/>
    
    
    <thead>
      
      <row>
        
        <entry align="left" valign="top">Command / Verb</entry>
        
        <entry align="left" valign="top">Message Parts</entry>
        
        <entry align="left" valign="top">Description</entry>
        
      </row>
      
    </thead>
    
    <tbody>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">ConnectToQueue</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>N/A</simpara></entry>
        
        <entry align="left" valign="top"><simpara>The first message sent by a connecting client to begin the handshaking process.</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">CapabilitiesNotice</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">CapabilitiesFlags</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>A message sent by one bus to another to notify it of its capabilities during handshake (for instance long polling or websockets)</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">FinishStateSync</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>N/A</simpara></entry>
        
        <entry align="left" valign="top"><simpara>A message sent from one bus to another to indicate that it has now provided all necessary information to the counter-party bus to establish the federation. When both buses have sent this message to each other, the federation is considered active.</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">RemoteSubscribe</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">Subject</phrase></literal><emphasis>or</emphasis> <literal><phrase role="code">SubjectsList</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>A message sent to the remote bus to notify it of a service or set of services which it is capable of routing to.</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">RemoteUnsubscribe</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">Subject</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>A message sent to the remote bus to notify it that a service is no longer available.</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">Disconnect</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">Reason</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>A message sent to a server bus from a client bus to indicate that it wishes to disconnect and defederate. Or, when sent from the client to server, indicates that the session has been terminated.</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">SessionExpired</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>N/A</simpara></entry>
        
        <entry align="left" valign="top"><simpara>A message sent to a client bus to indicate that its messages are no longer being routed because it no longer has an active session</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">Heartbeat</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>N/A</simpara></entry>
        
        <entry align="left" valign="top"><simpara>A message sent from one bus to another periodically to indicate it is still active.</simpara></entry>
        
      </row>
      
    </tbody>
    
  </tgroup>
</table>
<informaltable frame="all"
    rowsep="1" colsep="1">
  
  <tgroup cols="4">
    
    <colspec colname="col_1" colwidth="25*"/>
    
    <colspec colname="col_2" colwidth="25*"/>
    
    <colspec colname="col_3" colwidth="25*"/>
    
    <colspec colname="col_4" colwidth="25*"/>
    
    
    <thead>
      
      <row>
        
        <entry align="left" valign="top">Part</entry>
        
        <entry align="left" valign="top">Required</entry>
        
        <entry align="left" valign="top">JSON Type</entry>
        
        <entry align="left" valign="top">Description</entry>
        
      </row>
      
    </thead>
    
    <tbody>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">CapabilitiesFlags</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>Yes</simpara></entry>
        
        <entry align="left" valign="top"><simpara>String</simpara></entry>
        
        <entry align="left" valign="top"><simpara>A comma delimited string of capabilities the bus is capable of us</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">Subject</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>Yes</simpara></entry>
        
        <entry align="left" valign="top"><simpara>String</simpara></entry>
        
        <entry align="left" valign="top"><simpara>The subject to subscribe or unsubscribe from</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">SubjectsList</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>Yes</simpara></entry>
        
        <entry align="left" valign="top"><simpara>Array</simpara></entry>
        
        <entry align="left" valign="top"><simpara>An array of strings representing a list of subjects to subscribe to</simpara></entry>
        
      </row>
      
    </tbody>
    
  </tgroup>
</informaltable>
</section>
</section>
</section>
<section id="sid-24674472">
<title>Conversations</title>
<simpara>Conversations are message exchanges which are between a single client and a service. They are a fundmentally important concept in ErraiBus, since by default, a message will be broadcast to all client services listening on a particular channel.</simpara>
<simpara>When you create a reply with an incoming message, you ensure that the message you are sending back is received by the same client which sent the incoming message. A simple example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Service
public class HelloWorldService implements MessageCallback {
  public void callback(CommandMessage message) {
    // Send a message to the 'HelloWorldClient' on the client that sent us the
    // the message.
    MessageBuilder.createConversation(message)
      .toSubject("HelloWorldClient")
      .signalling()
      .with("text", "Hi There! We're having a reply!")
      .noErrorHandling().reply();
    });
  }
}</programlisting>
<simpara>Note that the only difference between the example in the previous section and this is the use of the <literal><phrase role="code">createConversation()</phrase></literal> method with <literal><phrase role="code">MessageBuilder</phrase></literal> .</simpara>
</section>
<section id="sid-53380177">
<title>WebSockets</title>
<simpara>ErraiBus has support for WebSocket-based communication. When WebSockets are enabled, capable web browsers will attempt to upgrade their COMET-based communication with the server-side bus to use a WebSocket channel.</simpara>
<simpara>There are two different ways the bus can enable WebSockets. The first uses a sideband server, which is a small, lightweight server which runs on a different port from the application server. The second is native JBoss AS 7-based integration.</simpara>
<section id="sid-53380177_WebSockets-Configuringthesidebandserver">
<title>Configuring the sideband server</title>
<simpara>Activating the sideband server is as simple as adding the following to the <literal><phrase role="code">ErraiService.properties</phrase></literal> file:</simpara>
<programlisting language="java" linenumbering="unnumbered">errai.bus.enable_web_socket_server=true</programlisting>
<simpara>The default port for the sideband server is <literal><phrase role="code">8085</phrase></literal> . You can change this by specifying a port with the <literal><phrase role="code">errai.bus.web_socket_port</phrase></literal> property in the <literal><phrase role="code">ErraiService.properties</phrase></literal> file.</simpara>
</section>
<section id="sid-53380177_WebSockets-DeployingwithJBossAS7">
<title>Deploying with JBoss AS 7</title>
<simpara>It is currently necessary use the native connector in JBoss AS for WebSockets to work. So the first step is to configure your JBoss AS instance to use the native connector by changing the <literal><phrase role="code">domain/configuration/domain.xml</phrase></literal> file, and change the line:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;subsystem xmlns="urn:jboss:domain:web:1.1" default-virtual-server="default-host" native="false"&gt;</programlisting>
<simpara>to:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;subsystem xmlns="urn:jboss:domain:web:1.1" default-virtual-server="default-host" native="true"&gt;</programlisting>
<simpara>You will then need to configure the servlet in your application&#8217;s <literal><phrase role="code">web.xml</phrase></literal> which will provide WebSocket upgrade support within AS7.</simpara>
<simpara>Add the following to the <literal><phrase role="code">web.xml</phrase></literal> :</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;context-param&gt;
  &lt;param-name&gt;websockets-enabled&lt;/param-name&gt;
  &lt;param-value&gt;true&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;context-param&gt;
  &lt;param-name&gt;websocket-path-element&lt;/param-name&gt;
  &lt;param-value&gt;in.erraiBusWS&lt;/param-value&gt;
&lt;/context-param&gt;</programlisting>
<simpara>This will tell the bus to enable web sockets support. The <literal><phrase role="code">websocket-path-element</phrase></literal> specified the path element within a URL which the client bus should request in order to negotiate a websocket connection. For instance, specifying <literal><phrase role="code">in.erraiBusWS</phrase></literal> as we have in the snippit above, will result in attempted negotiation at <literal><phrase role="code"><ulink url="http://&lt;your_server&gt;:&lt;your_port&gt;/&lt;context_path&gt;/in.erraiBusWS">http://&lt;your_server&gt;:&lt;your_port&gt;/&lt;context_path&gt;/in.erraiBusWS</ulink></phrase></literal> . For this to have any meaningful result, we must add a servlet mapping that will match this pattern:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;servlet&gt;
  &lt;servlet-name&gt;ErraiWSServlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;org.jboss.errai.bus.server.servlet.JBossAS7WebSocketServlet&lt;/servlet-class&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;service-locator&lt;/param-name&gt;
    &lt;param-value&gt;org.jboss.errai.cdi.server.CDIServiceLocator&lt;/param-value&gt;
  &lt;/init-param&gt;
  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;ErraiWSServlet&lt;/servlet-name&gt;
  &lt;url-pattern&gt;*.erraiBusWS&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</programlisting>
<note>
<title>Do not remove the regular ErraiBus servlet mappings!</title>
<simpara>When configuring ErraiBus to use WebSockets on JBoss AS, you <emphasis>do not</emphasis> remove the existing servlet mappings for the bus. The WebSocket servlet is in <emphasis>addition to</emphasis> your current bus servlet. This is because ErraiBus <emphasis>always</emphasis> negotiates WebSocket sessions over the COMET channel.</simpara>
</note>
</section>
</section>
<section id="sid-59146643">
<title>Bus Lifecycle</title>
<section id="sid-59146643_BusLifecycle-TurningServerCommunicationOnandOff">
<title>Turning Server Communication On and Off</title>
<simpara>By default, Errai&#8217;s client-side message bus attempts to connect to the server as soon as the ErraiBus module has been loaded. The bus will stay connected until a lengthy (about 45 seconds) communication failure occurs, or the web page is unloaded.</simpara>
<simpara>The application can affect bus communication through two mechanisms:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>By setting a global JavaScript variable <literal><phrase role="code">erraiBusRemoteCommunicationEnabled = false</phrase></literal> before the GWT scripts load, bus communication with the server is permanently disabled</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>By calling <literal><phrase role="code"><indexterm><primary>ClientMessageBus) ErraiBus.get(</primary></indexterm>ClientMessageBus) ErraiBus.get(.stop()</phrase></literal> , the bus disconnects from the server</simpara>
      
    </listitem>
  
</orderedlist>
<simpara>To resume server communication after a call to <literal><phrase role="code">ClientMessageBus.stop()</phrase></literal> or after communication with the server has exceeded the bus' retry timeout, call <literal><phrase role="code"><indexterm><primary>ClientMessageBus) ErraiBus.get(</primary></indexterm>ClientMessageBus) ErraiBus.get(.init()</phrase></literal> . You can use a <literal><phrase role="code">BusLifecycleListener</phrase></literal> to monitor the success or failure of this attempt. See the next section for details.</simpara>
</section>
<section id="sid-59146643_BusLifecycle-ObservingBusLifecycleStateandCommunicationStatus">
<title>Observing Bus Lifecycle State and Communication Status</title>
<simpara>In a perfect world, the client message bus would always be able to communicate with the server message bus. But in the real world, there&#8217;s a whole array of reasons why the communication link between the server and the client might be interrupted.</simpara>
<simpara>On its own, the client message bus will attempt to reconnect with the server whenever communication has been disrupted. Errai applications can monitor the status of the bus' communication link (whether it is disconnected, attempting to connect, or fully connected) through the <literal><phrase role="code">BusLifecycleListener</phrase></literal> interface:</simpara>
<programlisting language="java" linenumbering="unnumbered">class BusStatusLogger implements BusLifecycleListener {

  @Override
  public void busAssociating(BusLifecycleEvent e) {
    GWT.log("Errai Bus trying to connect...");
  }

  @Override
  public void busOnline(BusLifecycleEvent e) {
    GWT.log("Errai Bus connected!");
  }

  @Override
  public void busOffline(BusLifecycleEvent e) {
    GWT.log("Errai Bus trying to connect...");
  }

  @Override
  public void busDisassociating(BusLifecycleEvent e) {
    GWT.log("Errai Bus going into local-only mode.");
  }
}</programlisting>
<simpara>To attach such a listener to the bus, make the following call in client-side code:</simpara>
<programlisting language="java" linenumbering="unnumbered">ClientMessageBus bus = (ClientMessageBus) ErraiBus.get();
bus.addLifecycleListener(new BusStatusLogger());</programlisting>
</section>
</section>
<section id="sid-68355291">
<title>Shadow Services</title>
<simpara>Shadow Services is a Service that will get invoked when there is no longer a connection with the server. This is particular helpful when developing an application for mobile. To create a Shadow Service for a specific Services all you have to do is annotate a new client side implementation with the @ShadowService:</simpara>
<programlisting language="java" linenumbering="unnumbered">@ShadowService
public class SignupShadowService implements MessageCallback {
   @Override
   public void callback(Message message) {
   }
}</programlisting>
<simpara>Also when you have a RPC based Service you can just add @ShadowService on a client side implementation to configure it to be the service to get called when there is no network:</simpara>
<programlisting language="java" linenumbering="unnumbered">@ShadowService
public class SignupServiceShadow implements SignupService {
   @Override
   public User register(User newUserObject, String password) throws RegistrationException {
   }
}</programlisting>
<simpara>In this shadow service we can create logic that will deal with the temporary connection loss. For instance you could save the data that needs to get send to the server with JPA on the client and then when the bus get online again sent the data to the server.</simpara>
</section>
<section id="sid-5931386">
<title>Debugging Messaging Problems</title>
<simpara>Errai includes a bus monitoring application, which allows you to monitor all of the message exchange activity on the bus in order to help track down any potential problems It allows you to inspect individual messages to examine their state and structure.</simpara>
<simpara>To utilize the bus monitor, you&#8217;ll need to include the _errai-tools _ package as part of your application&#8217;s dependencies. When you run your application in development mode, you will simply need to add the following JVM options to your run configuration in order to launch the monitor: <literal><phrase role="code">-Derrai.tools.bus_monitor_attach=true</phrase></literal></simpara>
<figure>
<title>TODO InformalFigure image title empty</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/5931386/MonitorOverview.png"/>
    </imageobject>
    <textobject><phrase>MonitorOverview</phrase></textobject>
  </mediaobject>
</figure>
<simpara>The monitor provides you a real-time perspective on what&#8217;s going on inside the bus. The left side of the main screen lists the services that are currently available, and the right side is the service-explorer, which will show details about the service.</simpara>
<simpara>To see what&#8217;s going on with a specific service, simply double-click on the service or highlight the service, then click "Monitor Service&#8230;". This will bring up the service activity monitor.</simpara>
<figure>
<title>TODO InformalFigure image title empty</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/5931386/MonitorOverview2.png"/>
    </imageobject>
    <textobject><phrase>MonitorOverview2</phrase></textobject>
  </mediaobject>
</figure>
<simpara>The service activity monitor will display a list of all the messages that were transmitted on the bus since the monitor became active. You do not need to actually have each specific monitor window open in order to actively monitor the bus activity. All activity on the bus is recorded.</simpara>
<simpara>The monitor allows you select individual messages, an view their individual parts. Clicking on a message part will bring up the object inspector, which will allow you to explore the state of any objects contained within the message, not unlike the object inspectors provided by debuggers in your favorite IDE. This can be a powerful tool for looking under the covers of your application.</simpara>
</section>
</chapter>
<chapter id="sid-5931402">
<title>Dependency Injection</title>
<simpara>The core Errai IOC module implements the <emphasis>JSR-330 Dependency Injection</emphasis> specification for in-client component wiring.</simpara>
<simpara>Dependency injection (DI) allows for cleaner and more modular code, by permitting the implementation of decoupled and type-safe components. By using DI, components do not need to be aware of the implementation of provided services. Instead, they merely declare a contract with the container, which in turn provides instances of the services that component depends on.</simpara>
<note>
<title>Classpath Scanning and ErraiApp.properties</title>
<simpara>Errai only scans the contents of classpath locations (JARs and directories) that have <link linkend="sid-5931354">a file called
          ErraiApp.properties</link> at their root. If dependency injection is not working for you, double-check that you have an <literal><phrase role="code">ErraiApp.properties</phrase></literal> in every JAR and directory that contains classes Errai should know about.</simpara>
</note>
<simpara>A simple example:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class MyLittleClass {
  private final TimeService timeService;

  @Inject
  public MyLittleClass(TimeService timeService) {
    this.timeService = timeService;
  }

  public void printTime() {
    System.out.println(this.timeService.getTime());
  }
}</programlisting>
<simpara>In this example, we create a simple class which declares a dependency using <literal><phrase role="code">@Inject</phrase></literal> for the interface <literal><phrase role="code">TimeService</phrase></literal> . In this particular case, we use constructor injection to establish the contract between the container and the component. We can similarly use field injection to the same effect:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class MyLittleClass {
  @Inject
  private TimeService timeService;

  public void printTime() {
    System.out.println(this.timeService.getTime());
  }
}</programlisting>
<simpara>In order to inject <literal><phrase role="code">TimeService</phrase></literal> , you must annotate it with <literal><phrase role="code">@ApplicationScoped</phrase></literal> or the Errai DI container will not acknowledge the type as a bean.</simpara>
<programlisting language="java" linenumbering="unnumbered">@ApplicationScoped
public class TimeService {
}</programlisting>
<tip>
<title>Best Practices</title>
<simpara>Although field injection results in less code, a major disadvantage is that you cannot create immutable classes using the pattern, since the container must first call the default, no argument constructor, and then iterate through its injection tasks, which leaves the potential  albeit remote  that the object could be left in an partially or improperly initialized state. The advantage of constructor injection is that fields can be immutable (final), and invariance rules applied at construction time, leading to earlier failures, and the guarantee of consistent state.</simpara>
</tip>
<section id="sid-5931407">
<title>Container Wiring</title>
<simpara>In contrast to <ulink url="http://code.google.com/p/google-gin/">Gin</ulink> , the Errai IOC container does not provide a programmatic way of creating and configuring injectors. Instead, container-level binding rules are defined by implementing a <literal><phrase role="code">Provider</phrase></literal> , which is scanned for and auto-discovered by the container.</simpara>
<simpara>A <literal><phrase role="code">Provider</phrase></literal> is essentially a factory which produces type instances within in the container, and defers instantiation responsibility for the provided type to the provider implementation. Top-level providers use the standard <literal><phrase role="code">javax.inject.Provider&lt;T&gt;</phrase></literal> interface.</simpara>
<simpara>Types made available as <emphasis>top-level</emphasis> providers will be available for injection in any managed component within the container.</simpara>
<simpara>Out of the box, Errai IOC implements these default top-level providers, all defined in the <literal><phrase role="code">org.jboss.errai.ioc.client.api.builtin</phrase></literal> package:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara><literal><phrase role="code">CallerProvider :</phrase></literal> Makes RPC <literal><phrase role="code">Caller&lt;T&gt;</phrase></literal> objects available for injection.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal><phrase role="code">DisposerProvider :</phrase></literal> Makes Errai IoC <literal><phrase role="code">Disposer&lt;T&gt;</phrase></literal> objects available for injection.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal><phrase role="code">InitBallotProvider :</phrase></literal> Makes instances of <literal><phrase role="code">InitBallot</phrase></literal> available for injection.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal><phrase role="code">IOCBeanManagerProvider :</phrase></literal> Makes Errai&#8217;s client-side bean manager, <literal><phrase role="code">ClientBeanManager</phrase></literal> , available for injection.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal><phrase role="code">MessageBusProvider :</phrase></literal> Makes Errai&#8217;s client-side <literal><phrase role="code">MessageBus</phrase></literal> singleton available for injection.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal><phrase role="code">RequestDispatcherProvider :</phrase></literal> Makes an instance of the <literal><phrase role="code">RequestDispatcher</phrase></literal> available for injection.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal><phrase role="code">RootPanelProvider :</phrase></literal> Makes GWT&#8217;s <literal><phrase role="code">RootPanel</phrase></literal> singleton injectable.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal><phrase role="code">SenderProvider :</phrase></literal> Makes MessageBus <literal><phrase role="code">Sender&lt;T&gt;</phrase></literal> objects available for injection.</simpara>
      
    </listitem>
  
</itemizedlist>

<simpara>Implementing a <literal><phrase role="code">Provider</phrase></literal> is relatively straight-forward. Consider the following two classes:</simpara>
<simpara><emphasis>TimeService.java</emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">public interface TimeService {
  public String getTime();
}</programlisting>
<simpara><emphasis>TimeServiceProvider.java</emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered">@IOCProvider
@Singleton
public class TimeServiceProvider implements Provider&lt;TimeService&gt; {
  @Override
  public TimeService get() {
    return new TimeService() {
      public String getTime() {
        return "It's midnight somewhere!";
      }
    };
  }
}</programlisting>
<simpara>If you are familiar with Guice, this is semantically identical to configuring an injector like so:</simpara>
<programlisting language="java" linenumbering="unnumbered">Guice.createInjector(new AbstractModule() {
  public void configure() {
    bind(TimeService.class).toProvider(TimeServiceProvider.class);
  }
 }).getInstance(MyApp.class);</programlisting>
<simpara>As shown in the above example code, the annotation <literal><phrase role="code">@IOCProvider</phrase></literal> is used to denote top-level providers.</simpara>
<simpara>The classpath will be searched for all annotated providers at compile time.</simpara>
<important>
<simpara>Top-level providers are regular beans, so they can inject dependenciesparticularly from other top-level providersas necessary.</simpara>
</important>
</section>
<section id="sid-5931332">
<title>Wiring server side components</title>
<simpara>By default, Errai uses Google Guice to wire server-side components. When deploying services on the server-side, it is currently possible to obtain references to the <literal><phrase role="code">MessageBus</phrase></literal> , <literal><phrase role="code">RequestDispatcher</phrase></literal> , the <literal><phrase role="code">ErraiServiceConfigurator</phrase></literal> , and <literal><phrase role="code">ErraiService</phrase></literal> by declaring them as injection dependencies in Service classes, extension components, and session providers.</simpara>
<simpara>Alternatively, supports CDI based wiring of server-side components. See the chapter on Errai CDI for more information.</simpara>
</section>
<section id="sid-20938792">
<title>Scopes</title>
<simpara>Out of the box, the IOC container supports three bean scopes, <literal><phrase role="code">@Dependent</phrase></literal> , <literal><phrase role="code">@Singleton</phrase></literal> and <literal><phrase role="code">@EntryPoint</phrase></literal> . The singleton and entry-point scopes are roughly the same semantics.</simpara>
<section id="sid-24674461">
<title>Dependent Scope</title>
<simpara>In Errai IOC, all client types are valid bean types if they are default constructable or can have construction dependencies satisfied. These unqualified beans belong to the dependent pseudo-scope. See: <ulink url="http://docs.jboss.org/weld/reference/latest/en-US/html/scopescontexts.html#d0e1997">Dependent Psuedo-Scope from CDI Documentation</ulink></simpara>
<simpara>Additionally, beans may be qualified as <literal><phrase role="code">@ApplicationScoped</phrase></literal> , <literal><phrase role="code">@Singleton</phrase></literal> or <literal><phrase role="code">@EntryPoint</phrase></literal> . Although <literal><phrase role="code">@ApplicationScoped</phrase></literal> and <literal><phrase role="code">@Singleton</phrase></literal> are supported for completeness and conformance, within the client they effectively result in behavior that is identical.</simpara>
<example>
<title>Example dependent scoped bean</title>
<programlisting language="java" linenumbering="unnumbered">public void MyDependentScopedBean {
  private final Date createdDate;

  public MyDependentScopedBean {
    createdDate = new Date();
  }
}</programlisting>
</example>
<example>
<title>Example ApplicationScoped bean</title>
<programlisting language="java" linenumbering="unnumbered">@ApplicationScoped
public void MyClientBean {
  @Inject MyDependentScopedBean bean;

  // ... //
}</programlisting>
</example>
<important>
<title>Availability of dependent beans in the client-side BeanManager</title>
<simpara>As is mentioned in the <link linkend="sid-21627016_Client-SideBeanManager-AvailabilityOfBeans">bean manager documentation</link> , only beans that are <emphasis>explicitly</emphasis> scoped will be made available to the bean manager for lookup. So while it is not necessary for regular injection, you must annotate your dependent scoped beans with <literal><phrase role="code">@Dependent</phrase></literal> if you wish to dynamically lookup these beans at runtime.</simpara>
</important>
</section>
</section>
<section id="sid-20938794">
<title>Built-in Extensions</title>
<section id="sid-20938797">
<title>Bus Services</title>
<simpara>As Errai IOC provides a container-based approach to client development, support for Errai services are exposed to the container so they may be injected and used throughout your application where appropriate. This section covers those services.</simpara>
<section id="sid-20938797_BusServices-@Service">
<title>@Service</title>
<simpara>The <literal><phrase role="code">org.jboss.errai.bus.server.annotations.Service</phrase></literal> annotation is used for binding service endpoints to the bus. Within the Errai IOC container you can annotate services and have them published to the bus on the client (or on the server) in a very straight-forward manner:</simpara>
<example>
<title>A simple message receiving service</title>
<programlisting language="java" linenumbering="unnumbered">@Service
public class MyService implements MessageCallback {
  public void callback(Message message) {
    // ... //
  }
}</programlisting>
</example>
<simpara>As with server-side use of the annotation, if a service name is not explicitly specified, the underlying class name or field name being annotated will be used as the service name.</simpara>
</section>
<section id="sid-20938797_BusServices-@Local">
<title>@Local</title>
<simpara>The <literal><phrase role="code">org.jboss.errai.bus.server.api.Local</phrase></literal> annotation is used in conjunction with the <literal><phrase role="code">@Service</phrase></literal> annotation to advertise a service only for visibility on the local bus and thus, cannot receive messages across the wire for the service.</simpara>
<example>
<title>A local only service</title>
<programlisting language="java" linenumbering="unnumbered">@Service @Local
public class MyLocalService implements MessageCallback {
  public void callback(Message message) {
    // ... //
  }
}</programlisting>
</example>
</section>
<section id="sid-20938797_BusServices-LifecycleImpactofServices">
<title>Lifecycle Impact of Services</title>
<simpara>Services which are registered with ErraiBus via the bean manager through use of the <literal><phrase role="code">@Service</phrase></literal> annotation, have de-registration hooks tied implicitly to the destruction of the bean. Thus, <link linkend="sid-22872238">destruction of the bean</link> implies that these associated services are to be dereferenced.</simpara>
</section>
</section>
<section id="sid-20938800">
<title>Client Components</title>
<simpara>The IOC container, by default, provides a set of default injectable bean types. They range from basic services, to injectable proxies for RPC. This section covers the facilities available out-of-the-box.</simpara>
<section id="sid-20938800_ClientComponents-MessageBus">
<title>MessageBus</title>
<simpara>The type <literal><phrase role="code">org.jboss.errai.bus.client.framework.MessageBus</phrase></literal> is globally injectable into any bean. Injecting this type will provide the instance of the active message bus running in the client.</simpara>
<example>
<title>Injecting a MessageBus</title>
<programlisting language="java" linenumbering="unnumbered">@Inject MessageBus bus;</programlisting>
</example>
</section>
<section id="sid-20938800_ClientComponents-RequestDispatcher">
<title>RequestDispatcher</title>
<simpara>The type <literal><phrase role="code">org.jboss.errai.bus.client.framework.RequestDispatcher</phrase></literal> is globally injectable into any bean. Injecting this type will provide a <literal><phrase role="code">RequestDispatcher</phrase></literal> instance capable of delivering any messages provided to it, to the the <literal><phrase role="code">MessageBus</phrase></literal> .</simpara>
<example>
<title>Injecting a RequestDispatcher</title>
<programlisting language="java" linenumbering="unnumbered">@Inject RequestDispatcher dispatcher;</programlisting>
</example>
</section>
<section id="sid-20938800_ClientComponents-Caller%3C%3F%3E">
<title>Caller&lt;?&gt;</title>
<simpara>The type <literal><phrase role="code">org.jboss.errai.common.client.api.Caller&lt;?&gt;</phrase></literal> is a globally injectable RPC proxy. RPC proxies may be provided by various components. For example, JAX-RS or Errai RPC. The proxy itself is agnostic to the underlying RPC mechanism and is qualified by it&#8217;s type parameterization.</simpara>
<simpara>For example:</simpara>
<example>
<title>An example Caller&lt;?&gt; proxy</title>
<programlisting language="java" linenumbering="unnumbered">public void MyClientBean {
  @Inject
  private Caller&lt;MyRpcInterface&gt; rpcCaller;

  // ... ///

  @EventHandler("button")
  public void onButtonClick(ClickHandler handler) {
    rpcCaller.call(new RemoteCallback&lt;Void&gt;() {
      public void callback(Void void) {
        // put code here that should execute after RPC response arrives
      }
    ).callSomeMethod();
  }
}</programlisting>
</example>
<simpara>The above code shows the injection of a proxy for the RPC remote interface, <literal><phrase role="code">MyRpcInterface</phrase></literal> . For more information on defining RPC proxies see <link linkend="sid-5931313">Remote Procedure Calls (RPC)</link>.</simpara>
</section>
<section id="sid-20938800_ClientComponents-Sender%3C%3F%3E">
<title>Sender&lt;?&gt;</title>
<simpara>The <literal><phrase role="code">org.jboss.errai.ioc.support.bus.client.Sender&lt;?&gt;</phrase></literal> interface is the lower-level counterpart to the <literal><phrase role="code">Caller&lt;?&gt;</phrase></literal> interface described above. You can inject a <literal><phrase role="code">Sender</phrase></literal> to send low-level ErraiBus messages directly to subscribers on any subject.</simpara>
<simpara>For example:</simpara>
<programlisting language="java" linenumbering="unnumbered">  @Inject
  @ToSubject("ListCapitializationService")
  Sender&lt;List&lt;String&gt;&gt; listSender;

  // ... ///

  @EventHandler("button")
  public void onButtonClick(ClickHandler handler) {
    List&lt;String&gt; myListOfStrings = getSelectedCitiesFromForm();
    listSender.send(myListOfStrings, new MessageCallback() {
      public void callback(Message reply) {
        // do stuff with reply
      }
    );
  }</programlisting>
<simpara>The <literal><phrase role="code">Sender.send()</phrase></literal> method is overloaded. The variant demonstrated above takes a value and a MessageCallback to reply receive a reply (assuming the subscriber sends a conversational reply). The following variants are available:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara><literal><phrase role="code">send(T)</phrase></literal></simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal><phrase role="code">send(T, ErrorCallback)</phrase></literal></simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal><phrase role="code">send(T, MessageCallback)</phrase></literal></simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal><phrase role="code">send(T, MessageCallback, ErrorCallback)</phrase></literal></simpara>
      
    </listitem>
  
</itemizedlist>

<simpara>The reply-to service can also be specified declaratively using the <literal><phrase role="code">@ReplyTo</phrase></literal> annotation. This allows the app to receive conversational replies even when using the <literal><phrase role="code">send()</phrase></literal> variants that do not take a <literal><phrase role="code">MessageCallback</phrase></literal> :</simpara>
<programlisting language="java" linenumbering="unnumbered">  @Inject
  @ToSubject("ListCapitializationService")
  @ReplyTo("ClientListService")
  Sender&lt;List&lt;String&gt;&gt; listSender;

  // ... ///

  @EventHandler("button")
  public void onButtonClick(ClickHandler handler) {
    List&lt;String&gt; myListOfStrings = getSelectedCitiesFromForm();
    listSender.send(myListOfStrings);
  }

  @Singleton
  @Service
  public static class ClientListService implements MessageCallback {
    @Override
    public void callback(Message message) {
      // do stuff with message
    }
  }</programlisting>
<simpara>These <literal><phrase role="code">Sender&lt;?&gt;</phrase></literal> features are just convenient wrappers around the full-featured programmatic ErraiBus API. See <link linkend="sid-5931280">Messaging API Basics</link> and <link linkend="sid-24674472">Conversations</link> for full information about low-level ErraiBus communication.</simpara>
</section>
</section>
<section id="sid-21758082">
<title>Lifecycle Tools</title>
<simpara>A problem commonly associated with building large applications in the browser is ensuring that things happen in the proper order when code starts executing. Errai IOC provides you tools which permit you to ensure things happen before initialization, and forcing things to happen after initialization of all of the Errai services.</simpara>
<section id="sid-21758082_LifecycleTools-ControllingStartup">
<title>Controlling Startup</title>
<simpara>In order to prevent initialization of the the bus and it&#8217;s services so that you can do necessary configuration, especially if you are writing extensions to the Errai framework itself, you can create an implicit startup dependency on your bean by injecting an <literal><phrase role="code">org.jboss.errai.ioc.client.api.InitBallot&lt;?&gt;</phrase></literal> .</simpara>
<example>
<title>Using an InitBallot to Control Startup</title>
<programlisting language="java" linenumbering="unnumbered">@Singleton
public class MyClientBean {
  @Inject InitBallot&lt;MyClientBean&gt; ballot;

  @PostConstruct
  public void doStuff() {
    // ... do some work ...

    ballot.voteForInit();
  }
}</programlisting>
</example>
</section>
<section id="sid-21758082_LifecycleTools-PerformingTasksAfterInitialization">
<title>Performing Tasks After Initialization</title>
<simpara>Sending RPC calls to the server from inside constructors and <literal><phrase role="code">@PostConstruct</phrase></literal> methods in Errai is not always reliable due to the fact that the bus and RPC proxies initialize asynchronously with the rest of the application. Therefore it is often desirable to have such things happen in a post-initialization task, which is exposed in the <literal><phrase role="code">ClientMessageBus</phrase></literal> API. However, it is much cleaner to use the <literal><phrase role="code">@AfterInitialization</phrase></literal> annotation on one of your bean methods.</simpara>
<example>
<title>Using @AfterInitialization to do something after startup</title>
<programlisting language="java" linenumbering="unnumbered">@Singleton
public class MyClientBean {
  @AfterInitialization
  public void doStuffAfterInit() {
    // ... do some work ...
  }
}</programlisting>
</example>
</section>
</section>
<section id="sid-71467095">
<title>Timed Methods</title>
<simpara>The <literal><phrase role="code">@Timed</phrase></literal> annotation allows scheduling method executions on managed client-side beans. Timers are automatically scoped to the scope of the corresponding managed bean and participate in the same lifecycle (see <link linkend="sid-22872238">Bean Lifecycle</link> for details).</simpara>
<simpara>In the following example the <literal><phrase role="code">updateTime</phrase></literal> method is invoked repeatedly every second.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Timed(type = TimerType.REPEATING, interval = 1, timeUnit = TimeUnit.SECONDS)
private void updateTime() {
  timeWidget.setTime(System.currentTimeMillis);
}</programlisting>
<simpara>For delayed one-time execution of methods <literal><phrase role="code">type = TimerType.DELAYED</phrase></literal> can be used instead.</simpara>
</section>
</section>
<section id="sid-21627016">
<title>Client-Side Bean Manager</title>
<simpara>It may be necessary at times to manually obtain instances of beans managed by Errai IOC from outside the container managed scope or creating a hard dependency from your bean. Errai IOC provides a simple client-side bean manager for handling these scenarios: <literal><phrase role="code">org.jboss.errai.ioc.client.container.ClientBeanManager</phrase></literal> .</simpara>
<simpara>As you might expect, you can inject a bean manager instance into any of your managed beans. If you use Errai IOC in its default mode you will need to inject the synchronous bean manager ( <literal><phrase role="code">org.jboss.errai.ioc.client.container.SyncBeanManager</phrase></literal> ).</simpara>
<simpara>If you have asynchronous IOC mode enabled simply inject the asynchronous bean manager ( <literal><phrase role="code">org.jboss.errai.ioc.client.container.async.AsyncBeanManager</phrase></literal> ) instead. Asynchronous IOC brings support for <ulink url="http://www.gwtproject.org/doc/latest/DevGuideCodeSplitting.html">code splitting</ulink> . That means that any bean annotated with <literal><phrase role="code">@LoadAsync</phrase></literal> can be compiled into a separate JavaScript file that&#8217;s downloaded when the bean is first needed on the client.</simpara>
<example>
<title>Injecting the client-side bean manager</title>
<programlisting language="java" linenumbering="unnumbered">public MyManagedBean {
  @Inject SyncBeanManager manager;

  // class body
}</programlisting>
</example>
<simpara>If you need to access the bean manager outside a managed bean, such as in a unit test, you can access it by calling <literal><phrase role="code">org.jboss.errai.ioc.client.container.IOC.getBeanManager()</phrase></literal></simpara>
<section id="sid-21627016_Client-SideBeanManager-Lookingupbeans">
<title>Looking up beans</title>
<simpara>Looking up beans can be done through the use of the <literal><phrase role="code">lookupBeans()</phrase></literal> method. Here&#8217;s a basic example:</simpara>
<example>
<title>Example lookup of a bean</title>
<programlisting language="java" linenumbering="unnumbered">public MyManagedBean {
  @Inject SyncBeanManager manager;

  public void lookupBean() {
    IOCBeanDef&lt;SimpleBean&gt; bean = manager.lookupBean(SimpleBean.class);

    if (bean != null) {
      // get the instance of the bean
      SimpleBean inst = bean.getInstance();
    }
  }
}</programlisting>
</example>
<simpara>In this example we lookup a bean class named <literal><phrase role="code">SimpleBean</phrase></literal> . This example will succeed assuming that <literal><phrase role="code">SimpleBean</phrase></literal> is unambiguous. If the bean is ambiguous and requires qualification, you can do a qualified lookup like so:</simpara>
<example>
<title>Looking up beans with qualifiers</title>
<programlisting language="java" linenumbering="unnumbered">MyQualifier qual = new MyQualifier() {
  public annotationType() {
    return MyQualifier.class;
  }
}

MyOtherQualifier qual2 = new MyOtherQualifier() {
  public annotationType() {
    return MyOtherQualifier.class;
  }
}

// pass qualifiers to ClientBeanManager.lookupBeans
IOCBeanDef&lt;SimpleBean&gt; bean = beanManager.lookupBean(SimpleBean.class, qual, qual2);</programlisting>
</example>
<simpara>In this example we manually construct instances of qualifier annotations in order to pass it to the bean manager for lookup. This is a necessary step since there&#8217;s currently no support for annotation literals in Errai client code.</simpara>
</section>
<section id="sid-21627016_Client-SideBeanManager-Availabilityofbeans">
<title>Availability of beans</title>
<simpara>Not all beans that are available for injection are available for lookup from the bean manager by default. Only beans which are <emphasis>explicitly</emphasis> scoped are available for dynamic lookup. This is an intentional feature to keep the size of the generated code down in the browser.</simpara>
</section>
</section>
<section id="sid-22872133">
<title>Alternatives and Mocks</title>
<section id="sid-22872133_AlternativesandMocks-Alternatives">
<title>Alternatives</title>
<simpara>It may be desirable to have multiple matching dependencies for a given injection point with the ability to specify which implementation to use at runtime. For instance, you may have different versions of your application which target different browsers or capabilities of the browser. Using alternatives allows you to share common interfaces among your beans, while still using dependency injection, by exporting consideration of what implementation to use to the container&#8217;s configuration.</simpara>
<simpara>Consider the following example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Singleton @Alternative
public class MobileView implements View {
  // ... //
}</programlisting>
<simpara>and</simpara>
<programlisting language="java" linenumbering="unnumbered">@Singleton @Alternative
public class DesktopView implements View {
  // ... //</programlisting>
<simpara>In our controller logic we in turn inject the <literal><phrase role="code">View</phrase></literal> interface:</simpara>
<programlisting language="java" linenumbering="unnumbered">@EntryPoint
public class MyApp {
  @Inject
  View view;

  // ... //
}</programlisting>
<simpara>This code is unaware of the implementation of <literal><phrase role="code">View</phrase></literal> , which maintains good separation of concerns. However, this of course creates an ambiguous dependency on the <literal><phrase role="code">View</phrase></literal> interface as it has two matching subtypes in this case. Thus, we must configure the container to specify which alternative to use. Also note, that the beans in both cases have been annotated with <literal><phrase role="code">javax.enterprise.inject.Alternative</phrase></literal> .</simpara>
<simpara>In your <literal><phrase role="code">ErraiApp.properties</phrase></literal> for the module, you can simply specify which active alternative should be used:</simpara>
<programlisting language="ini" linenumbering="unnumbered">errai.ioc.enabled.alternatives=org.foo.MobileView</programlisting>
<simpara>You can specify multiple alternative classes by white space separating them:</simpara>
<programlisting language="ini" linenumbering="unnumbered">errai.ioc.enabled.alternatives=org.foo.MobileView \
                               org.foo.HTML5Orientation \
                               org.foo.MobileStorage</programlisting>
<simpara>You can only have one enabled alternative for a matching set of alternatives, otherwise you will get ambiguous resolution errors from the container.</simpara>
</section>
<section id="sid-22872133_AlternativesandMocks-TestMocks">
<title>Test Mocks</title>
<simpara>Similar to alternatives, but specifically designed for testing scenarios, you can replace beans with mocks at runtime for the purposes of running unit tests. This is accomplished simply by annotating a bean with the <literal><phrase role="code">org.jboss.errai.ioc.client.api.TestMock</phrase></literal> annotation. Doing so will prioritize consideration of the bean over any other matching beans while running unit tests.</simpara>
<simpara>Consider the following:</simpara>
<programlisting language="java" linenumbering="unnumbered">@ApplicationScoped
public class UserManagementImpl implements UserManagement {
  public List&lt;User&gt; listUsers() {
     // do user listy things!
  }
}</programlisting>
<simpara>You can specify a mock implementation of this class by implementing its common parent type ( <literal><phrase role="code">UserManagement</phrase></literal> ) and annotating that class with the <literal><phrase role="code">@TestMock</phrase></literal> annotation inside your test package like so:</simpara>
<programlisting language="java" linenumbering="unnumbered">@TestMock @ApplicationScoped
public class MockUserManagementImpl implements UserManagement {
  public List&lt;User&gt; listUsers() {
     // return only a test user.
     return Collections.singletonList(TestUser.INSTANCE);
  }
}</programlisting>
<simpara>In this case, the container will replace the <literal><phrase role="code">UserManagementImpl</phrase></literal> with the <literal><phrase role="code">MockUserManagementImpl</phrase></literal> automatically when running the unit tests.</simpara>
<simpara>The <literal><phrase role="code">@TestMock</phrase></literal> annotation can also be used to specify alternative providers during test execution. For example, it can be used to mock a <literal><phrase role="code">Caller&lt;T&gt;</phrase></literal> . <literal><phrase role="code">Callers</phrase></literal> are used to invoke RPC or JAX-RS endpoints. During tests you might want to replace theses callers with mock implementations. For details on providers see <xref linkend="sid-5931407"/> .</simpara>
<programlisting language="java" linenumbering="unnumbered">@TestMock @IOCProvider
public class MockedHappyServiceCallerProvider implements ContextualTypeProvider&lt;Caller&lt;HappyService&gt;&gt; {

  @Override
  public Caller&lt;HappyService&gt; provide(Class&lt;?&gt;[] typeargs, Annotation[] qualifiers) {
    return new Caller&lt;HappyService&gt;() {
      ...
    }
}</programlisting>
</section>
</section>
<section id="sid-22872238">
<title>Bean Lifecycle</title>
<simpara>All beans managed by the Errai IOC container support the <literal><phrase role="code">@PostConstruct</phrase></literal> and <literal><phrase role="code">@PreDestroy</phrase></literal> annotations.</simpara>
<simpara>Beans which have methods annotated with <literal><phrase role="code">@PostConstruct</phrase></literal> are guaranteed to have those methods called before the bean is put into service, and only after all dependencies within its graph has been satisfied.</simpara>
<simpara>Beans are also guaranteed to have their <literal><phrase role="code">@PreDestroy</phrase></literal> annotated methods called before they are destroyed by the bean manager.</simpara>
<important>
<simpara>This cannot be guaranteed when the browser DOM is destroyed prematurely due to: closing the browser window; closing a tab; refreshing the page, etc.</simpara>
</important>
<section id="sid-22872238_BeanLifecycle-DestructionofBeans">
<title>Destruction of Beans</title>
<simpara>Beans under management of Errai IOC, of any scope, can be explicitly destroyed through the client bean manager. Destruction of a managed bean is accomplished by passing a reference to the <literal><phrase role="code">destroyBean()</phrase></literal> method of the bean manager.</simpara>
<example>
<title>Destruction of bean</title>
<programlisting language="java" linenumbering="unnumbered">public MyManagedBean {
  @Inject SyncBeanManager manager;

  public void createABeanThenDestroyIt() {
    // get a new bean.
    SimpleBean bean = manager.lookupBean(SimpleBean.class).getInstance();

    bean.sendMessage("Sorry, I need to dispose of you now");

    // destroy the bean!
    manager.destroyBean(bean);
  }
}</programlisting>
</example>
<simpara>When the bean manager "destroys" the bean, any pre-destroy methods the bean declares are called, it is taken out of service and no longer tracked by the bean manager. If there are references on the bean by other objects, the bean will continue to be accessible to those objects.</simpara>
<important>
<simpara>Container managed resources that are dependent on the bean such as bus service endpoints or CDI event observers will also be automatically destroyed when the bean is destroyed.</simpara>
</important>
<simpara>Another important consideration is the rule, "all beans created together are destroyed together." Consider the following example:</simpara>
<example>
<title>SimpleBean.class</title>
<programlisting language="java" linenumbering="unnumbered">@Dependent
public class SimpleBean {
   @Inject @New AnotherBean anotherBean;

   public AnotherBean getAnotherBean() {
     return anotherBean;
   }

   @PreDestroy
   private void cleanUp() {
     // do some cleanup tasks
   }
}</programlisting>
</example>
<example>
<title>Destroying bean from subgraph</title>
<programlisting language="java" linenumbering="unnumbered">public MyManagedBean {
  @Inject SyncBeanManager manager;

  public void createABeanThenDestroyIt() {
    // get a new bean.
    SimpleBean bean = manager.lookupBean(SimpleBean.class).getInstance();

    // destroy the AnotherBean reference from inside the bean
    manager.destroyBean(bean.getAnotherBean());
  }
}</programlisting>
</example>
<simpara>In this example we pass the instance of <literal><phrase role="code">AnotherBean,</phrase></literal> created as a dependency of <literal><phrase role="code">SimpleBean,</phrase></literal> to the bean manager for destruction. Because this bean was created at the same time as its parent, its destruction will also result in the destruction of <literal><phrase role="code">SimpleBean</phrase></literal> ; thus, this action will result in the <literal><phrase role="code">@PreDestroy</phrase></literal>[code]<literal>cleanUp()</literal> method of <literal><phrase role="code">SimpleBean</phrase></literal> being invoked.</simpara>
<section id="sid-22872238_BeanLifecycle-Disposers">
<title>Disposers</title>
<simpara>Another way which beans can be destroyed is through the use of the injectable <literal><phrase role="code">org.jboss.errai.ioc.client.api.Disposer&lt;T&gt;</phrase></literal> class. The class provides a straight forward way of disposing of bean type.</simpara>
<simpara>For instance:</simpara>
<example>
<title>Destroying bean with disposer</title>
<programlisting language="java" linenumbering="unnumbered">public MyManagedBean {
  @Inject @New SimpleBean myNewSimpleBean;
  @Inject Disposer&lt;SimpleBean&gt; simpleBeanDisposer;

  public void destroyMyBean() {
    simpleBeanDisposer.dispose(myNewSimpleBean);
  }
}</programlisting>
</example>
</section>
</section>
</section>
</chapter>
<chapter id="sid-19398999">
<title>Errai CDI</title>
<simpara>CDI (Contexts and Dependency Injection) is the Jave EE standard (JSR-299) for handling dependency injection. In addition to dependency injection, the standard encompasses component lifecycle, application configuration, call-interception and a decoupled, type-safe eventing specification.</simpara>
<simpara>The Errai CDI extension implements a subset of the specification for use inside of client-side applications within Errai, as well as additional capabilities such as distributed eventing.</simpara>
<simpara>Errai CDI does not currently implement all life cycles specified in JSR-299 or interceptors. These deficiencies may be addressed in future versions.</simpara>
<important>
<simpara>Errai CDI is implemented as an extension on top of the Errai IOC Framework (see <xref linkend="sid-5931402"/> ), which itself implements JSR-330. Inclusion of the CDI module your GWT project will result in the extensions automatically being loaded and made available to your application.</simpara>
</important>
<note>
<title>Classpath Scanning and ErraiApp.properties</title>
<simpara>Errai CDI only scans the contents of classpath locations (JARs and directories) that have <link linkend="sid-5931354">a file called
          ErraiApp.properties</link> at their root. If CDI features such as dependency injection, event observation, and <literal><phrase role="code">@PostConstruct</phrase></literal> are not working for your classes, double-check that you have an <literal><phrase role="code">ErraiApp.properties</phrase></literal> at the root of every JAR and directory tree that contains classes Errai should know about.</simpara>
</note>
<section id="sid-5931498">
<title>Features and Limitations</title>
<simpara>Beans that are deployed to a CDI container will automatically be registered with Errai and exposed to your GWT client application. So, you can use Errai to communicate between your GWT client components and your CDI backend beans.</simpara>
<simpara>Errai CDI based applications use the same annotation-driven programming model as server-side CDI components, with some notable limitations. Many of these limitations will be addressed in future releases.</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>There is no support for CDI interceptors in the client. Although this is planned in a future release.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Passivating scopes are not supported.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The JSR-299 SPI is not supported for client side code. Although writing extensions for the client side container is possible via the Errai IOC Extensions API.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The <literal><phrase role="code">@Typed</phrase></literal> annotation is unsupported.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The <literal><phrase role="code">@Interceptor</phrase></literal> annotation is unsupported.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The <literal><phrase role="code">@Decorator</phrase></literal> annotation is unsupported.</simpara>
      
    </listitem>
  
</orderedlist>
<section id="sid-5931498_FeaturesandLimitations-Otherfeatures">
<title>Other features</title>
<simpara>The CDI container in Errai is built around the <link linkend="sid-5931402">Errai IOC module</link> , and thus is a superset of the existing functionality in Errai IOC. Thus, all features and APIs documented in Errai IOC are accessible and usable with this Errai CDI programming model.</simpara>
</section>
</section>
<section id="sid-21758054">
<title>Events</title>
<simpara>Any CDI managed component may produce and consume <ulink url="http://docs.jboss.org/weld/reference/latest/en-US/html/events.html">events</ulink> . This allows beans to interact in a completely decoupled fashion. Beans consume events by registering for a particular event type and optional qualifiers. The Errai CDI extension simply extends this concept into the client tier. A GWT client application can simply register an <literal><phrase role="code">Observer</phrase></literal> for a particular event type and thus receive events that are produced on the server-side. Likewise and using the same API, GWT clients can produce events that are consumed by a server-side observer.</simpara>
<simpara>Let&#8217;s take a look at an example.</simpara>
<example>
<title>FraudClient.java</title>
<programlisting language="java" linenumbering="unnumbered">public class FraudClient extends LayoutPanel {

  @Inject
  private Event&lt;AccountActivity&gt; event; (1)

  private HTML responsePanel;

  public FraudClient() {
    super(new BoxLayout(BoxLayout.Orientation.VERTICAL));
  }

  @PostConstruct
  public void buildUI() {
    Button button = new Button("Create activity", new ClickHandler() {
      public void onClick(ClickEvent clickEvent) {
        event.fire(new AccountActivity());
      }
    });
    responsePanel = new HTML();
    add(button);
    add(responsePanel);
  }

  public void processFraud(@Observes @Detected Fraud fraudEvent) { (2)
    responsePanel.setText("Fraud detected: " + fraudEvent.getTimestamp());
  }
}</programlisting>
</example>
<simpara>Two things are noteworthy in this example:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>Injection of an <literal><phrase role="code">Event</phrase></literal> dispatcher proxy</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Creation of an <literal><phrase role="code">Observer</phrase></literal> method for a particular event type</simpara>
      
    </listitem>
  
</orderedlist>
<simpara>The event dispatcher is responsible for sending events created on the client-side to the server-side event subsystem (CDI container). This means any event that is fired through a dispatcher will eventually be consumed by a CDI managed bean, if there is an corresponding <literal><phrase role="code">Observer</phrase></literal> registered for it on the server side.</simpara>
<simpara>In order to consume events that are created on the server-side you need to declare an client-side observer method for a particular event type. In case an event is fired on the server this method will be invoked with an event instance of type you declared.</simpara>
<simpara>To complete the example, let&#8217;s look at the corresponding server-side CDI bean:</simpara>
<example>
<title>AccountService.java</title>
<programlisting language="java" linenumbering="unnumbered">@ApplicationScoped
public class AccountService {

  @Inject @Detected
  private Event&lt;Fraud&gt; event;

  public void watchActivity(@Observes AccountActivity activity) {
    Fraud fraud = new Fraud(System.currentTimeMillis());
    event.fire(fraud);
 }
}</programlisting>
</example>
<section id="sid-21758054_Events-Conversationalevents">
<title>Conversational events</title>
<simpara>A server can address a single client in response to an event annotating event types as <literal><phrase role="code">@Conversational</phrase></literal> . Consider a service that responds to a subscription event.</simpara>
<example>
<title>SubscriptionService.java</title>
<programlisting language="java" linenumbering="unnumbered">@ApplicationScoped
public class SubscriptionService {

  @Inject
  private Event&lt;Documents&gt; welcomeEvent;

  public void onSubscription(@Observes Subscription subscription) {
    Document docs = createWelcomePackage(subscription);
    welcomeEvent.fire(docs);
 }
}</programlisting>
</example>
<simpara>And the <literal><phrase role="code">Document</phrase></literal> class would be annotated like so:</simpara>
<example>
<title>Document.java</title>
<programlisting language="java" linenumbering="unnumbered">@Conversational @Portable
public class Document {
   // code here
}</programlisting>
</example>
<simpara>As such, when <literal><phrase role="code">Document</phrase></literal> events are fired, they will be limited in scope to the initiating conversational contents  which are implicitly inferred by the caller. So only the client which fired the <literal><phrase role="code">Subscription</phrase></literal> event will receive the fired <literal><phrase role="code">Document</phrase></literal> event.</simpara>
</section>
<section id="sid-21758054_Events-ClientServerEventExample">
<title>Client-Server Event Example</title>
<simpara>A key feature of the Errai CDI framework is the ability to federate the CDI eventing bus between the client and the server. This permits the observation of server produced events on the client, and vice-versa.</simpara>
<simpara>Example server code:</simpara>
<example>
<title>MyServerBean.java</title>
<programlisting language="java" linenumbering="unnumbered">@ApplicationScoped
public class MyServerBean {
  @Inject
  Event&lt;MyResponseEvent&gt; myResponseEvent;

  public void myClientObserver(@Observes MyRequestEvent event) {
    MyResponseEvent response;

    if (event.isThankYou()) {
      // aww, that's nice!
      response = new MyResponseEvent("Well, you're welcome!");
    }
    else {
      // how rude!
      response = new MyResponseEvent("What? Nobody says 'thank you' anymore?");
    }

    myResponseEvent.fire(response);
  }
}</programlisting>
</example>
<simpara>Domain-model:</simpara>
<example>
<title>MyRequestEvent.java</title>
<programlisting language="java" linenumbering="unnumbered">@Portable
public class MyRequestEvent {
  private boolean thankYou;

  public MyRequestEvent(boolean thankYou) {
    setThankYou(thankYou);
  }

  public void setThankYou(boolean thankYou) {
    this.thankYou = thankYou;
  }

  public boolean isThankYou() {
    return thankYou;
  }
}</programlisting>
</example>
<example>
<title>MyResponseEvent.java</title>
<programlisting language="java" linenumbering="unnumbered">@Portable
public class MyResponseEvent {
  private String message;

  public MyRequestEvent(String message) {
    setMessage(message);
  }

  public void setMessage(String message) {
    this.message = message;
  }

  public String getMessage() {
    return message;
  }
}</programlisting>
</example>
<simpara>Client application logic:</simpara>
<example>
<title>MyClientBean.java</title>
<programlisting language="java" linenumbering="unnumbered">@EntryPoint
public class MyClientBean {
   @Inject
   Event&lt;MyRequestEvent&gt; requestEvent;

   public void myResponseObserver(@Observes MyResponseEvent event) {
     Window.alert("Server replied: " + event.getMessage());
   }

   @PostConstruct
   public void init() {
     Button thankYou = new Button("Say Thank You!");
     thankYou.addClickHandler(new ClickHandler() {
       public void onClick(ClickEvent event) {
         requestEvent.fire(new MyRequestEvent(true));
       }
     }

     Button nothing = new Button("Say nothing!");
     nothing.addClickHandler(new ClickHandler() {
       public void onClick(ClickEvent event) {
         requestEvent.fire(new MyRequestEvent(false));
       }
     }

     VerticalPanel vPanel = new VerticalPanel();
     vPanel.add(thankYou);
     vPanel.add(nothing);

     RootPanel.get().add(vPanel);
   }
}</programlisting>
</example>
</section>
</section>
<section id="sid-21758062">
<title>Producers</title>
<simpara>Producer methods and fields act as sources of objects to be injected. They are useful when additional control over object creation is needed before injections can take place e.g. when you need to make a decision at runtime before an object can be created and injected.</simpara>
<example>
<title>App.java</title>
<programlisting language="java" linenumbering="unnumbered">@EntryPoint
public class App {
  ...

  @Produces @Supported
  private MyBaseWidget createWidget() {
    return (Canvas.isSupported()) ? new MyHtml5Widget() : new MyDefaultWidget();
  }
}</programlisting>
</example>
<example>
<title>MyComposite.java</title>
<programlisting language="java" linenumbering="unnumbered">@ApplicationScoped
public class MyComposite extends Composite {

  @Inject @Supported
  private MyBaseWidget widget;

  ...
}
</programlisting>
</example>
<simpara>Producers can also be scoped themselves. By default, producer methods are dependent-scoped, meaning they get called every time an injection for their provided type is requested. If a producer method is scoped <literal><phrase role="code">@Singleton</phrase></literal> for instance, the method will only be called once, and the bean manager will inject the instance from the first invokation of the producer into every matching injection point.</simpara>
<example>
<title>Singleton producer</title>
<programlisting language="java" linenumbering="unnumbered">public class App {
  ...

  @Produces @Singleton
  private MyBean produceMyBean() {
    return new MyBean();
  }
}</programlisting>
</example>
<simpara>For more information on CDI producers, see the <ulink url="http://docs.jboss.org/cdi/spec/1.0/html/">CDI specification</ulink> and the <ulink url="http://seamframework.org/Weld/WeldDocumentation">WELD reference documentation</ulink> .</simpara>
</section>
<section id="sid-53118110">
<title>safe dynamic lookup</title>
<simpara>As an alternative to using the bean manager to dynamically create beans, this can be accomplished in a type-safe way by injecting a <literal><phrase role="code">javax.enterprise.inject.Instance&lt;T&gt;</phrase></literal> .</simpara>
<simpara>For instance, assume you have a dependent-scoped bean <literal><phrase role="code">Bar</phrase></literal> and consider the following:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Foo {
  @Inject Instance&lt;Bar&gt; barInstance;

  public void pingNewBar() {
    Bar bar = barInstance.get();
    bar.ping();
  }
}</programlisting>
<simpara>In this example, calling <literal><phrase role="code">barInstance.get()</phrase></literal> returns a new instance of the dependent-scoped bean <literal><phrase role="code">Bar</phrase></literal> .</simpara>
</section>
<section id="sid-5931501">
<title>Deploying Errai CDI</title>
<simpara>If you do not care about the deployment details for now and just want to get started take a look at the ERRAI:Quickstart Guide.</simpara>
<simpara>The CDI integration is a plugin to the Errai core framework and represents a CDI portable extension. Which means it is discovered automatically by both Errai and the CDI container. In order to use it, you first need to understand the different runtime models involved when working GWT, Errai and CDI.</simpara>
<simpara>Typically a GWT application lifecycle begins in <ulink url="http://code.google.com/webtoolkit/doc/latest/DevGuideCompilingAndDebugging.html">Development Mode</ulink> and finally a web application containing the GWT client code will be deployed to a target container (Servlet Engine, Application Server). This is no way different when working with CDI components to back your application.</simpara>
<simpara>What&#8217;s different however is availability of the CDI container across the different runtimes. In GWT development mode and in a pure servlet environment you need to provide and bootstrap the CDI environment on your own. While any Java EE 6 Application Server already provides a preconfigured CDI container. To accomodate these differences, we need to do a little trickery when executing the GWT Development Mode and packaging our application for deployment.</simpara>
<section id="sid-5931501_DeployingErraiCDI-DeploymentinDevelopmentMode">
<title>Deployment in Development Mode</title>
<simpara>In development mode we need to bootstrap the CDI environment on our own and make both Errai and CDI available through JNDI (common denominator across all runtimes). Since GWT uses Jetty, that only supports read only JNDI, we need to replace the default Jetty launcher with a custom one that will setup the JNDI bindings:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;plugin&gt;
  &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
  &lt;artifactId&gt;gwt-maven plugin&lt;/artifactId&gt;
  &lt;version&gt;${gwt.maven}&lt;/version&gt;

  &lt;configuration&gt;
  ...
    &lt;server&gt;org.jboss.errai.cdi.server.gwt.JettyLauncher&lt;/server&gt;
  &lt;/configuration&gt;
  &lt;executions&gt;
  ...
  &lt;/executions&gt;
&lt;/plugin&gt;</programlisting>
<note>
<title>Starting Development Mode from within your IDE</title>
<simpara>Consequently, when starting Development Mode from within your IDE the following program argument has to be provided: -server org.jboss.errai.cdi.server.gwt.JettyLauncher</simpara>
</note>
<section id="sid-5931501_DeployingErraiCDI-SpecialcaseClassloading">
<title>Special-case Classloading</title>
<simpara>JettyLauncher uses different class loaders to load classes that belongs to the web application, the Jetty server, and the Java standard library itself. In the majority of cases, you can simply put all dependencies into your web application&#8217;s <literal><phrase role="code">WEB-INF/lib</phrase></literal> folder. However, there are cases where putting a dependency in <literal><phrase role="code">WEB-INF/lib</phrase></literal> will cause troubles such as <literal><phrase role="code">ClassCastException</phrase></literal> when same class is also loaded by a different classloader. To mitigate this problem, JettyLauncher can be instructed that certain classes (or packages) shall be loaded only by the system class loader. To do so, set the Java system property <literal><phrase role="code">jetty.custom.sys.classes</phrase></literal> when launching Dev Mode.</simpara>
<simpara>For example, when using gwt-maven-plugin:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;extraJvmArgs&gt;-Djetty.custom.sys.classes=bitronix;javax.transaction&lt;/extraJvmArgs&gt;</programlisting>
<simpara>Once this is set up correctly, we can bootstrap the CDI container through a servlet listener:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;web-app&gt;
  ...
  &lt;listener&gt;
    &lt;listener-class&gt;org.jboss.errai.container.CDIServletStateListener&lt;/listener-class&gt;
  &lt;/listener&gt;

  &lt;resource-env-ref&gt;
    &lt;description&gt;Object factory for the CDI Bean Manager&lt;/description&gt;
    &lt;resource-env-ref-name&gt;BeanManager&lt;/resource-env-ref-name&gt;
    &lt;resource-env-ref-type&gt;javax.enterprise.inject.spi.BeanManager&lt;/resource-env-ref-type&gt;
  &lt;/resource-env-ref&gt;
  ...
&lt;/web-app&gt;</programlisting>
</section>
</section>
<section id="sid-5931501_DeployingErraiCDI-DeploymenttoaServletEngine">
<title>Deployment to a Servlet Engine</title>
<simpara>Deployment to servlet engine has basically the same requirements as running in development mode. You need to include the servlet listener that bootstraps the CDI container and make sure both Errai and CDI are accessible through JNDI. For Jetty you can re-use the artefacts we ship with the archetype. In case you want to run on tomcat, please consult the <ulink url="http://tomcat.apache.org/tomcat-5.5-doc/jndi-resources-howto.html">Apache Tomcat Documentation</ulink> .</simpara>
</section>
<section id="sid-5931501_DeployingErraiCDI-DeploymenttoanApplicationServer">
<title>Deployment to an Application Server</title>
<simpara>We provide integration with the <ulink url="http://jboss.org/jbossas">JBoss Application Server</ulink> , but the requirements are basically the same for other vendors. When running a GWT client app that leverages CDI beans on a Java EE 6 application server, CDI is already part of the container and accessible through JNDI ( <literal><phrase role="code">java:/BeanManager</phrase></literal> ).</simpara>
</section>
</section>
</chapter>
<chapter id="sid-5931328">
<title>Marshalling</title>
<simpara>Errai includes a comprehensive marshalling framework which permits the serialization of domain objects between the browser and the server. From the perspective of GWT, this is a complete replacement for the provided GWT serialization facilities and offers a great deal more flexibility. You are be able to map both application-specific domain model, as well as preexisting model, including model from third-party libraries using the custom definitions API.</simpara>
<section id="sid-5931328_Marshalling-MappingYourDomain">
<title>Mapping Your Domain</title>
<simpara>All classes that you intend to be marshalled between the client and the server must be exposed to the marshalling framework. There are several ways you can do it and this section will take you through the different approaches you can take to fit your needs.</simpara>
<section id="sid-5931328_Marshalling-@Portableand@NonPortable">
<title>@Portable and @NonPortable</title>
<simpara>To make a Java class eligible for serialization with Errai Marshalling, mark it with the <literal><phrase role="code">org.jboss.errai.common.client.api.annotations.Portable</phrase></literal> annotation. This tells the marshalling system to generate marshalling and demarshalling code for the annotated class and all of its nested classes.</simpara>
<simpara>The mapping strategy that will be used depends on how much information you provide about your model up-front. If you simply annotate a domain type with <literal><phrase role="code">@Portable</phrase></literal> and do nothing else, the marshalling system will use and exhaustive strategy to determine how to construct and deconstruct instances of that type and its nested types.</simpara>
<simpara>The Errai marshalling system works by enumerating all of the Portable types it can find (by any of the three methods discussed in this section of the reference guide), eliminating all the non-portable types it can find (via <literal><phrase role="code">@NonPortable</phrase></literal> annotations and entries in <literal><phrase role="code">ErraiApp.properties</phrase></literal> ), then enumerating the marshallable properties that make up each remaining portable entity type. The rules that Errai uses for enumerating the properties of a portable entity type are as follows:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>If an entity type has a field called <literal><phrase role="code">foo</phrase></literal> , then that entity has a property called <literal><phrase role="code">foo</phrase></literal> unless the field is marked <literal><phrase role="code">static</phrase></literal> or <literal><phrase role="code">transient</phrase></literal> .</simpara>
      
    </listitem>
  
</itemizedlist>

<simpara>Note that the existence of methods called <literal><phrase role="code">getFoo()</phrase></literal> , <literal><phrase role="code">setFoo()</phrase></literal> , or both, <emphasis>does not</emphasis> mean that the entity has a property called <literal><phrase role="code">foo</phrase></literal> . Errai Marshalling always works from fields when discovering properties.</simpara>
<simpara>When reading a field <literal><phrase role="code">foo</phrase></literal> , Errai Marshalling will call the method <literal><phrase role="code">getFoo()</phrase></literal> in preference to direct field access if the <literal><phrase role="code">getFoo()</phrase></literal> method exists.</simpara>
<simpara>Similarly, when writing a field <literal><phrase role="code">foo</phrase></literal> , Errai Marshalling will call the method <literal><phrase role="code">setFoo()</phrase></literal> in preference to direct field access if the <literal><phrase role="code">setFoo()</phrase></literal> method exists.</simpara>
<simpara>The above rules are sufficient for marshalling an existing entity to a JSON representation, but for de-marshalling, Errai must also know how to obtain an instance of a type. The rules that Errai uses for deciding how to create an instance of a <literal><phrase role="code">@Portable</phrase></literal> type are as follows:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>If the entity has a public constructor where every argument is annotated with <literal><phrase role="code">@MapsTo</phrase></literal> , and those parameters cover all properties of the entity type, then Errai uses this constructor to create the object, passing in all of the property values.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Otherwise, if the entity has a public static method where every argument is annotated with <literal><phrase role="code">@MapsTo</phrase></literal> , and those parameters cover all properties of the entity type, then Errai uses this method to create the object. Note that when using this mechanism you are free to create and return a subtype of the marshalled type, or resolve one from a cache.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>If the entity has a public no-arguments constructor (or no explicit constructors at all), it will be created via that constructor, and the properties will be written to the new object one at a time. Each property will be written by its setter method, or by direct field access if a setter method is not available.</simpara>
      
    </listitem>
  
</itemizedlist>

<simpara>Now let&#8217;s take a look at some common examples of how this works.</simpara>
<section id="sid-5931328_Marshalling-Example%3AASimpleEntity">
<title>Example: A Simple Entity</title>
<programlisting language="java" linenumbering="unnumbered">@Portable
public class Person {
  private String name;
  private int age;

  public Person() {
  }

  public Person(String name, int age) {
    this.name = name;
    this.age = age;
  }

  public String getName() {
    return name;
  }

  public int getAge() {
    return age;
  }
}</programlisting>
<simpara>This is a pretty vanilla domain object. Note the default, public, no-argument constructor. In this case, it will be necessary to have one explicitly declared. But notice we have no setters. In this case, the marshaler will rely on private field access to write the values on each side of the marshalling transaction. For simple domain objects, this is both nice and convenient. But you may want to make the class immutable and have a constructor enforce invariance. See the next section for that.</simpara>
</section>
<section id="sid-5931328_Marshalling-Example%3AAnImmutableEntitywithaPublicConstructor">
<title>Example: An Immutable Entity with a Public Constructor</title>
<simpara>Immutability is almost always a good practice, and the marshalling system provides you a straight forward way to tell it how to marshal and de-marshal objects which enforce an immutable contract. Let&#8217;s modify our example from the previous section.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Portable
public class Person {
  private final String name;
  private final int age;

  public Person(@MapsTo("name") String name, @MapsTo("age") int age) {
    this.name = name;
    this.age = age;
  }

  public String getName() {
    return name;
  }

  public int getAge() {
    return age;
  }
}</programlisting>
<simpara>Here we have set both of the class fields final. By doing so, we had to remove our default constructor. But that&#8217;s okay, because we have annotated the remaining constructor&#8217;s parameters using the <literal><phrase role="code">org.jboss.errai.marshalling.client.api.annotations.MapsTo</phrase></literal> annotation.</simpara>
<simpara>By doing this, we have told the marshaling system, for instance, that the first parameter of the constructor maps to the property <literal><phrase role="code">name</phrase></literal> . Which in this case, defaults to the name of the corresponding field. This may not always be the case  as will be explored in the section on custom definitions. But for now that&#8217;s a safe assumption.</simpara>
</section>
<section id="sid-5931328_Marshalling-Example%3AAnImmutableEntitywithaFactoryMethod">
<title>Example: An Immutable Entity with a Factory Method</title>
<simpara>Another good practice is to use a factory pattern to enforce invariance. Once again, let&#8217;s modify our example.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Portable
public class Person {
  private final String name;
  private final int age;

  private Person(String name, int age) {
    this.name = name;
    this.age = age;
  }

  public static Person createPerson(@MapsTo("name") String name, @MapsTo("age") int age) {
    return new Person(name, age);
  }

  public String getName() {
    return name;
  }

  public int getAge() {
    return age;
  }
}</programlisting>
<simpara>Here we have made our only declared constructor private, and created a static factory method. Notice that we&#8217;ve simply used the same <literal><phrase role="code">@MapsTo</phrase></literal> annotation in the same way we did on the constructor from our previous example. The marshaller will see this method and know that it should use it to construct the object.</simpara>
</section>
<section id="sid-5931328_Marshalling-Example%3AAnImmutableEntitywithaBuilder">
<title>Example: An Immutable Entity with a Builder</title>
<simpara>For types with a large number of optional attributes, a builder is often the best approach.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Portable
public class Person {
  private final String name;
  private final int age;

  private Person(@MapsTo("name") String name, @MapsTo("age") int age) {
    this.name = name;
    this.age = age;
  }

  public String getName() {
    return name;
  }

  public int getAge() {
    return age;
  }

  @NonPortable
  public static class Builder {
    private String name;
    private int age;

    public Builder name(String name) {
      this.name = name;
      return this;
    }

    public Builder age(int age) {
      this.age = age;
      return this;
    }

    public Person build() {
      return new Person(name, age);
    }
  }
}</programlisting>
<simpara>In this example, we have a nested <literal><phrase role="code">Builder</phrase></literal> class that implements the Builder Pattern and calls the private <literal><phrase role="code">Person</phrase></literal> constructor. Hand-written code will always use the builder to create <literal><phrase role="code">Person</phrase></literal> instances, but the <literal><phrase role="code">@MapsTo</phrase></literal> annotations on the private <literal><phrase role="code">Person</phrase></literal> constructor tell Errai Marshalling to bypass the builder and construct instances of Person directly.</simpara>
<simpara>One final note: as a nested type of <literal><phrase role="code">Person</phrase></literal> (which is marked <literal><phrase role="code">@Portable</phrase></literal> ), the builder itself would normally be portable. However, we do not intend to move instances of <literal><phrase role="code">Person.Builder</phrase></literal> across the network, so we mark <literal><phrase role="code">Person.Builder</phrase></literal> as <literal><phrase role="code">@NonPortable</phrase></literal> .</simpara>
</section>
</section>
<section id="sid-5931328_Marshalling-ManualMapping">
<title>Manual Mapping</title>
<simpara>Some classes may be out of your control, making it impossible to annotate them for auto-discovery by the marshalling framework. For cases such as this, there are two approaches which can be undertaken to include these classes in your application.</simpara>
<simpara>The first approach is the easiest, but is contingent on whether or not the class is directly exposed to the GWT compiler. That means, the classes must be part of a GWT module and within the GWT client packages. See the GWT documentation on <ulink url="http://code.google.com/webtoolkit/doc/latest/DevGuideCodingBasicsClient.html">Client-Side Code</ulink> for information on this.</simpara>
<section id="sid-5931328_Marshalling-MappingExistingClientClassesx">
<title>Mapping Existing Client Classes</title>
<simpara>If you have client-exposed classes that cannot be annotated with the <literal><phrase role="code">@Portable</phrase></literal> annotation, you may manually map these classes so that the marshaller framework will comprehend and produce marshallers for them and their nested types.</simpara>
<simpara>To do this, specify them in <emphasis>ErraiApp.properties</emphasis> , using the <literal><phrase role="code">errai.marshalling.serializableTypes</phrase></literal> attribute with a whitespace separated list of classes to make portable.</simpara>
<example>
<title>Example ErraiApp.properties defining portable classes.</title>
<programlisting language="ini" linenumbering="unnumbered">errai.marshalling.serializableTypes=org.foo.client.UserEntity \
                                    org.foo.client.GroupEntity \
                                    org.abcinc.model.client.Profile</programlisting>
</example>
<simpara>If any of the serializable types have nested classes that you wish to make non-portable, you can specify them like this:</simpara>
<example>
<title>Example ErraiApp.properties defining nonportable classes.</title>
<programlisting language="ini" linenumbering="unnumbered">errai.marshalling.nonserializableTypes=org.foo.client.UserEntity$Builder \
                                       org.foo.client.GroupEntity$Builder</programlisting>
</example>
</section>
<section id="sid-5931328_Marshalling-AliasedMappingsofExistingInterfaceContracts">
<title>Aliased Mappings of Existing Interface Contracts</title>
<simpara>The marshalling framework supports and promotes the concept of marshalling by interface contract, where possible. For instance, the framework ships with a marshaller which can marshall data to and from the <literal><phrase role="code">java.util.List</phrase></literal> interface. Instead of having custom marshallers for classes such as <literal><phrase role="code">ArrayList</phrase></literal> and <literal><phrase role="code">LinkedList</phrase></literal> , by default, these implementations are merely aliased to the <literal><phrase role="code">java.util.List</phrase></literal> marshaller.</simpara>
<simpara>There are two distinct ways to go about doing this. The most straightforward is to specify which marshaller to alias when declaring your class is <literal><phrase role="code">@Portable</phrase></literal> .</simpara>
<programlisting language="java" linenumbering="unnumbered">package org.foo.client;

@Portable(aliasOf = java.util.List.class)
public MyListImpl extends ArrayList {
  // .. //
}</programlisting>
<simpara>In the case of this example, the marshaller will not attempt to comprehend your class. Instead, it will merely rely on the <literal><phrase role="code">java.util.List</phrase></literal> marshaller to dematerialize and serialize instances of this type onto the wire.</simpara>
<simpara>If for some reason it is not feasible to annotate the class, directly, you may specify the mapping in the <emphasis>ErraiApp.properties</emphasis> file using the <literal><phrase role="code">errai.marshalling.mappingAliases</phrase></literal> attribute.</simpara>
<programlisting language="ini" linenumbering="unnumbered">errai.marshalling.mappingAliases=org.foo.client.MyListImpl-&gt;java.util.List \
                                 org.foo.client.MyMapImpl-&gt;java.util.Map</programlisting>
<simpara>The list of classes is whitespace-separated so that it may be split across lines.</simpara>
<simpara>The example above shows the equivalent mapping for the <literal><phrase role="code">MyListImpl</phrase></literal> class from the previous example, as well as a mapping of a class to the <literal><phrase role="code">java.util.Map</phrase></literal> marshaller.</simpara>
<simpara>The syntax of the mapping is as follows: <literal><phrase role="code">&lt;class_to_map&gt;</phrase></literal><emphasis>&#8594;</emphasis>[code]<literal>&lt;contract_to_map_to&gt;</literal> .</simpara>
<important>
<title>Aliases do not inherit functionality!</title>
<simpara>When you alias a class to another marshalling contract, extended functionality of the aliased class will not be available upon deserialization. For this you must provide custom marshallers for those classes.</simpara>
</important>
</section>
</section>
<section id="sid-5931328_Marshalling-ManualClassMapping">
<title>Manual Class Mapping</title>
<simpara>Although the default marshalling strategies in Errai Marshalling will suit the vast majority of use cases, there may be situations where it is necessary to manually map your classes into the marshalling framework to teach it how to construct and deconstruct your objects.</simpara>
<simpara>This is accomplished by specifying <literal><phrase role="code">MappingDefinition</phrase></literal> classes which inform the framework exactly how to read and write state in the process of constructing and deconstructing objects.</simpara>
<section id="sid-5931328_Marshalling-MappingDefinition">
<title>MappingDefinition</title>
<simpara>All manual mappings should extend the <literal><phrase role="code">org.jboss.errai.marshalling.rebind.api.model.MappingDefinition</phrase></literal> class. This is base metadata class which contains data on exactly how the marshaller can deconstruct and construct objects.</simpara>
<simpara>Consider the following class:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class MySuperCustomEntity {
   private final String mySuperName;
   private String mySuperNickname;

   public MySuperCustomEntity(String mySuperName) {
     this.mySuperName = mySuperName;;
   }

   public String getMySuperName() {
     return this.mySuperName;
   }

   public void setMySuperNickname(String mySuperNickname) {
     this.mySuperNickname = mySuperNickname;
   }

   public String getMySuperNickname() {
     return this.mySuperNickname;
   }
}</programlisting>
<simpara>Let us construct this object like so:</simpara>
<programlisting language="java" linenumbering="unnumbered">  MySuperCustomEntity entity = new MySuperCustomEntity("Coolio");
  entity.setSuperNickname("coo");</programlisting>
<simpara>It is clear that we may rely on this object&#8217;s two getter methods to extract the totality of its state. But due to the fact that the <literal><phrase role="code">mySuperName</phrase></literal> field is final, the only way to properly construct this object is to call its only public constructor and pass in the desired value of <literal><phrase role="code">mySuperName</phrase></literal> .</simpara>
<simpara>Let us consider how we could go about telling the marshalling framework to pull this off:</simpara>
<programlisting language="java" linenumbering="unnumbered">@CustomMapping
public MySuperCustomEntityMapping extends MappingDefinition {
  public MySuperCustomEntityMapping() {
    super(MySuperCustomEntity.class);                                                          // (1)

    SimpleConstructorMapping cnsMapping = new SimpleConstructorMapping();
    cnsMapping.mapParmToIndex("mySuperName", 0, String.class);                                 // (2)

    setInstantiationMapping(cnsMapping);

    addMemberMapping(new WriteMapping("mySuperNickname", String.class, "setMySuperNickname")); // (3)

    addMemberMapping(new ReadMapping("mySuperName", String.class, "getMySuperName"));          // (4)
    addMemberMapping(new ReadMapping("mySuperNickname", String.class, "getMySuperNickname"));  // (5)
  }
}</programlisting>
<simpara>And that&#8217;s it. This describes to the marshalling framework how it should go about constructing and deconstructing <literal><phrase role="code">MySuperCustomEntity</phrase></literal> .</simpara>
<simpara>Paying attention to our annotating comments, let&#8217;s describe what we&#8217;ve done here.</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>Call the constructor in <literal><phrase role="code">MappingDefinition</phrase></literal> passing our reference to the class we are mapping.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Using the <literal><phrase role="code">SimpleConstructorMapping</phrase></literal> class, we have indicated that a custom constructor will be needed to instantiate this class. We have called the <literal><phrase role="code">mapParmToIndex</phrase></literal> method with three parameters. The first, <literal><phrase role="code">"mySupername"</phrase></literal> describes the class field that we are targeting. The second parameter, the integer <literal><phrase role="code">0</phrase></literal> indicates the parameter index of the constructor arguments that we&#8217;ll be providing the value for the aforementioned field  in this case the first and only, and the final parameter <literal><phrase role="code">String.class</phrase></literal> tells the marshalling framework which marshalling contract to use in order to de-marshall the value.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Using the <literal><phrase role="code">WriteMapping</phrase></literal> class, we have indicated to the marshaller framework how to write the <literal><phrase role="code">"mySuperNickname"</phrase></literal> field, using the <literal><phrase role="code">String.class</phrase></literal> marshaller, and using the setter method <literal><phrase role="code">setMySuperNickname</phrase></literal> .</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Using the <literal><phrase role="code">ReadMapping</phrase></literal> class, we have indicated to the marshaller framework how to read the <literal><phrase role="code">"mySuperName"</phrase></literal> field, using the <literal><phrase role="code">String.class</phrase></literal> marshaller, and using the getter method <literal><phrase role="code">getMySuperName</phrase></literal> .</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Using the <literal><phrase role="code">ReadMapping</phrase></literal> class, we have indicated to the marshaller framework how to read the <literal><phrase role="code">"mySuperNickname"</phrase></literal> field, using the <literal><phrase role="code">String.class</phrase></literal> marshaller, and using the getter method <literal><phrase role="code">getMySuperNickname</phrase></literal> .</simpara>
      
    </listitem>
  
</orderedlist>
</section>
</section>
<section id="sid-5931328_Marshalling-CustomMarshallers">
<title>Custom Marshallers</title>
<simpara>There is another approach to extending the marshalling functionality that doesn&#8217;t involve mapping rules, and that is to implement your own <literal><phrase role="code">Marshaller</phrase></literal> class. This gives you complete control over the parsing and emission of the JSON structure.</simpara>
<simpara>The implementation of marshallers is made relatively straight forward by the fact that both the server and the client share the same JSON parsing API.</simpara>
<simpara>Consider the included <literal><phrase role="code">java.util.Date</phrase></literal> marshaller that comes built-in to the marshalling framework:</simpara>
<example>
<title>DataMarshaller.java from the built-in marshallers</title>
<programlisting language="java" linenumbering="unnumbered">@ClientMarshaller(Date.class)
@ServerMarshaller(Date.class)
public class DateMarshaller extends AbstractNullableMarshaller&lt;Date&gt; {
  @Override
  public Date[] getEmptyArray() {
    return new Date[0];
  }

  @Override
  public Date doNotNullDemarshall(final EJValue o, final MarshallingSession ctx) {
    if (o.isObject() != null) {
      EJValue qualifiedValue = o.isObject().get(SerializationParts.QUALIFIED_VALUE);
      if (!qualifiedValue.isNull() &amp;&amp; qualifiedValue.isString() != null) {
        return new Date(Long.parseLong(qualifiedValue.isString().stringValue()));
      }
      EJValue numericValue = o.isObject().get(SerializationParts.NUMERIC_VALUE);
      if (!numericValue.isNull() &amp;&amp; numericValue.isNumber() != null) {
        return new Date(new Double(numericValue.isNumber().doubleValue()).longValue());
      }
      if (!numericValue.isNull() &amp;&amp; numericValue.isString() != null) {
        return new Date(Long.parseLong(numericValue.isString().stringValue()));
      }
    }

    return null;
  }

  @Override
  public String doNotNullMarshall(final Date o, final MarshallingSession ctx) {
    return "{\"" + SerializationParts.ENCODED_TYPE + "\":\"" + Date.class.getName() + "\"," +
            "\"" + SerializationParts.OBJECT_ID + "\":\"" + o.hashCode() + "\"," +
            "\"" + SerializationParts.QUALIFIED_VALUE + "\":\"" + o.getTime() + "\"}";
  }
}</programlisting>
</example>
<simpara>The class is annotated with both <literal><phrase role="code">@ClientMarshaller</phrase></literal> and <literal><phrase role="code">@ServerMarshaller</phrase></literal> indicating that this class should be used for both marshalling on the client and on the server.</simpara>
<simpara>The <literal><phrase role="code">doNotNullDemarshall()</phrase></literal> method is responsible for converting the given JSON object (which has already been parsed and verified non-null) into a Java object.</simpara>
<simpara>The <literal><phrase role="code">doNotNullMarshall()</phrase></literal> method does roughly the inverse: it converts the given Java object into a String (which must be parseable as a JSON object) for transmission on the wire.</simpara>
</section>
</section>
</chapter>
<chapter id="sid-5931313">
<title>Remote Procedure Calls (RPC)</title>
<simpara>ErraiBus supports a high-level RPC layer to make typical client-server RPC communication easy on top of the bus. While it is possible to use ErraiBus without ever using this API, you may find it to be a more useful and concise approach for exposing services to the clients.</simpara>
<simpara>Please note that this API has changed since version 1.0. RPC services provide a way of creating type-safe mechanisms to make client-to-server calls. Currently, this mechanism only support client-to-server calls, and not vice-versa.</simpara>
<simpara>Creating a service is straight forward. It requires the definition of a remote interface, and a service class which implements it. See the following:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Remote
public interface MyRemoteService {
  public boolean isEveryoneHappy();
}</programlisting>
<simpara>The <literal><phrase role="code">@Remote</phrase></literal> annotation tells Errai that we&#8217;d like to use this interface as a remote interface. The remote interface must be part of of the GWT client code. It cannot be part of the server-side code, since the interface will need to be referenced from both the client and server side code. That said, the implementation of a service is relatively simple to the point:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Service
public class MyRemoteServiceImpl implements MyRemoteService {

  public boolean isEveryoneHappy() {
    // blatently lie and say everyone's happy.
    return true;
  }
}</programlisting>
<simpara>That&#8217;s all there is to it. You use the same <literal><phrase role="code">@Service</phrase></literal> annotation as described in Section 2.4. The presence of the remote interface tips Errai off as to what you want to do with the class.</simpara>
<warning>
<simpara>Beginning with Errai 2.0.CR1, the default for automatic service discovery has changed in favour of CDI based applications, meaning RPC service discovery must be explicitly turned on in case Errai CDI is not used (the <literal><phrase role="code">weld-integration.jar</phrase></literal> is not on the classpath). This can be done using an init-param in the servlet config of your web.xml:</simpara>
</warning>
<programlisting language="xml" linenumbering="unnumbered">&lt;servlet&gt;
  &lt;servlet-name&gt;ErraiServlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;org.jboss.errai.bus.server.servlet.DefaultBlockingServlet&lt;/servlet-class&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;auto-discover-services&lt;/param-name&gt;
    &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;</programlisting>
<section id="sid-5931313_RemoteProcedureCalls%28RPC%29-Makingcalls">
<title>Making calls</title>
<simpara>Calling a remote service involves use of the <literal><phrase role="code">MessageBuilder</phrase></literal> API. Since all messages are asynchronous, the actual code for calling the remote service involves the use of a callback, which we use to receive the response from the remote method. Let&#8217;s see how it works:</simpara>
<programlisting language="java" linenumbering="unnumbered">MessageBuilder.createCall(new RemoteCallback&lt;Boolean&gt;() {
  public void callback(Boolean isHappy) {
    if (isHappy) Window.alert("Everyone is happy!");
  }
 }, MyRemoteService.class).isEveryoneHappy();
</programlisting>
<simpara>In the above example, we declare a remote callback that receives a Boolean, to correspond to the return value of the method on the server. We also reference the remote interface we are calling, and directly call the method. However, <emphasis>don&#8217;t be tempted to write code like this</emphasis> :</simpara>
<programlisting language="java" linenumbering="unnumbered"> boolean bool = MessageBuilder.createCall(..., MyRemoteService.class).isEveryoneHappy();</programlisting>
<simpara>The above code will never return a valid result. In fact, it will always return null, false, or 0 depending on the type. This is due to the fact that the method is dispatched asynchronously, as in, it does not wait for a server response before returning control. The reason we chose to do this, as opposed to emulate the native GWT-approach, which requires the implementation of remote and async interfaces, was purely a function of a tradeoff for simplicity.</simpara>
<section id="sid-5931313_RemoteProcedureCalls%28RPC%29-ProxyInjection">
<title>Proxy Injection</title>
<simpara>An alternative to using the <literal><phrase role="code">MessageBuilder</phrase></literal> API is to have a proxy of the service injected.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Inject
private Caller&lt;MyRemoteService&gt; remoteService;</programlisting>
<simpara>For calling the remote service, the callback objects need to be provided to the <literal><phrase role="code">call</phrase></literal> method before the corresponding interface method is invoked.</simpara>
<programlisting language="java" linenumbering="unnumbered">remoteService.call(callback).isEveryoneHappy();</programlisting>
<simpara>The Errai IOC GWT module needs to be inherited to make use of caller injection. To do this, the following line needs to be added to the application&#8217;s <literal><phrase role="code">\*.gwt.xml</phrase></literal> file. It is important that this line comes <literal><phrase role="code">after</phrase></literal> the Errai Bus module:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;inherits name="org.jboss.errai.ioc.Container"/&gt;</programlisting>
</section>
</section>
<section id="sid-5931313_RemoteProcedureCalls%28RPC%29-Handlingexceptions">
<title>Handling exceptions</title>
<simpara>Handling remote exceptions can be done by providing an <literal><phrase role="code">ErrorCallback</phrase></literal> on the client:</simpara>
<programlisting language="java" linenumbering="unnumbered">MessageBuilder.createCall(
  new RemoteCallback&lt;Boolean&gt;() {
    public void callback(Boolean isHappy) {
      if (isHappy) Window.alert("Everyone is happy!");
    }
  },
  new ErrorCallback() {
    public boolean error(Message message, Throwable caught) {
      try {
        throw caught;
      }
      catch (NobodyIsHappyException e) {
        Window.alert("OK, that's sad!");
      }
      catch (Throwable t) {
        GWT.log("An unexpected error has occurred", t);
      }
      return false;
    }
  },
  MyRemoteService.class).isEveryoneHappy();</programlisting>
<simpara>As remote exceptions need to be serialized to be sent to the client, the <literal><phrase role="code">@Portable</phrase></literal> annotation needs to be present on the corresponding exception class (see <xref linkend="sid-5931328"/> ). Further the exception class needs to be part of the client-side code. For more details on <literal><phrase role="code">ErrorCallbacks</phrase></literal> see <xref linkend="sid-5931306"/> .</simpara>
<section id="sid-5931313_RemoteProcedureCalls%28RPC%29-GlobalRPCexceptionhandler">
<title>Global RPC exception handler</title>
<simpara>In a scenario where many different remote calls potentially throw the same exception types (e.g. exceptions related to authentication or authorization) it can be easier to register a global exception handler instead of providing error callbacks at each RPC invocation. This global exception handler is called in case an exception occurs in the process of a remote call that has no error callback associated with it. So, it will handle an otherwise uncaught exception.</simpara>
<programlisting language="java" linenumbering="unnumbered">@UncaughtException
private void onUncaughtException(Throwable t) {
  try {
    throw caught;
  }
  catch (UserNotLoggedInException e) {
    // navigate to login dialog
  }
  catch (Throwable t) {
    GWT.log("An unexpected error has occurred", t);
  }
}</programlisting>
</section>
</section>
<section id="sid-5931313_RemoteProcedureCalls%28RPC%29-ClientsideInterceptors">
<title>Client-side Interceptors</title>
<simpara>Client-side remote call interceptors provide the ability to manipulate or bypass the remote call before it&#8217;s being sent. This is useful for implementing crosscutting concerns like caching, for example when the remote call should be avoided if the data is already cached locally.</simpara>
<simpara>To have a remote call intercepted, either an interface method or the remote interface type has to be annotated with <literal><phrase role="code">@InterceptedCall</phrase></literal> . If the type is annotated, all interface methods will be intercepted.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Remote
public interface CustomerService {

  @InterceptedCall(MyCacheInterceptor.class)
  public Customer retrieveCustomerById(long id);
}</programlisting>
<simpara>Note that an ordered list of interceptors can be used for specifying an interceptor chain e.g.</simpara>
<programlisting language="java" linenumbering="unnumbered">@InterceptedCall({MyCacheInterceptor.class, MySecurityInterceptor.class})
public Customer retrieveCustomerById(long id);
</programlisting>
<simpara>Implementing an interceptor is easy:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class MyCacheInterceptor implements RpcInterceptor {

  @Override
  public void aroundInvoke(final RemoteCallContext context) {
    // e.g check if the result is cached and carry out the actual call only in case it's not.
    context.proceed() // executes the next interceptor in the chain or the actual remote call.
    // context.setResult() // sets the result directly without carrying out the remote call.
  }
}</programlisting>
<simpara>The <literal><phrase role="code">RemoteCallContext</phrase></literal> passed to the <literal><phrase role="code">aroundInvoke</phrase></literal> method provides access to the intercepted method&#8217;s name and read/write access to the parameter values provided at the call site.</simpara>
<simpara>Calling <literal><phrase role="code">proceed</phrase></literal> executes the next interceptor in the chain or the actual remote call if all interceptors have already been executed. If access to the result of the (asynchronous) remote call is needed in the interceptor, one of the overloaded versions of <literal><phrase role="code">proceed</phrase></literal> accepting a <literal><phrase role="code">RemoteCallback</phrase></literal> has to be used instead.</simpara>
<simpara>The result of the remote call can be manipulated by calling <literal><phrase role="code">RemoteCallContext.setResult()</phrase></literal> .</simpara>
<simpara>Not calling <literal><phrase role="code">proceed</phrase></literal> in the interceptor bypasses the actual remote call, passing <literal><phrase role="code">RestCallContext.getResult()</phrase></literal> to the <literal><phrase role="code">RemoteCallBack</phrase></literal> provided at the call site.</simpara>
</section>
<section id="sid-5931313_RemoteProcedureCalls%28RPC%29-SessionandrequestobjectsinRPCendpoints">
<title>Session and request objects in RPC endpoints</title>
<simpara>Before invoking an endpoint method Errai sets up an <literal><phrase role="code">RpcContext</phrase></literal> that provides access to message resources that are otherwise not visible to RPC endpoints.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Service
public class MyRemoteServiceImpl implements MyRemoteService {

  public boolean isEveryoneHappy() {
    HttpSession session = RpcContext.getHttpSession();
    ServletRequest request = RpcContext.getServletRequest();
    ...
    return true;
  }
}</programlisting>
</section>
<section id="sid-5931313_RemoteProcedureCalls%28RPC%29-Batchingremotecalls">
<title>Batching remote calls</title>
<simpara>Some use cases require multiple interactions with the server to complete. Errai&#8217;s RPC mechanism allows for batched invocations of remote methods that will be executed using a single server round-trip. This is useful for reducing the number of simultaneous HTTP connections and at the same time allows for reusing and combining fine-grained remote services.</simpara>
<simpara>Injecting a BatchCaller instead of a Caller&lt;T&gt; is all it takes to make use of batched remote procedure calls.</simpara>
<programlisting language="java" linenumbering="unnumbered">@EntryPoint
public class MyBean {

 @Inject
 private BatchCaller batchCaller;

 private void someMethod() {
    // ...
    batchCaller.call(remoteCallback1, RemoteService1.class).method1();
    batchCaller.call(remoteCallback2, RemoteService2.class).method2();

    // Invokes the accumulated remote requests using a single server round-trip.
    batchCaller.sendBatch();
 }

}</programlisting>
<simpara>The remote methods will get executed only after <literal><phrase role="code">sendBatch()</phrase></literal> was called. The method <literal><phrase role="code">sendBatch</phrase></literal> accepts an additional <literal><phrase role="code">RemoteCallback</phrase></literal> instance as a parameter which will we invoked when all remote calls have completed in success. Consequently, an <literal><phrase role="code">ErrorCallback</phrase></literal> can also be provided which will get executed for all remote calls that have completed in failure.</simpara>
</section>
</chapter>
<chapter id="sid-19398997">
<title>Errai JAX-RS</title>
<simpara>JAX-RS (Java API for RESTful Web Services) is a Java EE standard (JSR-311) for implementing REST-based Web services in Java. Errai JAX-RS brings this standard to the browser and simplifies the integration of REST-based services in GWT client applications. Errai can generate proxies based on JAX-RS interfaces which will handle all the underlying communication and serialization logic. All that&#8217;s left to do is to invoke a Java method.</simpara>
<simpara>Errai&#8217;s JAX-RS support consists of the following:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>A client-side API to communicate with JAX-RS endpoints</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>A code generator that runs at your project&#8217;s build time, providing proxy implementations for each JAX-RS resource interfaces visible within the GWT module</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Errai IoC and CDI providers that allow you to <literal><phrase role="code">@Inject</phrase></literal> instances of {{Caller&lt;T&gt;} (the same API used in Errai RPC)}</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Integration with either Errai Marshalling or Jackson to translate request and response data between Java object and a string-based wire format</simpara>
      
    </listitem>
  
</itemizedlist>

<simpara>To get started with a working demo that makes use of Errai JAX-RS you can either download and unzip the <ulink url="https://github.com/errai/errai-tutorial/archive/master.zip">Errai tutorial project</ulink> or check out the CRUD demo part of our <ulink url="https://github.com/errai/errai/tree/master/errai-demos">demo collection</ulink> . If you prefer getting started from scratch keep reading .TODO Gliffy image title empty
image::author/images/icons/emoticons/smile.gif[]</simpara>
<simpara>.</simpara>
<section id="sid-19398997_ErraiJAX-RS-GettingStarted">
<title>Getting Started</title>
<section id="sid-19398997_ErraiJAX-RS-Dependencies">
<title>Dependencies</title>
<simpara>To use Errai JAX-RS, you must include it on the compile-time classpath. If you are using Maven for your build, add this dependency:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.errai&lt;/groupId&gt;
      &lt;artifactId&gt;errai-jaxrs-client&lt;/artifactId&gt;
      &lt;version&gt;${errai.version}&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;</programlisting>
<simpara>or if you are not using Maven for dependency management, add <literal><phrase role="code">errai-jaxrs-client-version.jar</phrase></literal> to your classpath.</simpara>
<simpara>If you intend to use Errai&#8217;s JSON format on the wire you will need to add Errai&#8217;s JAX-RS JSON provider to your classpath and make sure it gets deployed to the server.</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.errai&lt;/groupId&gt;
      &lt;artifactId&gt;errai-jaxrs-provider&lt;/artifactId&gt;
      &lt;version&gt;${errai.version}&lt;/version&gt;
    &lt;/dependency&gt;
</programlisting>
<simpara>or manually add <literal><phrase role="code">errai-jaxrs-provider-version.jar</phrase></literal> in case you&#8217;re not using Maven. If your REST service returns Jackson generated JSON you do not need the errai-jaxrs-provider (see <link linkend="sid-19398997_ErraiJAX-RS-Configuration">Configuration</link> ) .</simpara>
</section>
<section id="sid-19398997_ErraiJAX-RS-GWTModule">
<title>GWT Module</title>
<simpara>Once you have Errai JAX-RS on your classpath, ensure your application inherits the GWT module as well. Add this line to your application&#8217;s <literal><phrase role="code">\*.gwt.xml</phrase></literal> file:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;inherits name="org.jboss.errai.enterprise.Jaxrs"/&gt;</programlisting>
</section>
<section id="sid-19398997_ErraiJAX-RS-ServerSideJAXRSImplementation">
<title>Server-Side JAX-RS Implementation</title>
<simpara>Errai&#8217;s JAX-RS support consists mostly of features that make the client side easier and more reliable to maintain. You will need to use an existing third-party JAX-RS implementation on the server side. All Java EE 6 application servers include such a module out-of-the-box. If you are developing an application that you intend to deploy on a plain servlet container, you will have to choose a JAX-RS implementation (for example, RestEasy) and configure it properly in your web.xml.</simpara>
<simpara>Alternatively, you could keep your REST resource layer in a completely separate web application hosted on the same server (perhaps build an Errai JAX-RS client against an existing REST service you developed previously). In this case, you could factor out the shared JAX-RS interface into a shared library, leaving the implementation in the non-Errai application.</simpara>
<simpara>Finally, you can take advantage of the cross-origin resource sharing (CoRS) feature in modern browsers and use Errai JAX-RS to send requests to a third-party server. The third-party server would have to be configured to allow cross-domain requests. In this case, you would write a JAX-RS-Annotated interface describing the remote REST resources, but you would not create an implementation of that interface.</simpara>
</section>
<section id="sid-19398997_ErraiJAX-RS-SharedJAXRSInterface">
<title>Shared JAX-RS Interface</title>
<simpara>Errai JAX-RS works by leveraging standard Java interfaces that bear JAX-RS annotations. You will also want these interfaces visible to server-side code so that your JAX-RS resource classes can implement them (and inherit the annotations). This keeps the whole setup typesafe, and reduces duplication to the bare minimum. The natural solution, then is to put the JAX-RS interfaces under the client.shared package within your GWT module:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>project</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>src</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>main</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>java</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>com.mycompany.myapp</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>MyApp.gwt.xml <emphasis>[the app&#8217;s GWT module]</emphasis></simpara>
      
    </listitem>
  
    <listitem>
      <simpara>com.mycompany.myapp.client.local</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>MyAppClientStuff.java <emphasis>[code that @Injects Caller&lt;MyAppRestResource&gt;]</emphasis></simpara>
      
    </listitem>
  
    <listitem>
      <simpara>com.mycompany.myapp.client.shared</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>CustomerService.java <emphasis>[the JAX-RS interface]</emphasis></simpara>
      
    </listitem>
  
    <listitem>
      <simpara>com.mycompany.myapp.server</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>CustomerServiceImpl.java <emphasis>[the server-side JAX-RS resource implementation]</emphasis></simpara>
      
    </listitem>
  
</itemizedlist>

<simpara>The contents of the server-side files would be as follows:</simpara>
<example>
<title>CustomerService.java</title>
<programlisting language="java" linenumbering="unnumbered">@Path("customers")
public interface CustomerService {
  @GET
  @Produces("application/json")
  public List&lt;Customer&gt; listAllCustomers();

  @POST
  @Consumes("application/json")
  @Produces("text/plain")
  public long createCustomer(Customer customer);
}</programlisting>
</example>
<simpara>The above interface is visible both to server-side code and to client-side code. It is used by client-side code to describe the available operations, their parameter types, and their return types. If you use your IDE&#8217;s refactoring tools to modify this interface, both the server-side and client-side code will be updated automatically.</simpara>
<example>
<title>CustomerServiceImpl.java</title>
<programlisting language="java" linenumbering="unnumbered">public class CustomerServiceImpl implements CustomerService {

  @Override
  public List&lt;Customer&gt; listAllCustomers() {
    // Use a database API to look up all customers in back-end data store
    // Return the resulting list
  }

  @Override
  public long createCustomer(Customer customer) {
    // Store new Customer instance in back-end data store
  }
}</programlisting>
</example>
<simpara>The above class implements the shared interface. Since it performs database and/or filesystem operations to manipulate the persistent data store, it is not GWT translatable, and it&#8217;s therefore kept in a package that is not part of the GWT module.</simpara>
<important>
<title>Save typing and reduce duplication</title>
<simpara>Note that all JAX-RS annotations ( <literal><phrase role="code">@Path</phrase></literal> , <literal><phrase role="code">@GET</phrase></literal> , <literal><phrase role="code">@Consumes</phrase></literal> , and so on) can be inherited from the interface. You do not need to repeat these annotations in your resource implementation classes.</simpara>
</important>
</section>
</section>
<section id="sid-19398997_ErraiJAX-RS-CreatingRequests">
<title>Creating Requests</title>
<simpara>This section assumes you have already set up the CustomerService JAX-RS endpoint as described in the previous section.</simpara>
<simpara>To create a request on the client, all that needs to be done is to invoke <literal><phrase role="code">RestClient.create()</phrase></literal> , thereby providing the JAX-RS interface, a response callback and to invoke the corresponding interface method:</simpara>
<example>
<title>App.java</title>
<programlisting language="java" linenumbering="unnumbered">...
Button create = new Button("Create", new ClickHandler() {
  public void onClick(ClickEvent clickEvent) {
    Customer customer = new Customer(firstName, lastName, postalCode);
    RestClient.create(CustomerService.class, callback).createCustomer(customer);
  }
});
...</programlisting>
</example>
<simpara>For details on the callback mechanism see <link linkend="sid-19398997_ErraiJAX-RS-HandlingResponses">Handling Responses</link> .</simpara>
<section id="sid-19398997_ErraiJAX-RS-ProxyInjection">
<title>Proxy Injection</title>
<simpara>Injectable proxies can be used as an alternative to calling <literal><phrase role="code">RestClient.create()</phrase></literal> .</simpara>
<programlisting language="java" linenumbering="unnumbered">@Inject
private Caller&lt;CustomerService&gt; customerService;</programlisting>
<simpara>To create a request, the callback objects need to be provided to the <literal><phrase role="code">call</phrase></literal> method before the corresponding interface method is invoked.</simpara>
<programlisting language="java" linenumbering="unnumbered">customerService.call(callback).listAllCustomers();</programlisting>
<simpara>To use caller injection, your application needs to inherit the Errai IOC GWT module. To do this, just add this line to your application&#8217;s <literal><phrase role="code">\*.gwt.xml</phrase></literal> file and make sure it comes <literal><phrase role="code">after</phrase></literal> the Errai JAX-RS module (see <link linkend="sid-19398997_ErraiJAX-RS-GettingStarted">Getting Started</link> ):</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;inherits name="org.jboss.errai.ioc.Container"/&gt;
</programlisting>
<note>
<simpara>The JAX-RS interfaces need to be visible to the GWT compiler and must therefore reside within the client packages (e.g. client.shared).</simpara>
</note>
</section>
</section>
<section id="sid-19398997_ErraiJAX-RS-HandlingResponses">
<title>Handling Responses</title>
<simpara>An instance of Errai&#8217;s <literal><phrase role="code">RemoteCallback&lt;T&gt;</phrase></literal> has to be passed to the <literal><phrase role="code">RestClient.create()</phrase></literal> call, which will provide access to the JAX-RS resource method&#8217;s result. <literal><phrase role="code">T</phrase></literal> is the return type of the JAX-RS resource method. In the example below it&#8217;s just a <literal><phrase role="code">Long</phrase></literal> representing a customer ID, but it can be any serializable type (see <xref linkend="sid-5931328"/> ).</simpara>
<programlisting language="java" linenumbering="unnumbered">RemoteCallback&lt;Long&gt; callback = new RemoteCallback&lt;Long&gt;() {
  public void callback(Long id) {
    Window.alert("Customer created with ID: " + id);
  }
};</programlisting>
<simpara>A special case of this <literal><phrase role="code">RemoteCallback</phrase></literal> is the <literal><phrase role="code">ResponseCallback</phrase></literal> which can be used as an alternative. It provides access to the <literal><phrase role="code">Response</phrase></literal> object representing the underlying HTTP response. This is useful when more details of the HTTP response are needed, such as headers and the status code. The <literal><phrase role="code">ResponseCallback</phrase></literal> can also be used for JAX-RS interface methods that return a <literal><phrase role="code">javax.ws.rs.core.Response</phrase></literal> type. In this case, the <literal><phrase role="code">MarshallingWrapper</phrase></literal> class can be used to manually demarshall the response body to an entity of the desired type.</simpara>
<programlisting language="java" linenumbering="unnumbered">ResponseCallback callback = new ResponseCallback() {
  public void callback(Response response) {
    Window.alert("HTTP status code: " + response.getStatusCode());
    Window.alert("HTTP response body: " + response.getText());
  }
};</programlisting>
<simpara>For handling errors, Errai&#8217;s error callback mechanism can be reused and an instance of <literal><phrase role="code">ErrorCallback</phrase></literal> can optionally be passed to the <literal><phrase role="code">RestClient.create()</phrase></literal> call. In case of an HTTP error, the <literal><phrase role="code">ResponseException</phrase></literal> provides access to the <literal><phrase role="code">Response</phrase></literal> object. All other <literal><phrase role="code">Throwables</phrase></literal> indicate a communication problem.</simpara>
<programlisting language="java" linenumbering="unnumbered">ErrorCallback errorCallback = new RestErrorCallback() {
  public boolean error(Request request, Throwable throwable) {
    try {
      throw throwable;
    }
    catch (ResponseException e) {
      Response response = e.getResponse();
      // process unexpected response
      response.getStatusCode();
    }
    catch (Throwable t) {
      // process unexpected error (e.g. a network problem)
    }
    return false;
  }
};</programlisting>
</section>
<section id="sid-19398997_ErraiJAX-RS-ClientsideInterceptors">
<title>Client-side Interceptors</title>
<simpara>Client-side remote call interceptors provide the ability to manipulate or bypass the request before it&#8217;s being sent. This is useful for implementing crosscutting concerns like caching or security features e.g:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>avoiding the request when the data is cached locally</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>adding special HTTP headers or parameters to the request</simpara>
      
    </listitem>
  
</itemizedlist>

<simpara>To have a JAX-RS remote call intercepted, either an interface method or the remote interface type has to be annotated with <literal><phrase role="code">@InterceptedCall</phrase></literal> . If the type is annotated, all interface methods will be intercepted.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Path("customers")
public interface CustomerService {

  @GET
  @Path("/{id}")
  @Produces("application/json")
  @InterceptedCall(MyCacheInterceptor.class)
  public Customer retrieveCustomerById(@PathParam("id") long id);
}</programlisting>
<simpara>Note that an ordered list of interceptors can be used for specifying an interceptor chain e.g.</simpara>
<programlisting language="java" linenumbering="unnumbered">@InterceptedCall({MyCacheInterceptor.class, MySecurityInterceptor.class})
public Customer retrieveCustomerById(@PathParam("id") long id);</programlisting>
<simpara>Implementing an interceptor is easy:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class MyCacheInterceptor implements RestClientInterceptor {

  @Override
  public void aroundInvoke(final RestCallContext context) {
    RequestBuilder builder = context.getRequestBuilder();
    builder.setHeader("headerName", "value");
    context.proceed();
  }
}</programlisting>
<simpara>The <literal><phrase role="code">RestCallContext</phrase></literal> passed to the <literal><phrase role="code">aroundInvoke</phrase></literal> method provides access to the context of the intercepted JAX-RS (REST) remote call. It allows to read and write the parameter values provided at the call site and provides read/write access to the <literal><phrase role="code">RequestBuilder</phrase></literal> instance which has the URL, HTTP headers and parameters set.</simpara>
<simpara>Calling <literal><phrase role="code">proceed</phrase></literal> executes the next interceptor in the chain or the actual remote call if all interceptors have already been executed. If access to the result of the (asynchronous) remote call is needed in the interceptor, one of the overloaded versions of <literal><phrase role="code">proceed</phrase></literal> accepting a <literal><phrase role="code">RemoteCallback</phrase></literal> has to be used instead.</simpara>
<simpara>The result of the remote call can be manipulated by calling <literal><phrase role="code">RestCallContext.setResult()</phrase></literal> .</simpara>
<simpara>Not calling <literal><phrase role="code">proceed</phrase></literal> in the interceptor bypasses the actual remote call, passing <literal><phrase role="code">RestCallContext.getResult()</phrase></literal> to the <literal><phrase role="code">RemoteCallBack</phrase></literal> provided at the call site.</simpara>
</section>
<section id="sid-19398997_ErraiJAX-RS-WireFormat">
<title>Wire Format</title>
<simpara>Errai&#8217;s JSON format will be used to serialize/deserialize your custom types. See <xref linkend="sid-5931328"/> for details.</simpara>
<simpara>Alternatively, a Jackson compatible JSON format can be used on the wire. See <link linkend="sid-19398997_ErraiJAX-RS-Configuration">Configuration</link> for details on how to enable Jackson marshalling.</simpara>
</section>
<section id="sid-19398997_ErraiJAX-RS-Configuration">
<title>Configuration</title>
<section id="sid-19398997_ErraiJAX-RS-ConfiguringthedefaultrootpathofJAXRSendpoints">
<title>Configuring the default root path of JAX-RS endpoints</title>
<simpara>All paths specified using the <literal><phrase role="code">@Path</phrase></literal> annotation on JAX-RS interfaces are by definition relative paths. Therefore, by default, it is assumed that the JAX-RS endpoints can be found at the specified paths relative to the GWT client application&#8217;s context path.</simpara>
<simpara>To configure a relative or absolute root path, the following JavaScript variable can be set in either</simpara>
<simpara>the host HTML page</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;script type="text/javascript"&gt;
  erraiJaxRsApplicationRoot = "/MyJaxRsEndpointPath";
&lt;/script&gt;</programlisting>
<simpara>or by using a JSNI method:</simpara>
<programlisting language="java" linenumbering="unnumbered">private native void setMyJaxRsAppRoot(String path) /*-{
  $wnd.erraiJaxRsApplicationRoot = path;
}-*/;</programlisting>
<simpara>or by simply invoking:</simpara>
<programlisting language="java" linenumbering="unnumbered">RestClient.setApplicationRoot("/MyJaxRsEndpointPath");</programlisting>
<simpara>The root path will be prepended to all paths specified on the JAX-RS interfaces. It serves as the base URL for all requests sent from the client.</simpara>
</section>
<section id="sid-19398997_ErraiJAX-RS-EnablingJacksonmarshalling">
<title>Enabling Jackson marshalling</title>
<simpara>The following options are available for activating Jackson marshalling on the client. Note that this is a client-side configuration, the JAX-RS endpoint is assumed to already return a Jackson representation (Jackson is supported by all JAX-RS implementations). The <literal><phrase role="code">errai-jaxrs-provider.jar</phrase></literal> does not have to be deployed on the server in this case!</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;script type="text/javascript"&gt;
  erraiJaxRsJacksonMarshallingActive = true;
&lt;/script&gt;</programlisting>
<simpara>or by using a JSNI method:</simpara>
<programlisting language="java" linenumbering="unnumbered">private native void setJacksonMarshallingActive(boolean active) /*-{
  $wnd.erraiJaxRsJacksonMarshallingActive = active;
}-*/;</programlisting>
<simpara>or by simply invoking:</simpara>
<programlisting language="java" linenumbering="unnumbered">RestClient.setJacksonMarshallingActive(true);</programlisting>
</section>
</section>
</chapter>
<chapter id="sid-54493688">
<title>Errai JPA</title>
<simpara>Starting with Errai 2.1, Errai implements a subset of JPA 2.0. With Errai JPA, you can store and retrieve entity objects on the client side, in the browser&#8217;s local storage. This allows the reuse of JPA-related code (both entity class definitions and procedural logic that uses the EntityManager) between client and server.</simpara>
<simpara>Errai JPA implements the following subset of JPA 2.0:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>Annotation-based configuration</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Entity Types with</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Identifiers of any numeric type (int, long, short, etc.)</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Generated identifiers</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Regular attributes of any JPA Basic type (Java primitive types, boxed primitives, enums, BigInteger, BigDecimal, String, Date, Time, and Timestamp)</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Singular and Plural (collection-valued) attributes of other entity types</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>All association types (one-to-one, one-to-many, many-to-one, many-to-many)</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>All association cascade rules (ALL, PERSIST, MERGE, REMOVE, REFRESH, DETACH)</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Circular and self references work properly</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Polymorphic queries and collections (queries for a base entity type can result in instances of its subtypes)</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Property access by field or get/set methods</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Named, typed JPQL queries that select exactly one entity type</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>With cascading fetch of related entities</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>With or without <literal><phrase role="code">WHERE</phrase></literal> clause</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>All boolean, arithmetic, and string operators supported</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>All String manipulation functions supported</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>With or without <literal><phrase role="code">ORDER BY</phrase></literal> clause</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Lifecycle events and entity lifecycle listeners</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Much of the Metamodel API ( <literal><phrase role="code">Metamodel</phrase></literal> , <literal><phrase role="code">EntityType</phrase></literal> , <literal><phrase role="code">SingularAttribute</phrase></literal> , <literal><phrase role="code">PluralAttribute</phrase></literal> , etc.)</simpara>
      
    </listitem>
  
</itemizedlist>

<important>
<title>It&#8217;s all client-side</title>
<simpara>Errai JPA is a declarative, typesafe interface to the web browser&#8217;s <literal><phrase role="code">localStorage</phrase></literal> object. As such it is a <emphasis>client-side implementation</emphasis> of JPA. Objects are stored and fetched from the browser&#8217;s local storage, <emphasis>not</emphasis> from the JPA provider on the server side.</simpara>
</important>
<section id="sid-54493688_ErraiJPA-GettingStarted">
<title>Getting Started</title>
<section id="sid-54493688_ErraiJPA-Compiletimedependency">
<title>Compile-time dependency</title>
<simpara>To use Errai JPA, you must include it on the compile-time classpath. If you are using Maven for your build, add this dependency:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.errai&lt;/groupId&gt;
      &lt;artifactId&gt;errai-jpa-client&lt;/artifactId&gt;
      &lt;version&gt;${errai.version}&lt;/version&gt;
    &lt;/dependency&gt;</programlisting>
<simpara>If you are not using Maven for dependency management, add <literal><phrase role="code">errai-jpa-client-version.jar</phrase></literal> , Hibernate 4.1.1, and Google Guava for GWT 12.0 to your compile-time classpath.</simpara>
</section>
<section id="sid-54493688_ErraiJPA-GWTModuleDescriptor">
<title>GWT Module Descriptor</title>
<simpara>Once you have Errai JPA on your classpath, ensure your application inherits the GWT module as well. Add this line to your application&#8217;s <literal><phrase role="code">\*.gwt.xml</phrase></literal> file:</simpara>
<programlisting language="xml" linenumbering="unnumbered">   &lt;inherits name="org.jboss.errai.jpa.JPA"/&gt;</programlisting>
</section>
<section id="sid-54493688_ErraiJPA-METAINF%2Fpersistence.xml">
<title>INF/persistence.xml</title>
<simpara>Errai ignores META-INF/persistence.xml for purposes of client-side JPA. Instead, Errai scans all Java packages that are part of your GWT modules for classes annotated with <literal><phrase role="code">@Entity</phrase></literal> . This allows you the freedom of defining a persistence.xml that includes both shared entity classes that you use on the client and the server, plus server-only entities that are defined in a server-only package.</simpara>
</section>
<section id="sid-54493688_ErraiJPA-DeclaringanEntityClass">
<title>Declaring an Entity Class</title>
<simpara>Classes whose instances can be stored and retrieved by JPA are called <emphasis>entities</emphasis> . To declare a class as a JPA entity, annotate it with <literal><phrase role="code">@Entity</phrase></literal> .</simpara>
<simpara>JPA requires that entity classes conform to a set of rules. These are:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>The class must have an ID attribute</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The class must have a public or protected constructor that takes no arguments</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The class must be public and nonfinal</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>No methods or persistent fields of the class may be final</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The class must be a top-level type (not a nested or inner class)</simpara>
      
    </listitem>
  
</itemizedlist>

<simpara>Here is an example of a valid entity class with an ID attribute ( <literal><phrase role="code">id</phrase></literal> ) and a String-valued persistent attribute ( <literal><phrase role="code">name</phrase></literal> ):</simpara>
<programlisting language="java" linenumbering="unnumbered">@Entity
public class Genre {

  @Id @GeneratedValue
  private int id;

  private String name;

  // This constructor is used by JPA
  public Genre() {}

  // This constructor is not used by JPA
  public Genre(String name) {
    this();
    this.name = name;
  }


  // These getter and Setter methods are optional:

  public int getId() { return id; }
  public void setId(int id) { this.id = id; }

  public String getName() { return name; }
  public void setName(String name) { this.name = name; }
}</programlisting>
<section id="sid-54493688_ErraiJPA-EntityAttributes">
<title>Entity Attributes</title>
<simpara>The state of fields and JavaBeans properties of entities are generally persisted with the entity instance. These persistent things are called <emphasis>attributes</emphasis> .</simpara>
<simpara>JPA Attributes are subdivided into two main types: <emphasis>singular</emphasis> and <emphasis>plural</emphasis> . Singular attributes are scalar types like <literal><phrase role="code">Integer</phrase></literal> or <literal><phrase role="code">String</phrase></literal> . Plural attributes are collection values, such as <literal><phrase role="code">List&lt;Integer&gt;</phrase></literal> or <literal><phrase role="code">Set&lt;String&gt;</phrase></literal> .</simpara>
<simpara>The values of singular attributes (and the elements of plural attributes) can be of any application-defined entity type or a JPA Basic type. The JPA basic types are all of the Java primitive types, all boxed primitives, enums, BigInteger, BigDecimal, String, Date ( <literal><phrase role="code">java.util.Date</phrase></literal> or <literal><phrase role="code">java.sql.Date</phrase></literal> ), Time, and Timestamp.</simpara>
<simpara>You can direct JPA to read and write your entity&#8217;s attributes by direct field access or via JavaBeans property access methods (that is, "getters and setters"). Direct field access is the default. To request property access, annotate the class with <literal><phrase role="code">@Access(AccessType.PROPERTY)</phrase></literal> . If using direct field access, attribute-specific JPA annotations should be on the fields themselves; when using property access, the attribute-specific annotations should be on the getter method for that property.</simpara>
</section>
<section id="sid-54493688_ErraiJPA-IDAttributesandAutoGeneratedIdentifiers">
<title>ID Attributes and Auto-Generated Identifiers</title>
<simpara>Each entity class must have exactly one ID attribute. The value of this attribute together with the fully-qualified class name uniquely identifies an instance to the entity manager.</simpara>
<simpara>ID values can be assigned by the application, or they can be generated by the JPA entity manager. To declare a generated identifier, annotate the field with <literal><phrase role="code">@GeneratedValue</phrase></literal> . To declare an application-assigned identifier, leave off the <literal><phrase role="code">@GeneratedValue</phrase></literal> annotation.</simpara>
<simpara>Generated identifier fields must not be initialized or modified by application code. Application-assigned identifier fields must be initialized to a unique value before the entity is persisted by the entity manager, but must not be modified afterward.</simpara>
</section>
<section id="sid-54493688_ErraiJPA-SinglevaluedAttributes">
<title>Single-valued Attributes</title>
<simpara>By default, every field of a JPA basic type is a persistent attribute. If a basic type field should not be presistent, mark it with <literal><phrase role="code">transient</phrase></literal> or annotate it with <literal><phrase role="code">@Transient</phrase></literal> .</simpara>
<simpara>Single-valued attributes of entity types must be annotated with <literal><phrase role="code">@OneToOne</phrase></literal> or <literal><phrase role="code">@ManyToOne</phrase></literal> .</simpara>
<simpara>Single-valued types that are neither entity types nor JPA Basic types are not presently supported by Errai JPA. Such attributes must be marked transient.</simpara>
<simpara>Here is an example of an entity with single-valued basic attributes and a single-valued relation to another entity type:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Entity
public class Album {

  @GeneratedValue
  @Id
  private Long id;

  private String name;

  @ManyToOne
  private Artist artist;

  private Date releaseDate;

  private Format format;

  public Long getId() { return id; }
  public void setId(Long id) { this.id = id; }

  public String getName() { return name; }
  public void setName(String name) { this.name = name; }

  public Artist getArtist() { return artist; }
  public void setArtist(Artist artist) { this.artist = artist; }

  public Date getReleaseDate() { return releaseDate; }
  public void setReleaseDate(Date releaseDate) { this.releaseDate = releaseDate; }

  public Format getFormat() { return format; }
  public void setFormat(Format format) { this.format = format; }
}</programlisting>
</section>
<section id="sid-54493688_ErraiJPA-Plural%28collectionvalued%29Attributes">
<title>Plural (collection-valued) Attributes</title>
<simpara>Collection-valued types <literal><phrase role="code">Collection&lt;T&gt;</phrase></literal> , <literal><phrase role="code">Set&lt;T&gt;</phrase></literal> , and <literal><phrase role="code">List&lt;T&gt;</phrase></literal> are supported. JPA rules require that all access to the collections are done through the collection interface method; never by specific methods on an implementation.</simpara>
<simpara>The element type of a collection attribute can be a JPA basic type or an entity type. If it is an entity type, the attribute must be annotated with <literal><phrase role="code">@OneToMany</phrase></literal> or <literal><phrase role="code">@ManyToMany</phrase></literal> .</simpara>
<simpara>Here is an example of an entity with two plural attributes:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Entity
public class Artist {

  @Id
  private Long id;

  private String name;

  // a two-way relationship (albums refer back to artists)
  @OneToMany(mappedBy="artist", cascade=CascadeType.ALL)
  private Set&lt;Album&gt; albums = new HashSet&lt;Album&gt;();

  // a one-way relationship (genres don't reference artists)
  @OneToMany(cascade={CascadeType.PERSIST, CascadeType.MERGE})
  private Set&lt;Genre&gt; genres = new HashSet&lt;Genre&gt;();

  public Long getId() { return id; }
  public void setId(Long id) { this.id = id; }

  public String getName() { return name; }
  public void setName(String name) { this.name = name; }

  public Set&lt;Album&gt; getAlbums() { return albums; }
  public void setAlbums(Set&lt;Album&gt; albums) { this.albums = albums; }

  public Set&lt;Genre&gt; getGenres() { return genres; }
  public void setGenres(Set&lt;Genre&gt; genres) { this.genres = genres; }
}</programlisting>
</section>
</section>
<section id="sid-54493688_ErraiJPA-EntityLifecycleStates">
<title>Entity Lifecycle States</title>
<section id="sid-54493688_ErraiJPA-CascadeRules">
<title>Cascade Rules</title>
<simpara>When an entity changes state (more on this later), that state change can be cascaded automatically to related entity instances. By default, no state changes are cascaded to related entities. To request cascading of entity state changes, use the <literal><phrase role="code">cascade</phrase></literal> attribute on any of the relationship quantifiers <literal><phrase role="code">@OneToOne</phrase></literal> , <literal><phrase role="code">@ManyToOne</phrase></literal> , <literal><phrase role="code">@OneToMany</phrase></literal> , and <literal><phrase role="code">@ManyToMany</phrase></literal> .</simpara>
<informaltable frame="all"
    rowsep="1" colsep="1">
  
  <tgroup cols="2">
    
    <colspec colname="col_1" colwidth="50*"/>
    
    <colspec colname="col_2" colwidth="50*"/>
    
    
    <thead>
      
      <row>
        
        <entry align="left" valign="top">CascadeType value</entry>
        
        <entry align="left" valign="top">Description</entry>
        
      </row>
      
    </thead>
    
    <tbody>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">PERSIST</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>Persist the related entity object(s) when this entity is persisted</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">MERGE</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>Merge the attributes of the related entity object(s) when this entity is merged</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">REMOVE</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>Remove the related entity object(s) from persistent storage when this one is removed</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">REFRESH</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>Not applicable in Errai JPA</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">DETACH</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>Detach the related entity object(s) from the entity manager when this object is detached</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">ALL</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>Equivalent to specifying all of the above</simpara></entry>
        
      </row>
      
    </tbody>
    
  </tgroup>
</informaltable>
<simpara>For an example of specifying cascade rules, refer to the <literal><phrase role="code">Artist</phrase></literal> example above. In that example, the cascade type on <literal><phrase role="code">albums</phrase></literal> is <literal><phrase role="code">ALL</phrase></literal> . When a particular <literal><phrase role="code">Artist</phrase></literal> is persisted or removed, detached, etc., all of that artist&#8217;s albums will also be persisted or removed, or detached correspondingly. However, the cascade rules for <literal><phrase role="code">genres</phrase></literal> are different: we only specify <literal><phrase role="code">PERSIST</phrase></literal> and <literal><phrase role="code">MERGE</phrase></literal> . Because a <literal><phrase role="code">Genre</phrase></literal> instance is reusable and potentially shared between many artists, we do not want to remove or detach these when one artist that references them is removed or detached. However, we still want the convenience of automatic cascading persistence in case we persist an <literal><phrase role="code">Artist</phrase></literal> which references a new, unmanaged <literal><phrase role="code">Genre</phrase></literal> .</simpara>
</section>
</section>
<section id="sid-54493688_ErraiJPA-ObtaininganinstanceofEntityManager">
<title>Obtaining an instance of EntityManager</title>
<simpara>The entity manager provides the means for storing, retrieving, removing, and otherwise affecting the lifecycle state of entity instances.</simpara>
<simpara>To obtain an instance of EntityManager on the client side, use Errai IoC (or CDI) to inject it into any client-side bean:</simpara>
<programlisting language="java" linenumbering="unnumbered">@EntryPoint
public class Main {
  @Inject EntityManager em;
}</programlisting>
<section id="sid-54493688_ErraiJPA-StoringandUpdatingEntities">
<title>Storing and Updating Entities</title>
<simpara>To store an entity object in persistent storage, pass that object to the <literal><phrase role="code">EntityManager.persist()</phrase></literal> method. Once this is done, the entity instance transitions from the <emphasis>new</emphasis> state to the <emphasis>managed</emphasis> state.</simpara>
<simpara>If the entity references any related entities, these entities must be in the managed state already, or have cascade-on-persist enabled. If neither of these criteria are met, an <literal><phrase role="code">IllegalStateException</phrase></literal> will be thrown.</simpara>
<simpara>See an example in the following section.</simpara>
</section>
<section id="sid-54493688_ErraiJPA-FetchingEntitiesbyID">
<title>Fetching Entities by ID</title>
<simpara>If you know the unique ID of an entity object, you can use the <literal><phrase role="code">EntityManager.find()</phrase></literal> method to retrieve it from persistent storage. The object returned from the <literal><phrase role="code">find()</phrase></literal> method will be in the managed state.</simpara>
<simpara>Example:</simpara>
<programlisting language="java" linenumbering="unnumbered">    // make it
    Album album = new Album();
    album.setArtist(null);
    album.setName("Abbey Road");
    album.setReleaseDate(new Date(-8366400000L));

    // store it
    EntityManager em = getEntityManager();
    em.persist(album);
    em.flush();
    em.detach(album);
    assertNotNull(album.getId());

    // fetch it
    Album fetchedAlbum = em.find(Album.class, album.getId());
    assertNotSame(album, fetchedAlbum);
    assertEquals(album.toString(), fetchedAlbum.toString());</programlisting>
</section>
<section id="sid-54493688_ErraiJPA-RemovingEntitiesfromPersistentStorage">
<title>Removing Entities from Persistent Storage</title>
<simpara>To remove a persistent managed entity, pass it to the <literal><phrase role="code">EntityManager.remove()</phrase></literal> method. As the cascade rules specify, related entities will also be removed recursively.</simpara>
<simpara>Once an entity has been removed and the entity manager&#8217;s state has been flushed, the entity object is unmanaged and back in the <emphasis>new</emphasis> state.</simpara>
<section id="sid-54493688_ErraiJPA-ClearingallLocalStorage">
<title>Clearing all Local Storage</title>
<simpara>Errai&#8217;s EntityManager class provides a <literal><phrase role="code">removeAll()</phrase></literal> method which removes everything from the browser&#8217;s persistent store for the domain of the current webpage.</simpara>
<simpara>This method is not part of the JPA standard, so you must down-cast your client-side <literal><phrase role="code">EntityManager</phrase></literal> instance to <literal><phrase role="code">ErraiEntityManager</phrase></literal> . Example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@EntryPoint
public class Main {

  @Inject EntityManager em;

  void resetJpaStorage() {
    ((ErraiEntityManager) em).removeAll();
  }
}</programlisting>
</section>
</section>
<section id="sid-54493688_ErraiJPA-DetachingEntityInstancesfromtheEntityManager">
<title>Detaching Entity Instances from the Entity Manager</title>
<simpara>For every entity instance in the managed state, changes to the attribute values of that entity are persisted to local storage whenever the entity manager is flushed. To prevent this automatic updating from happening, you can <emphasis>detach</emphasis> an entity from the entity manager. When an instance is detached, it is not deleted. All information about it remains in persistent storage. The next time that entity is retrieved, the entity manager will create a new and separate managed instance for it.</simpara>
<simpara>To detach one particular object along with all related objects whose cascade rules say so, call <literal><phrase role="code">EntityManager.detach()</phrase></literal> and pass in that object.</simpara>
<simpara>To detach all objects from the entity manager at once, call <literal><phrase role="code">EntityManager.detachAll()</phrase></literal> .</simpara>
</section>
<section id="sid-54493688_ErraiJPA-TestingifanEntityisintheManagedState">
<title>Testing if an Entity is in the Managed State</title>
<simpara>To check if a given object is presently managed by the entity manager, call <literal><phrase role="code">EntityManager.contains()</phrase></literal> and pass in the object of interest.</simpara>
</section>
</section>
<section id="sid-54493688_ErraiJPA-NamedQueries">
<title>Named Queries</title>
<simpara>To retrieve one or more entities that match a set of criteria, Errai JPA allows the use of JPA <emphasis>named queries</emphasis> . Named queries are declared in annotations on entity classes.</simpara>
<section id="sid-54493688_ErraiJPA-DeclaringNamedQueries">
<title>Declaring Named Queries</title>
<simpara>Queries in JPA are written in the JPQL language. As of Errai 2.1, Errai JPA does not support all JPQL features. Most importantly, implicit and explicit joins in queries are not yet supported. Queries of the following form generally work:</simpara>
<programlisting language="java" linenumbering="unnumbered">SELECT et FROM EntityType et WHERE [expression with constants, named parameters and attributes of et] ORDER BY et.attr1 [ASC|DESC], et.attr2 [ASC|DESC]</programlisting>
<simpara>Here is how to declare a JPQL query on an entity:</simpara>
<programlisting language="java" linenumbering="unnumbered">@NamedQuery(name="selectAlbumByName", query="SELECT a FROM Album a WHERE a.name=:name")
@Entity
public class Album {
  ... same as before ...
}</programlisting>
<simpara>To declare more than one query on the same entity, wrap the <literal><phrase role="code">@NamedQuery</phrase></literal> annotations in <literal><phrase role="code">@NamedQueries</phrase></literal> like this:</simpara>
<programlisting language="java" linenumbering="unnumbered">@NamedQueries({
  @NamedQuery(name="selectAlbumByName", query="SELECT a FROM Album a WHERE a.name = :name"),
  @NamedQuery(name="selectAlbumsAfter", query="SELECT a FROM Album a WHERE a.releaseDate &gt;= :startDate")
})
@Entity
public class Album {
  ... same as before ...
}</programlisting>
</section>
<section id="sid-54493688_ErraiJPA-ExecutingNamedQueries">
<title>Executing Named Queries</title>
<simpara>To execute a named query, retrieve it by name and result type from the entity manager, set the values of its parameters (if any), and then call one of the execution methods <literal><phrase role="code">getSingleResult()</phrase></literal> or <literal><phrase role="code">getResultList()</phrase></literal> .</simpara>
<simpara>Example:</simpara>
<programlisting language="java" linenumbering="unnumbered">    TypedQuery&lt;Album&gt; q = em.createNamedQuery("selectAlbumByName", Album.class);
    q.setParameter("name", "Let It Be");
    List&lt;Album&gt; fetchedAlbums = q.getResultList();</programlisting>
</section>
</section>
<section id="sid-54493688_ErraiJPA-EntityLifecycleEvents">
<title>Entity Lifecycle Events</title>
<simpara>To receive a notification when an entity instance transitions from one lifecycle state to another, use an entity lifecycle listener.</simpara>
<simpara>These annotations can be applied to methods in order to receive notifications at certain points in an entity&#8217;s lifecycle. These events are delivered for direct operations initiated on the EntityManager as well as operations that happen due to cascade rules.</simpara>
<informaltable frame="all"
    rowsep="1" colsep="1">
  
  <tgroup cols="2">
    
    <colspec colname="col_1" colwidth="50*"/>
    
    <colspec colname="col_2" colwidth="50*"/>
    
    
    <thead>
      
      <row>
        
        <entry align="left" valign="top">Annotation</entry>
        
        <entry align="left" valign="top">Meaning</entry>
        
      </row>
      
    </thead>
    
    <tbody>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">@PrePersist</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>The entity is about to be persisted or merged into the entity manager.</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">@PostPersist</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>The entity has just been persisted or merged into the entity manager.</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">@PreUpdate</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>The entity&#8217;s state is about to be captured into the browser&#8217;s localStorage.</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">@PostUpdate</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>The entity&#8217;s state has just been captured into the browser&#8217;s localStorage.</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">@PreRemove</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>The entity is about to be removed from persistent storage.</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">@PostRemove</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>The entity has just been removed from persistent storage.</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara><literal><phrase role="code">@PostLoad</phrase></literal></simpara></entry>
        
        <entry align="left" valign="top"><simpara>The entity&#8217;s state has just been retrieved from the browser&#8217;s localStorage.</simpara></entry>
        
      </row>
      
    </tbody>
    
  </tgroup>
</informaltable>
<simpara>JPA lifecycle event annotations can be placed on methods in the entity type itself, or on a method of any type with a public no-args constructor.</simpara>
<simpara>To receive lifecycle event notifications directly on the affected entity instance, create a no-args method on the entity class and annotate it with one or more of the lifecycle annotations in the above table.</simpara>
<simpara>For example, here is a variant of the Album class where instances receive notification right after they are loaded from persistent storage:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Entity
public class Album {

  ... same as before ...

  @PostLoad
  public void postLoad() {
    System.out.println("Album " + getName() + " was just loaded into the entity manager");
  }
}</programlisting>
<simpara>To receive lifecycle methods in a different class, declare a method that takes one parameter of the entity type and annotate it with the desired lifecycle annotations. Then name that class in the <literal><phrase role="code">@EntityListeners</phrase></literal> annotation on the entity type.</simpara>
<simpara>The following example produces the same results as the previous example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Entity
@EntityListeners(StandaloneLifecycleListener.class)
public class Album {

  ... same as always ...

}

public class StandaloneLifecycleListener {

  @PostLoad
  public void albumLoaded(Album a) {
  public void postLoad() {
    System.out.println("Album " + a.getName() + " was just loaded into the entity manager");
  }
}</programlisting>
</section>
<section id="sid-54493688_ErraiJPA-JPAMetamodel">
<title>JPA Metamodel</title>
<simpara>Errai captures structural information about entity types at compile time and makes them available in the GWT runtime environment. The JPA metamodel includes methods for enumerating all known entity types and enumerating the singular and plural attributes of those types. Errai extends the JPA 2.0 Metamodel by providing methods that can create new instances of entity classes, and read and write attribute values of existing entity instances.</simpara>
<simpara>As an example of what is possible, this functionality could be used to create a reusable UI widget that can present an editable table of any JPA entity type.</simpara>
<simpara>To access the JPA Metamodel, call the <literal><phrase role="code">EntityManager.getMetamodel()</phrase></literal> method. For details on what can be done with the stock JPA metamodel, see the API&#8217;s javadoc or consult the JPA specification.</simpara>
<section id="sid-54493688_ErraiJPA-ErraiExtensionstoJPAMetamodelAPI">
<title>Errai Extensions to JPA Metamodel API</title>
<simpara>Wherever you obtain an instance of <literal><phrase role="code">SingularAttribute</phrase></literal> from the metamodel API, you can down-cast it to <literal><phrase role="code">ErraiSingularAttribute</phrase></literal> . Likewise, you can down-cast any <literal><phrase role="code">PluralAttribute</phrase></literal> to <literal><phrase role="code">ErraiPluralAttribute</phrase></literal> .</simpara>
<simpara>In either case, you can read the value of an arbitrary attribute by calling <literal><phrase role="code">ErraiAttribute.get()</phrase></literal> and passing in the entity instance. You can set any attribute&#8217;s value by calling <literal><phrase role="code">ErraiAttribute.set()</phrase></literal> , passing in the entity instance and the new value.</simpara>
<simpara>In addition to <literal><phrase role="code">get()</phrase></literal> and <literal><phrase role="code">set()</phrase></literal> , <literal><phrase role="code">ErraiPluralAttribute</phrase></literal> also has the <literal><phrase role="code">createEmptyCollection()</phrase></literal> method, which creates an empty collection of the correct interface type for the given attribute.</simpara>
</section>
</section>
<section id="sid-54493688_ErraiJPA-JPAFeaturesNotImplementedinErrai2.4">
<title>JPA Features Not Implemented in Errai 2.4</title>
<simpara>The following features are not yet implemented, but could conceivably be implemented in a future Errai JPA release:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>Flush modes other than immediate</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Transactions, including EntityManager.getTransaction()</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>In named queries:</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Joins and nested attribute paths ( <literal><phrase role="code">a.b.c</phrase></literal> ) do not yet work, although single-step attribute paths ( <literal><phrase role="code">a.b</phrase></literal> ) do.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The <literal><phrase role="code">SELECT</phrase></literal> clause must specify exactly one entity type. Selection of individual attributes is not yet implemented.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Embedded collections</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Compound identifiers (presently, only basic types are supported for entity IDs)</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal><phrase role="code">EntityManager.refresh()</phrase></literal> to pick up changes made in localStorage from a different browser window/tab.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Criteria Queries</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The generated static Metamodel</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The <literal><phrase role="code">@PersistenceContext</phrase></literal> annotation currently has no effect in client-side code (use <literal><phrase role="code">@Inject</phrase></literal> instead)</simpara>
      
    </listitem>
  
</itemizedlist>

<simpara>The following may never be implemented due to limitations and restrictions in the GWT client-side environment:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara><literal><phrase role="code">EntityManager.createQuery(String, &#8230;)</phrase></literal> (that is, unnamed queries) are impractical because JPQL queries are parsed at compile time, not in the browser.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal><phrase role="code">EntityManager.createNativeQuery(String, &#8230;)</phrase></literal> don&#8217;t make sense because the underlying database is just a hash table. It does not have a query language.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Persistent attributes of type <literal><phrase role="code">java.util.Calendar</phrase></literal> because the <literal><phrase role="code">Calendar</phrase></literal> class is not in GWT&#8217;s JRE emulation library.</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
<section id="sid-54493688_ErraiJPA-OtherCaveatsforErrai2.1JPA">
<title>Other Caveats for Errai 2.1 JPA</title>
<simpara>We hope to remedy these shortcomings in a future release.</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>In Dev Mode, changes to entity classes are not discovered on page refresh. You need to restart Dev Mode.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The local data stored in the browser is not encrypted</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
</section>
<section id="sid-71467090">
<title>Errai JPA Data Sync</title>
<simpara>Traditional JPA implementations allow you to store and retrieve entity objects on the server side. Errai&#8217;s JPA implementation allows you to store and retrieve entity objects in the web browser using the same APIs. All that&#8217;s missing is the ability to synchronize the stored data between the server side and the client side.</simpara>
<simpara>This is where Errai JPA Data Sync comes in: it provides an easy mechanism for two-way synchronization of data sets between the client and the server.</simpara>
<section id="sid-71467090_ErraiJPADataSync-HowToUseIt">
<title>How To Use It</title>
<section id="sid-71467090_ErraiJPADataSync-Dependencies">
<title>Dependencies</title>
<simpara>First, ensure your <literal><phrase role="code">pom.xml</phrase></literal> includes a dependency on the Data Sync module. This module must be packaged in your application&#8217;s WAR file, so include it with the default scope (compile):</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;dependency&gt;
    &lt;groupId&gt;org.jboss.errai&lt;/groupId&gt;
    &lt;artifactId&gt;errai-jpa-datasync&lt;/artifactId&gt;
    &lt;version&gt;${errai.version}&lt;/version&gt;
  &lt;/dependency&gt;</programlisting>
<simpara>Then, ensure your project&#8217;s <literal><phrase role="code">gwt.xml</phrase></literal> module descriptor includes a dependency on the Data Sync GWT module:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;inherits name="org.jboss.errai.jpa.sync.DataSync"/&gt;</programlisting>
</section>
<section id="sid-71467090_ErraiJPADataSync-ARunningExample">
<title>A Running Example</title>
<simpara>For the rest of this chapter, we will refer to the following Entity classes, which are defined in a <literal><phrase role="code">shared</phrase></literal> package that&#8217;s visible to client and server code:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Portable
@Entity
@NamedQuery(name = "allUsers", query = "SELECT u FROM User u")
public class User {

  @Id
  @GeneratedValue
  private long id;

  private String name;

  // getters and setters omitted
}</programlisting>
<programlisting language="java" linenumbering="unnumbered">@Portable
@Entity
@NamedQuery(name = "groceryListsForUser", query = "SELECT gl FROM GroceryList gl WHERE gl.owner=:user")
public class GroceryList {

  @Id
  @GeneratedValue
  private long id;

  @ManyToOne
  private User owner;

  @OneToMany(cascade = { CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REFRESH })
  private List&lt;Item&gt; items = new ArrayList&lt;Item&gt;();

  // getters and setters omitted
}</programlisting>
<programlisting language="java" linenumbering="unnumbered">@Portable
@Entity
@NamedQuery(name = "allItems", query = "SELECT i FROM Item i")
public class Item {

  @Id
  @GeneratedValue
  private long id;

  private String name;
  private String department;
  private String comment;
  private Date addedOn;

  @ManyToOne(cascade = { CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REFRESH })
  private User addedBy;

  // getters and setters omitted
}</programlisting>
<simpara>To summarize: there are three entity types: <literal><phrase role="code">User</phrase></literal> , <literal><phrase role="code">GroceryList</phrase></literal> , and <literal><phrase role="code">Item</phrase></literal> . Each <literal><phrase role="code">GroceryList</phrase></literal> belongs to a <literal><phrase role="code">User</phrase></literal> and has a list of <literal><phrase role="code">Item</phrase></literal> objects.</simpara>
<note>
<simpara>All the entities involved in the data synchronization request must be marshallable via Errai Marshalling. This is normally accomplished by adding the <literal><phrase role="code">@Portable</phrase></literal> annotation to each JPA entity class, but it is also acceptable to list them in <literal><phrase role="code">ErraiApp.properties</phrase></literal> . See the <xref linkend="sid-5931328"/> section for more details.</simpara>
</note>
<simpara>Now let&#8217;s say we want to synchronize the data for all of a user&#8217;s grocery lists. This will make them available for offline use through Errai JPA, and at the same time it will update the server with the latest changes made on the client. Ultimately, the sync operation is accomplished in one asynchronous call, but first we have to prepare a few things on the client and the server.</simpara>
</section>
<section id="sid-71467090_ErraiJPADataSync-ClientSide">
<title>Client Side</title>
<programlisting language="java" linenumbering="unnumbered">  @Inject private ClientSyncManager syncManager;
  @Inject private EntityManager em;

  public void syncGroceryLists(User forUser) {
    RemoteCallback&lt;List&lt;SyncResponse&lt;GroceryList&gt;&gt;&gt; onCompletion = new RemoteCallback&lt;List&lt;SyncResponse&lt;GroceryList&gt;&gt;&gt;() {
      @Override
      public void callback(List&lt;SyncResponse&lt;GroceryList&gt;&gt; response) {
        Window.alert("Data Sync Complete!");
      }
    };

    ErrorCallback&lt;?&gt; onError = new BusErrorCallback() {

      @Override
      public boolean error(Message message, Throwable throwable) {
        Window.alert("Data Sync failed!");
        return false;
      }
    };

    Map&lt;String, Object&gt; queryParams = new HashMap&lt;String, Object&gt;();
    queryParams.put("user", forUser);

    syncManager.coldSync("groceryListsForUser", GroceryList.class, queryParams, onCompletion, onError);
  }</programlisting>
<important>
<simpara>The <literal><phrase role="code">onCompletion</phrase></literal> and <literal><phrase role="code">onError</phrase></literal> callbacks are optional. In the unlikely case that your application doesn&#8217;t care if a data sync request completed successfully, you can pass <literal><phrase role="code">null</phrase></literal> for either callback.</simpara>
</important>
<simpara>Once your <literal><phrase role="code">onCompletion</phrase></literal> callback has been notified, the server and client will have the same entities stored in their respective databases for all entities reachable from the given query result.</simpara>
</section>
<section id="sid-71467090_ErraiJPADataSync-ServerSide%E2%80%93DataSyncServiceImpl">
<title>Server Side  DataSyncServiceImpl</title>
<simpara>During the <literal><phrase role="code">coldSync()</phrase></literal> call, the client-side sync manager sends an <link linkend="sid-5931313">Errai RPC</link> request to the server. Although a server-side implementation of the remote interface is provided, you are responsible for implementing a thin wrapper around it. This wrapper serves two purposes:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>It allows you to determine how to obtain a reference to the JPA EntityManager (and to choose which persistence context the server-side data sync will operate on)</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>It allows you to inspect the contents of each sync request and make security decisions about access to particular entities</simpara>
      
    </listitem>
  
</orderedlist>
<simpara>If you are deploying to a container that supports CDI and EJB 3, you can use this DataSyncServiceImpl as a template for your own:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Stateless @org.jboss.errai.bus.server.annotations.Service
public class DataSyncServiceImpl implements DataSyncService {

  @PersistenceContext
  private EntityManager em;

  private final JpaAttributeAccessor attributeAccessor = new JavaReflectionAttributeAccessor();

  @Inject private LoginService loginService;

  @Override
  public &lt;X&gt; List&lt;SyncResponse&lt;X&gt;&gt; coldSync(SyncableDataSet&lt;X&gt; dataSet, List&lt;SyncRequestOperation&lt;X&gt;&gt; remoteResults) {

    // Ensure a user is logged in
    User currentUser = loginService.whoAmI();
    if (currentUser == null) {
      throw new IllegalStateException("Nobody is logged in!");
    }

    // Ensure user is accessing their own data!
    if (dataSet.getQueryName().equals("groceryListsForUser")) {
      User requestedUser = (User) dataSet.getParameters().get("user");
      if (!currentUser.getId().equals(requestedUser.getId())) {
        throw new AccessDeniedException("You don't have permission to sync user " + requestedUser.getId());
      }
    }
    else {
      throw new IllegalArgumentException("You don't have permission to sync dataset " + dataSet.getQueryName());
    }

    DataSyncService dss = new org.jboss.errai.jpa.sync.server.DataSyncServiceImpl(em, attributeAccessor);
    return dss.coldSync(dataSet, remoteResults);
  }
}</programlisting>
<simpara>If you are not using EJB 3, you will not be able to use the <literal><phrase role="code">@PersistenceContext</phrase></literal> annotation. In this case, obtain a reference to your EntityManager the same way you would anywhere else in your application.</simpara>
</section>
<section id="sid-71467090_ErraiJPADataSync-DealingWithConflicts">
<title>Dealing With Conflicts</title>
<simpara>When the client sends the sync request to the server, it includes information about the state it expects each entity to be in. If an entity&#8217;s state on the server does not match this expected state on the client, the server ignores the client&#8217;s change request and includes a <literal><phrase role="code">ConflictResponse</phrase></literal> object in the sync reply.</simpara>
<simpara>When the client processes the sync responses from the server, it applies the new state from the server to the local data store. This overwrites the change that was initially requested from the client. In short, you could call this the "server wins" conflict resolution policy.</simpara>
<simpara>In some cases, your application may be able to do something smarter: apply domain-specific knowledge to merge the conflict automatically, or prompt the user to perform a manual merge. In order to do this, you will have to examine the server response from inside the <literal><phrase role="code">onCompletion</phrase></literal> callback you provided to the <literal><phrase role="code">coldSync()</phrase></literal> method:</simpara>
<programlisting language="java" linenumbering="unnumbered">    RemoteCallback&lt;List&lt;SyncResponse&lt;GroceryList&gt;&gt;&gt; onCompletion = new RemoteCallback&lt;List&lt;SyncResponse&lt;GroceryList&gt;&gt;&gt;() {
      @Override
      public void callback(List&lt;SyncResponse&lt;GroceryList&gt;&gt; responses) {
        for (SyncResponse&lt;GroceryList&gt; response : responses) {
          if (response instanceof ConflictResponse) {
            ConflictResponse&lt;GroceryList&gt; cr = (ConflictResponse&lt;GroceryList&gt;) response;
            List&lt;Item&gt; expectedItems = cr.getExpected().getItems();
            List&lt;Item&gt; serverItems = cr.getActualNew().getItems();
            List&lt;Item&gt; clientItems = cr.getRequestedNew().getItems();

            // merge the list of items by comparing each to expectedItems
            List&lt;Item&gt; merged = ...;

            // update local storage with the merged list
            em.find(GroceryList.class, cr.getActualNew().getId()).setItems(merged);
            em.flush();
          }
        }
      }
    };</programlisting>
<simpara>Remember, because of Errai&#8217;s default "server wins" resolution policy, the call to <literal><phrase role="code">em.find(GroceryList.class, cr.getActualNew().getId())</phrase></literal> will return a GroceryList object that has already been updated to match the state present in <literal><phrase role="code">serverItems</phrase></literal> .</simpara>
<note>
<simpara>Searching for ConflictResponse objects in the <literal><phrase role="code">onCompletion</phrase></literal> callback is the only way to recover client data that was clobbered in a conflict. If you do not merge this data back into local storage, or at least retain a reference to the <literal><phrase role="code">cr.getRequestedNew()</phrase></literal> object, this conflicting client data will be lost forever.</simpara>
<simpara>In a future release of Errai JPA, we plan to provide a client-side callback mechanism for custom conflict handling. If such a callback is registered, it will override the default behaviour.</simpara>
</note>
</section>
</section>
</section>
</chapter>
<chapter id="sid-51282340">
<title>Data Binding</title>
<simpara>Errai&#8217;s data binding module provides the ability to bind model objects to UI fields/widgets. The bound properties of the model and the UI components will automatically be kept in sync for as long as they are bound. So, there is no need to write code for UI updates in response to model changes and no need to register listeners to update the model in response to UI changes.</simpara>
<section id="sid-51282340_DataBinding-GettingStarted">
<title>Getting Started</title>
<simpara>The data binding module is directly integrated with <link linkend="sid-51806600">Errai UI</link> and <link linkend="sid-54493688">Errai JPA</link> but can also be used as a standalone project in any GWT client application:</simpara>
<section id="sid-51282340_DataBinding-Compiletimedependency">
<title>Compile-time dependency</title>
<simpara>To use Errai&#8217;s data binding module, you must include it on the compile-time classpath. If you are using Maven for your build, add this dependency:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.errai&lt;/groupId&gt;
      &lt;artifactId&gt;errai-data-binding&lt;/artifactId&gt;
      &lt;version&gt;${errai.version}&lt;/version&gt;
    &lt;/dependency&gt;</programlisting>
<simpara>If you are not using Maven for dependency management, add <literal><phrase role="code">errai-data-binding-</phrase></literal>[code]<literal>version</literal>[code]<literal>.jar</literal> to your classpath.</simpara>
</section>
<section id="sid-51282340_DataBinding-GWTmoduledescriptor">
<title>GWT module descriptor</title>
<simpara>You must also inherit the Errai data binding module by adding the following line to your GWT module descriptor (gwt.xml).</simpara>
<example>
<title>App.gwt.xml</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;inherits name="org.jboss.errai.databinding.DataBinding" /&gt;</programlisting>
</example>
</section>
<section id="sid-51282340_DataBinding-BindableObjects">
<title>Bindable Objects</title>
<simpara>Objects that should participate in data bindings have to be marked as <literal><phrase role="code">@Bindable</phrase></literal> and must follow Java bean conventions. All editable properties of these objects are then bindable to UI widgets.</simpara>
<example>
<title>Customer.java</title>
<programlisting language="java" linenumbering="unnumbered">@Bindable
public class Customer {
  ...
  private String name;

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }
  ...
}</programlisting>
</example>
<important>
<simpara>If you cannot or prefer not to annotate your classes with <literal><phrase role="code">@Bindable</phrase></literal> , you can alternatively specify bindable types in your ErraiApp.properties using a whitespace-separated list of fully qualified class names: <literal><phrase role="code">errai.ui.bindableTypes=org.example.Model1 org.example.Model2</phrase></literal></simpara>
</important>
</section>
<section id="sid-51282340_DataBinding-InitializingaDataBinder">
<title>Initializing a DataBinder</title>
<simpara>An instance of <literal><phrase role="code">DataBinder</phrase></literal> is required to create bindings. It can either be</simpara>
<simpara>injected into a client-side bean:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class CustomerView {
  @Inject
  private DataBinder&lt;Customer&gt; dataBinder;
}</programlisting>
<simpara>or created manually:</simpara>
<programlisting language="java" linenumbering="unnumbered">DataBinder&lt;Customer&gt; dataBinder = DataBinder.forType(Customer.class);</programlisting>
<simpara>In both cases above, the <literal><phrase role="code">DataBinder</phrase></literal> instance is associated with a new instance of the model (e.g. a new <literal><phrase role="code">Customer</phrase></literal> object). A <literal><phrase role="code">DataBinder</phrase></literal> can also be associated with an already existing object:</simpara>
<programlisting language="java" linenumbering="unnumbered">DataBinder&lt;Customer&gt; dataBinder = DataBinder.forModel(existingCustomerObject);</programlisting>
<simpara>In case there is existing state in either the model object or the UI components before the they are bound, initial state synchronization can be carried out to align the model and the corresponding UI fields.</simpara>
<simpara>For using the model object&#8217;s state to set the initial values in the UI:</simpara>
<programlisting language="java" linenumbering="unnumbered">DataBinder&lt;Customer&gt; dataBinder = DataBinder.forModel(existingCustomerObject, InitialState.FROM_MODEL);</programlisting>
<simpara>For using the UI values to set the initial state in the model object:</simpara>
<programlisting language="java" linenumbering="unnumbered">DataBinder&lt;Customer&gt; dataBinder = DataBinder.forModel(existingCustomerObject, InitialState.FROM_UI);</programlisting>
</section>
</section>
<section id="sid-51282340_DataBinding-CreatingBindings">
<title>Creating Bindings</title>
<simpara>Bindings can be created by calling the <literal><phrase role="code">bind</phrase></literal> method on a <literal><phrase role="code">DataBinder</phrase></literal> instance, thereby specifying which widgets should be bound to which properties of the model. It is possible to use property chains for bindings, given that all nested properties are of bindable types. When binding to <literal><phrase role="code">customer.address.streetName</phrase></literal> , for example, both <literal><phrase role="code">customer</phrase></literal> and <literal><phrase role="code">address</phrase></literal> have to be of a type annotated with <literal><phrase role="code">@Bindable</phrase></literal> .</simpara>
<programlisting language="java" linenumbering="unnumbered">public class CustomerView {
  @Inject
  private DataBinder&lt;Customer&gt; dataBinder;

  private Customer customer;
  private TextBox nameTextBox = new TextBox();
  // more UI widgets...

  @PostConstruct
  private void init() {
    customer = dataBinder
        .bind(nameTextBox, "name")
        .bind(idLabel, "id")
        .getModel();
  }
}</programlisting>
<simpara>After the call to <literal><phrase role="code">dataBinder.bind()</phrase></literal> in the example above, the customer object&#8217;s name property and the <literal><phrase role="code">nameTextBox</phrase></literal> are kept in sync until either the <literal><phrase role="code">dataBinder.unbind()</phrase></literal> method is called or the <literal><phrase role="code">CustomerView</phrase></literal> bean is destroyed.</simpara>
<simpara>That means that a call to <literal><phrase role="code">customer.setName()</phrase></literal> will automatically update the value of the TextBox and any change to the TextBox&#8217;s value in the browser will update the customer object&#8217;s name property. So, <literal><phrase role="code">customer.getName()</phrase></literal> will always reflect the currently displayed value of the <literal><phrase role="code">TextBox</phrase></literal> .</simpara>
<note>
<simpara>It&#8217;s important to retrieve the model instance using dataBinder.getModel() before making changes to it as the data binder will provide a proxy to the model to ensure that changes will update the corresponding UI components.</simpara>
</note>
<tip>
<simpara>Errai also provides a <link linkend="sid-51282340_DataBinding-DeclarativeBinding">declarative binding API</link> that can be used to create bindings automatically based on matching field and model property names.</simpara>
</tip>
</section>
<section id="sid-51282340_DataBinding-SpecifyingConverters">
<title>Specifying Converters</title>
<simpara>Errai has built-in conversion support for all Number types as well as Boolean and Date to java.lang.String and vice versa. However, in some cases it will be necessary to provide custom converters (e.g. if a custom date format is desired). This can be done on two levels.</simpara>
<section id="sid-51282340_DataBinding-Registeringaglobaldefaultconverter">
<title>Registering a global default converter</title>
<programlisting language="java" linenumbering="unnumbered">@DefaultConverter
public class MyCustomDateConverter implements Converter&lt;Date, String&gt; {

  private static final String DATE_FORMAT = "YY_DD_MM";

  @Override
  public Date toModelValue(String widgetValue) {
    return DateTimeFormat.getFormat(DATE_FORMAT).parse(widgetValue);
  }

  @Override
  public String toWidgetValue(Date modelValue) {
    return DateTimeFormat.getFormat(DATE_FORMAT).format((Date) modelValue);
  }
}</programlisting>
<simpara>All converters annotated with <literal><phrase role="code">@DefaultConverter</phrase></literal> will be registered as global defaults calling <literal><phrase role="code">Convert.registerDefaultConverter()</phrase></literal> . Note that the <literal><phrase role="code">Converter</phrase></literal> interface specifies two type parameters. The first one represents the type of the model field, the second one the type held by the widget (e.g. <literal><phrase role="code">String</phrase></literal> for widgets implementing <literal><phrase role="code">HasValue&lt;String&gt;</phrase></literal> ). These default converters will be used for all bindings with matching model and widget types.</simpara>
</section>
<section id="sid-51282340_DataBinding-Providingabindingspecificconverter">
<title>Providing a binding-specific converter</title>
<simpara>Alternatively, converter instances can be passed to the <literal><phrase role="code">dataBinder.bind()</phrase></literal> calls.</simpara>
<programlisting language="java" linenumbering="unnumbered">dataBinder.bind(textBox, "name", customConverter);</programlisting>
<simpara>Converters specified on the binding level take precedence over global default converters with matching types.</simpara>
</section>
</section>
<section id="sid-51282340_DataBinding-PropertyChangeHandlers">
<title>Property Change Handlers</title>
<simpara>In some cases keeping the model and the UI in sync is not enough. Errai&#8217;s <literal><phrase role="code">DataBinder</phrase></literal> allows for the registration of <literal><phrase role="code">PropertyChangeHandlers</phrase></literal> for specific properties, property expressions or all properties of a bound model. A property expression can be a property chain such as customer.address.street. It can end in a wildcard to indicate that changes of any property of the corresponding bean should be observed (e.g <literal><phrase role="code">"customer.address.*"</phrase></literal> ). A double wildcard can be used at the end of a property expression to register a cascading change handler for any nested property (e.g <literal><phrase role="code">"customer.\*\*"</phrase></literal> ).</simpara>
<simpara>This provides a uniform notification mechanism for model and UI value changes. <literal><phrase role="code">PropertyChangeHandlers</phrase></literal> can be used to carry out any additional logic that might be necessary after a model or UI value has changed.</simpara>
<programlisting language="java" linenumbering="unnumbered">dataBinder.addPropertyChangeHandler(new PropertyChangeHandler() {
  @Override
  public void onPropertyChange(PropertyChangeEvent event) {
    Window.alert(event.getPropertyName() + " changed to:" + event.getNewValue());
  }
});</programlisting>
<programlisting language="java" linenumbering="unnumbered">dataBinder.addPropertyChangeHandler("name", new PropertyChangeHandler() {
  @Override
  public void onPropertyChange(PropertyChangeEvent event) {
    Window.alert("name changed to:" + event.getNewValue());
  }
});</programlisting>
</section>
<section id="sid-51282340_DataBinding-DeclarativeBinding">
<title>Declarative Binding</title>
<simpara>Programmatic binding as described above (see <link linkend="sid-51282340_DataBinding-CreatingBindings">Creating Bindings</link> ) can be tedious when working with UI components that contain a large number of input fields. Errai provides an annotation-driven binding API that can be used to create bindings automatically which cuts a lot of boilerplate code. The declarative API will work in any <link linkend="sid-5931402">Errai IOC</link> managed bean (including <link linkend="sid-51806600">Errai UI</link> templates). Simply inject a data binder or model object and declare the bindings using <literal><phrase role="code">@Bound</phrase></literal> .</simpara>
<simpara>Here is a simple example using an injected model object provided by the <literal><phrase role="code">@Model</phrase></literal> annotation (field injection is used here, but constructor and method injection are supported as well):</simpara>
<programlisting language="java" linenumbering="unnumbered">@Dependent
public class CustomerView {
  @Inject @Model
  private Customer customer;

  @Inject @Bound
  private TextBox name;

  @Bound
  private Label id = new Label();

  ....
}</programlisting>
<simpara>Here is the same example injecting a <literal><phrase role="code">DataBinder</phrase></literal> instead of the model object. This is useful when more control is needed (e.g. the ability to register property change handlers). The <literal><phrase role="code">@AutoBound</phrase></literal> annotation specifies that this <literal><phrase role="code">DataBinder</phrase></literal> should be used to bind the model to all enclosing widgets annotated with <literal><phrase role="code">@Bound</phrase></literal> . This example uses field injection again but constructor and method injection are supported as well.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Dependent
public class CustomerView {
  @Inject @AutoBound
  private DataBinder&lt;Customer&gt; customerBinder;

  @Inject @Bound
  private TextBox name;

  @Bound
  private Label id = new Label();

  ...
}</programlisting>
<simpara>In both examples above an instance of the <literal><phrase role="code">Customer</phrase></literal> model is automatically bound to the corresponding UI widgets based on matching field names. The model object and the UI fields will automatically be kept in sync. The widgets are inferred from all enclosing fields and methods annotated with <literal><phrase role="code">@Bound</phrase></literal> of the class that defines the <literal><phrase role="code">@AutoBound DataBinder</phrase></literal> or <literal><phrase role="code">@Model</phrase></literal> and all its super classes.</simpara>
<section id="sid-51282340_DataBinding-Default%2CSimple%2CandChainedPropertyBindings">
<title>Default, Simple, and Chained Property Bindings</title>
<simpara>By default, bindings are determined by matching field names to property names on the model object. In the examples above, the field <literal><phrase role="code">name</phrase></literal> was automatically bound to the JavaBeans property <literal><phrase role="code">name</phrase></literal> of the model ( <literal><phrase role="code">user</phrase></literal> object). If the field name does not match the model property name, you can use the <literal><phrase role="code">property</phrase></literal> attribute of the <literal><phrase role="code">@Bound</phrase></literal> annotation to specify the name of the property. The property can be a simple name (for example, "name") or a property chain (for example, <literal><phrase role="code">user.address.streetName</phrase></literal> ). When binding to a property chain, all properties but the last in the chain must refer to @Bindable values.</simpara>
<simpara>The following example illustrates all three scenarios:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Bindable
public class Address {
  private String line1;
  private String line2;
  private String city;
  private String stateProv;
  private String country;

  // getters and setters
}

@Bindable
public class User {
  private String name;
  private String password;
  private Date dob;
  private Address address;
  private List&lt;Role&gt; roles;

  // getters and setters
}

@Templated
public class UserWidget {
  @Inject @AutoBound DataBinder&lt;User&gt; user;
  @Inject @Bound TextBox name;
  @Inject @Bound("dob") DatePicker dateOfBirth;
  @Inject @Bound("address.city") TextBox city;
}</programlisting>
<simpara>In <literal><phrase role="code">UserWidget</phrase></literal> above, the <literal><phrase role="code">name</phrase></literal> text box is bound to <literal><phrase role="code">user.name</phrase></literal> using the default name matching; the <literal><phrase role="code">dateOfBirth</phrase></literal> date picker is bound to <literal><phrase role="code">user.dob</phrase></literal> using a simple property name mapping; finally, the <literal><phrase role="code">city</phrase></literal> text box is bound to <literal><phrase role="code">user.address.city</phrase></literal> using a property chain. Note that the <literal><phrase role="code">Address</phrase></literal> class is required to be <literal><phrase role="code">@Bindable</phrase></literal> in this case.</simpara>
</section>
<section id="sid-51282340_DataBinding-DataConverters">
<title>Data Converters</title>
<simpara>The <literal><phrase role="code">@Bound</phrase></literal> annotation further allows to specify a converter to use for the binding (see <link linkend="sid-51282340_DataBinding-SpecifyingConverters">Specifying Converters</link> for details). This is how a binding specific converter can be specified on a data field:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Inject
@Bound(converter=MyDateConverter.class)
@DataField
private TextBox date;</programlisting>
</section>
<section id="sid-51282340_DataBinding-Replacingamodelobject">
<title>Replacing a model object</title>
<simpara>The injected model objects in the examples above are always proxies to the actual model since method invocations on these objects need to trigger additional logic for updating the UI. Special care needs to be taken in case a model object should be replaced.</simpara>
<simpara>When working with an <literal><phrase role="code">@AutoBound DataBinder</phrase></literal> , simply calling <literal><phrase role="code">setModel()</phrase></literal> on the <literal><phrase role="code">DataBinder</phrase></literal> will be enough to replace the underlying model instance. However, when working with <literal><phrase role="code">@Model</phrase></literal> the instance cannot be replaced directly. Errai provides a special method level annotation <literal><phrase role="code">@ModelSetter</phrase></literal> that will allow replacing the model instance. Here&#8217;s an example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Dependent
public class CustomerView {
  @Inject @Model
  private Customer customer;

  @Inject @Bound
  private TextBox name;

  @Bound
  private Label id = new Label();

  @ModelSetter
  public void setModel(Customer customer) {
    this.customer = customer;
  }
}</programlisting>
<simpara>The <literal><phrase role="code">@ModelSetter</phrase></literal> method is required to have a single parameter. The parameter type needs to correspond to the type of the managed model.</simpara>
</section>
</section>
<section id="sid-51282340_DataBinding-Beanvalidation">
<title>Bean validation</title>
<simpara>Java bean validation (JSR 303) provides a declarative programming model for validating entities. More details and examples can be found <ulink url="http://docs.jboss.org/hibernate/validator/4.3/reference/en-US/html_single/">here</ulink> . Errai provides a bean validation module that makes <literal><phrase role="code">Validator</phrase></literal> instances injectable and work well with Errai&#8217;s data binding module. The following line needs to be added to the GWT module descriptor to inherit Errai&#8217;s bean validation module:</simpara>
<example>
<title>App.gwt.xml</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;inherits name="org.jboss.errai.validation.Validation" /&gt;

&lt;inherits name="org.hibernate.validator.HibernateValidator" /&gt;</programlisting>
</example>
<simpara>To use Errai&#8217;s bean validation module, you must add the module, the javax.validation API and an implementation such as hibernate validator to your classpath. If you are using Maven for your build, add these dependencies:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.errai&lt;/groupId&gt;
      &lt;artifactId&gt;errai-validation&lt;/artifactId&gt;
      &lt;version&gt;${errai.version}&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;javax.validation&lt;/groupId&gt;
      &lt;artifactId&gt;validation-api&lt;/artifactId&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;javax.validation&lt;/groupId&gt;
      &lt;artifactId&gt;validation-api&lt;/artifactId&gt;
      &lt;classifier&gt;sources&lt;/classifier&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;
      &lt;version&gt;4.2.0.Final&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;
      &lt;version&gt;4.2.0.Final&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
      &lt;classifier&gt;sources&lt;/classifier&gt;
    &lt;/dependency&gt;</programlisting>
<simpara>Now it is as simple as injecting a <literal><phrase role="code">Validator</phrase></literal> instance into an <link linkend="sid-5931402">Errai IOC</link> managed bean and calling the <literal><phrase role="code">validate</phrase></literal> method.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Inject
private Validator validator;</programlisting>
<programlisting language="java" linenumbering="unnumbered">Set&lt;ConstraintViolation&lt;Customer&gt;&gt; violations  = validator.validate(customer);
// display violations</programlisting>
<section id="sid-51282340_DataBinding-ExcludingClassesfromValidation">
<title>Excluding Classes from Validation</title>
<simpara>By default, Errai scans the entire classpath for classes with constraints. But sometimes it is necessary or desirable to exclude some shared classes from being validated on the client side. This can be done by adding a list of classes and package masks to the ErraiApp.properties file like so:</simpara>
<programlisting language="ini" linenumbering="unnumbered"># The following blacklists the class some.fully.qualified.ClassName and all classes in some.package.mask (and subpackages thereof).
errai.validation.blacklist = some.fully.qualified.ClassName \
                             some.package.mask.*</programlisting>
</section>
</section>
</chapter>
<chapter id="sid-51806600">
<title>Errai UI</title>
<informaltable frame="all"
    rowsep="1" colsep="1">
  
  <tgroup cols="2">
    
    <colspec colname="col_1" colwidth="50*"/>
    
    <colspec colname="col_2" colwidth="50*"/>
    
    
    <tbody>
      
      <row>
        
        <entry align="left" valign="top"><simpara>One of the primary complaints of GWT to date has been that it is difficult to use "pure HTML" when building and skinning widgets. Inevitably one must turn to Java-based configuration in order to finish the job. Errai, however, strives to remove the need for Java styling. HTML template files are placed in the project source tree, and referenced from custom "Composite components" (Errai UI Widgets) in Java. Since Errai UI depends on Errai IOC and Errai CDI, dependency injection is supported in all custom components. Errai UI provides rapid prototyping and HTML5 templating for GWT.</simpara></entry>
        
        <entry align="left" valign="top"><simpara><ulink url="http://get.adobe.com/flashplayer/">.TODO Gliffy image title empty
image::http://www.adobe.com/images/shared/download_buttons/get_flash_player.gif[</ulink>
</simpara><simpara></simpara><simpara>]</simpara></entry>
        
      </row>
      
    </tbody>
    
  </tgroup>
</informaltable>
<section id="sid-51806600_ErraiUI-Getstarted">
<title>Get started</title>
<simpara>The Errai UI module is directly integrated with <link linkend="sid-51282340">Data Binding</link> and Errai JPA but can also be used as a standalone project in any GWT client application by simply inheriting the Errai UI GWT module, and ensuring that you have properly using <link linkend="sid-19398999">Errai CDI&#8217;s @Inject</link> to instantiate your widgets:</simpara>
<section id="sid-51806600_ErraiUI-App.gwt.xml">
<title>App.gwt.xml</title>
<programlisting language="xml" linenumbering="unnumbered">
&lt;inherits name="org.jboss.errai.ui.UI" /&gt;
</programlisting>
</section>
<section id="sid-51806600_ErraiUI-pom.xml">
<title>pom.xml</title>
<simpara>The easiest way to get Errai UI on your classpath is to depend on the special <literal><phrase role="code">errai-javaee-all</phrase></literal> artifact, which brings in most Errai modules:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;org.jboss.errai&lt;/groupId&gt;
  &lt;artifactId&gt;errai-javaee-all&lt;/artifactId&gt;
  &lt;version&gt;${errai.version}&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
<simpara>Or if you prefer to manage your project&#8217;s dependency in a finer-grained way, you can depend on <literal><phrase role="code">errai-ui</phrase></literal> directly:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;org.jboss.errai&lt;/groupId&gt;
  &lt;artifactId&gt;errai-ui&lt;/artifactId&gt;
  &lt;version&gt;${errai.version}&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
</section>
<section id="sid-51806600_ErraiUI-WorkingDemo">
<title>Working Demo</title>
<simpara>If you work better by playing with a finished product, you can see a simple client-server project <ulink url="https://github.com/errai/summit-demo-2013">implemented using Errai UI here</ulink> .</simpara>
</section>
</section>
<section id="sid-51806600_ErraiUI-UseErraiUICompositecomponents">
<title>Use Errai UI Composite components</title>
<simpara>Before explaining how to create Errai UI components, it should be noted that these components behave no differently from any other GWT Widget once built. The primary difference is in A) their construction, and B) their instantiation. As with most other features of Errai, dependency injection with CDI is the programming model of choice, so when interacting with components defined using Errai UI, you should always <literal><phrase role="code">@Inject</phrase></literal> references to your Composite components.</simpara>
<section id="sid-51806600_ErraiUI-Injectasingleinstance">
<title>Inject a single instance</title>
<programlisting language="java" linenumbering="unnumbered">@EntryPoint
public class Application {
   @Inject
   private ColorComponent comp;

   @PostConstruct
   public void init() {
      comp.setColor("blue");
      RootPanel.get().add(comp);
   }
}</programlisting>
</section>
<section id="sid-51806600_ErraiUI-Injectmultipleinstances%28foriteration%29">
<title>Inject multiple instances (for iteration)</title>
<programlisting language="java" linenumbering="unnumbered">@EntryPoint
public class Application {
   private String[] colors = new String[]{"Blue", "Yellow", "Red"};

   @Inject
   private Instance&lt;ColorComponent&gt; instance;

   @PostConstruct
   public void init() {
      for(String color: colors) {
        ColorComponent comp = instance.get();
        comp.setColor(c);
        RootPanel.get().add();
      }
   }
}</programlisting>
</section>
</section>
<section id="sid-51806600_ErraiUI-Createa@TemplatedCompositecomponent">
<title>Create a @Templated Composite component</title>
<simpara>Custom components in Errai UI are single classes extending from <literal><phrase role="code">com.google.gwt.user.client.ui.Composite</phrase></literal> , and must be annotated with @Templated.</simpara>
<section id="sid-51806600_ErraiUI-Basiccomponent">
<title>Basic component</title>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class LoginForm extends Composite {
   /* looks for LoginForm.html in LoginForm's package */
}</programlisting>
</section>
<section id="sid-51806600_ErraiUI-Customtemplatenames">
<title>Custom template names</title>
<simpara>With default values, @Templated informs Errai UI to look in the current package for a parallel <literal><phrase role="code">".html"</phrase></literal> template next to the Composite component Class; however, the template name may be overridden by passing a String into the @Templated annotation, like so:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated("my-template.html")
public class LoginForm extends Composite {
   /* looks for my-template.html in LoginForm's package */
}</programlisting>
<simpara>Fully qualified template paths are also supported, but must begin with a leading <emphasis>/</emphasis>:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated("/org/example/my-template.html")
public class LoginForm extends Composite {
   /* looks for my-template.html in package org.example */
}</programlisting>
</section>
</section>
<section id="sid-51806600_ErraiUI-CreateanHTMLtemplate">
<title>Create an HTML template</title>
<simpara>Templates in Errai UI may be designed either as an HTML snippet or as a full HTML document. You can even take an existing HTML page and use it as a template. With either approach, the <literal><phrase role="code">id</phrase></literal> , <literal><phrase role="code">class</phrase></literal> , and <literal><phrase role="code">data-field</phrase></literal> attributes in the template identify elements by name. These elements and their children are used in the Composite component to add behavior, and use additional components to add functionality to the template. There is no limit to how many component classes may share a given HTML template.</simpara>
<simpara>We will begin by creating a simple HTML login form to accompany our <literal><phrase role="code">@Templated LoginForm</phrase></literal> composite component.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;form&gt;
  &lt;legend&gt;Log in to your account&lt;/legend&gt;

  &lt;label for="username"&gt;Username&lt;/label&gt;
  &lt;input id="username" type="text" placeholder="Username"&gt;

  &lt;label for="password"&gt;Password&lt;/label&gt;
  &lt;input id="password" type="password" placeholder="Password"&gt;

  &lt;button&gt;Log in&lt;/button&gt;
  &lt;button&gt;Cancel&lt;/button&gt;
&lt;/form&gt;</programlisting>
<section id="sid-51806600_ErraiUI-SelectatemplatefromalargerHTMLfile">
<title>Select a template from a larger HTML file</title>
<simpara>Or as a full HTML document which may be more easily previewed during design without running the application; however, in this case we must also specify the location of our component&#8217;s root DOM Element using a <literal><phrase role="code">"data-field"</phrase></literal> , <literal><phrase role="code">id</phrase></literal> , or <literal><phrase role="code">class</phrase></literal> attribute matching the value of the @Templated annotation. There is no limit to how many component classes may share a given HTML template.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated("my-template.html#login-form")
public class LoginForm extends Composite {
   /* Specifies that &lt;... id="login-form"&gt; be used as the root Element of this Widget  */
}</programlisting>
<simpara>Notice the corresponding HTML <literal><phrase role="code">id</phrase></literal> attribute in the form Element below (we could have used <literal><phrase role="code">data-field</phrase></literal> or <literal><phrase role="code">class</phrase></literal> instead). Note that multiple components may use the same template provided that they specify a corresponding <literal><phrase role="code">data-field</phrase></literal> , <literal><phrase role="code">id</phrase></literal> , or <literal><phrase role="code">class</phrase></literal> attribute. Also note that two or more components may share the same DOM elements; there is no conflict since components each receive a unique copy of the template DOM rooted at the designated element at runtime (or from the root element if a fragment is not specified.)</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;title&gt;A full HTML snippet&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;
        &lt;form id="login-form"&gt;
          &lt;legend&gt;Log in to your account&lt;/legend&gt;

          &lt;label for="username"&gt;Username&lt;/label&gt;
          &lt;input id="username" type="text" placeholder="Username"&gt;

          &lt;label for="username"&gt;Password&lt;/label&gt;
          &lt;input id="password" type="password" placeholder="Password"&gt;

          &lt;button&gt;Log in&lt;/button&gt;
          &lt;button&gt;Cancel&lt;/button&gt;
        &lt;/form&gt;
    &lt;/div&gt;

    &lt;hr&gt;
    &lt;footer id="theme-footer"&gt;
        &lt;p&gt;(c) Company 2012&lt;/p&gt;
    &lt;/footer&gt;
&lt;/body&gt;
&lt;/html&gt;</programlisting>
<simpara>For example&#8217;s sake, the component below could also use the same template. All it needs to do is reference the template name, and specify a fragment.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated("my-template.html#theme-footer")
public class Footer extends Composite {
   /* Specifies that &lt;... id="theme-footer"&gt; be used as the root Element of this Widget  */
}</programlisting>
</section>
</section>
<section id="sid-51806600_ErraiUI-UseotherWidgetsinacompositecomponent">
<title>Use other Widgets in a composite component</title>
<simpara>Now that we have created the @Templated Composite component and an HTML template, we can start wiring in functionality and behavior; this is done by annotating fields and methods to replace specific sub-elements of the template DOM with other Widgets. We can even replace portions of the template with other Errai UI Widgets!</simpara>
<section id="sid-51806600_ErraiUI-AnnotateWidgetsinthetemplatewith@DataField">
<title>Annotate Widgets in the template with @DataField</title>
<simpara>In order to composite Widgets into the template DOM, you annotate fields in your @Templated Composite component with @DataField, and mark the HTML template Element with a correspondingly named <literal><phrase role="code">data-field</phrase></literal> , <literal><phrase role="code">id</phrase></literal> , or <literal><phrase role="code">class</phrase></literal> attribute. This informs Errai UI which element in the template the Widget should replace. All replacements happen while the @Templated Composite component is being constructed; thus, fields annotated with @DataField must either be {{@Inject}}ed or provide their own Widget or Element instances in field initializers.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class LoginForm extends Composite {
   // This element must be initialized manually because Element is not @Inject-able*/
   @DataField
   private Element form = DOM.createForm();

   // If not otherwise specified, the name to match in the HTML template defaults to the name of the field; in this case, the name would be "username"
   @Inject
   @DataField
   private TextBox username;

   // The name to reference in the template can also be specified manually
   @Inject
   @DataField("pass")
   private PasswordTextBox password;

   // We can also choose to instantiate our own Widgets. Injection is not required.
   @DataField
   private Button submit = new Button();
}</programlisting>
<important>
<simpara>Note: Field, method, and constructor injection are all supported by @DataField.</simpara>
</important>
</section>
<section id="sid-51806600_ErraiUI-AddcorrespondingattributestotheHTMLtemplate">
<title>Add corresponding attributes to the HTML template</title>
<simpara>Each @DataField reference in the Java class must match an element in the HTML template. The matching of Java references to HTML elements is performed as follows:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>A <emphasis>name</emphasis> for the Java reference is determined. If the <literal><phrase role="code">@DataField</phrase></literal> annotation has a value argument, that is used as the reference name. For fields, the default reference name is the field name. Method and constructor parameters have no default name, so they must always specify a value.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>If there is an element in the HTML template with attribute <literal><phrase role="code">data-field=name</phrase></literal> , the Java reference will point to this element. If there is more than one such element, the Java reference points to the first.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Otherwise, if there is an element in the HTML template with attribute <literal><phrase role="code">id=name</phrase></literal> , the Java reference will point to this element. If there is more than one such element, the Java reference points to the first.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Otherwise, if there is an element in the HTML template with a CSS style class <literal><phrase role="code">name</phrase></literal> , the Java reference will point to this element. If there is more than one such element, the Java reference points to the first. For elements with more than one CSS style, each style name is considered individually. For example:</simpara>
      
    </listitem>
  
</orderedlist>
<programlisting language="java" linenumbering="unnumbered">
   &lt;div class="eat drink be-merry"&gt;
</programlisting>
<simpara>matches Java references named <literal><phrase role="code">eat</phrase></literal> , <literal><phrase role="code">drink</phrase></literal> , or <literal><phrase role="code">be-merry</phrase></literal> .</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>If no matching element is found by this point, it is an error.</simpara>
      
    </listitem>
  
</orderedlist>
<simpara>If more than one Java reference matches the same HTML element in the template, it is an error. For example, given a template containing the element <literal><phrase role="code">&lt;div class="eat drink be-merry"&gt;</phrase></literal> , the following Java code is in error:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class ErroneousTemplate extends Composite {
 @Inject @DataField
 private Label eat;

 @Inject @DataField
 private Label drink;
}</programlisting>
<simpara>because both fields <literal><phrase role="code">eat</phrase></literal> and <literal><phrase role="code">drink</phrase></literal> refer to the same HTML <literal><phrase role="code">div</phrase></literal> element.</simpara>
<simpara>So now we must ensure there are <literal><phrase role="code">data-field</phrase></literal> , <literal><phrase role="code">id</phrase></literal> , or <literal><phrase role="code">class</phrase></literal> attributes in the right places in our template HTML file. This, combined with the @DataField annotation in our Composite component allow Errai UI to determine where and what should be composited when creating component instances.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;form id="form"&gt;
  &lt;legend&gt;Log in to your account&lt;/legend&gt;

  &lt;label for="username"&gt;Username&lt;/label&gt;
  &lt;input id="username" type="text" placeholder="Username"&gt;

  &lt;label for="password"&gt;Password&lt;/label&gt;
  &lt;input data-field="pass" id="password" type="password" placeholder="Password"&gt;

  &lt;button id="submit"&gt;Log in&lt;/button&gt;
  &lt;button&gt;Cancel&lt;/button&gt;
&lt;/form&gt;</programlisting>
<simpara>Now, when we run our application, we will be able to interact with these fields in our Widget.</simpara>
</section>
</section>
<section id="sid-51806600_ErraiUI-HowHTMLtemplatesaremergedwithComponents">
<title>How HTML templates are merged with Components</title>
<simpara>Three things are merged or modified when Errai UI creates a new Composite component instance:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>Element attributes are merged from the template to the component</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>DOM Elements are merged from the component to the template</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Template element inner text and inner HTML are preserved when the given <literal><phrase role="code">@DataField</phrase></literal>[code]<literal>Widget</literal> implements <literal><phrase role="code">HasText</phrase></literal> or <literal><phrase role="code">HasHTML</phrase></literal></simpara>
      
    </listitem>
  
</orderedlist>
<section id="sid-51806600_ErraiUI-Example">
<title>Example</title>
<section id="sid-51806600_ErraiUI-Compositecomponentclass%3A">
<title>Composite component class:</title>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class StyledComponent extends Composite {
   @Inject
   @DataField("field-1")
   private Label div = new Label();

   public StyledComponent() {
      div.getElement().setAttribute("style", "position: fixed; top: 0; left: 0;");
      this.getElement().setId("outer-id");
   }
}</programlisting>
</section>
<section id="sid-51806600_ErraiUI-Template%3A">
<title>Template:</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;form&gt;
  &lt;span data-field="field-1" style="display:inline;"&gt; This element will become a div &lt;/span&gt;
&lt;/form&gt;

This text will be ignored.</programlisting>
</section>
<section id="sid-51806600_ErraiUI-Output%2Fresult%3A">
<title>Output / result:</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;form id="outer-id"&gt;
   &lt;div data-field="field-1" style="display:inline;"&gt; This element will become a div &lt;/div&gt;
&lt;/form&gt;</programlisting>
<simpara>But why does the output look the way it does? Some things happened that may be unsettling at first, but we find that once you understand why these things occur, you&#8217;ll find the mechanisms extremely powerful.</simpara>
</section>
</section>
<section id="sid-51806600_ErraiUI-Elementattributes%28templatewins%29">
<title>Element attributes (template wins)</title>
<simpara>When styling your templates, you should keep in mind that all attributes defined in the template file will take precedence over any preset attributes in your Widgets. This "attribute merge" occurs only when the components are instantiated; subsequent changes to any attributes after Widget construction will function normally. In the example we defined a Composite component that applied several styles to a child Widget in its constructor, but we can see from the output that the styles from the template have overridden them. If styles must be applied in Java, instead of the template, <literal><phrase role="code">@PostConstruct</phrase></literal> or other methods should be favored over constructors to apply styles to fully-constructed Composite components.</simpara>
</section>
<section id="sid-51806600_ErraiUI-DOMElements%28componentfieldwins%29">
<title>DOM Elements (component field wins)</title>
<simpara>Element composition, however, functions inversely from attribute merging, and the <literal><phrase role="code">&lt;span&gt;</phrase></literal> defined in our template was actually be replaced by the <literal><phrase role="code">&lt;div&gt;</phrase></literal> Label in our Composite component field. This does not, however, change the behavior of the attribute merge - the new <literal><phrase role="code">&lt;div&gt;</phrase></literal> was still be rendered inline, because we have specified this style in our template, and the template always wins in competition with attributes set programatically before composition occurs. In short, whatever is inside the <literal><phrase role="code">@DataField</phrase></literal> in your class will replace the children of the corresponding element in your template.</simpara>
</section>
<section id="sid-51806600_ErraiUI-InnertextandinnerHTML%28preservedwhencomponentimplementsHasTextorHasHTML%29">
<title>Inner text and inner HTML (preserved when component implements HasText or HasHTML)</title>
<simpara>Additionally, because <literal><phrase role="code">Label</phrase></literal> implements both <literal><phrase role="code">HasText</phrase></literal> and <literal><phrase role="code">HasHTML</phrase></literal> (only one is required,) the contents of this &lt;span&gt; "field-1" Element in the template were preserved; however, this would not have been the case if the <literal><phrase role="code">@DataField</phrase></literal> specified for the element did not implement <literal><phrase role="code">HasText</phrase></literal> or <literal><phrase role="code">HasHTML</phrase></literal> . In short, if you wish to preserve text or HTML contents of an element in your template, you can do one of two things: do not composite that Element with a <literal><phrase role="code">@DataField</phrase></literal> reference, or ensure that the Widget being composited implements <literal><phrase role="code">HasText</phrase></literal> or <literal><phrase role="code">HasHTML</phrase></literal> .</simpara>
</section>
</section>
<section id="sid-51806600_ErraiUI-Eventhandlers">
<title>Event handlers</title>
<simpara>Dealing with User and DOM Events is a reality in rich web development, and Errai UI provides several approaches for dealing with all types of browser events using its "quick handler" functionality. It is possible to handle:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>GWT events on Widgets</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>GWT events on DOM Elements</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Native DOM events on Elements</simpara>
      
    </listitem>
  
</orderedlist>
<important>
<simpara>It is not possible to handle Native DOM events on Widgets because GWT overrides native event handlers when Widgets are added to the DOM. You must programatically configure such handlers after the Widget has been added to the DOM.</simpara>
</important>
<section id="sid-51806600_ErraiUI-Concepts">
<title>Concepts</title>
<simpara>Each of the three scenarios mentioned above use the same basic programming model for event handling: Errai UI wires methods annotated with <literal><phrase role="code">@EventHandler("my-data-field")</phrase></literal> ( <emphasis>event handler methods</emphasis> ) to handle events on the corresponding <literal><phrase role="code">@DataField("my-data-field")</phrase></literal> in the same component. Event handler methods annotated with a bare <literal><phrase role="code">@EventHandler</phrase></literal> annotation (no annotation parameter) are wired to receive events on the @Templated component itself.</simpara>
</section>
<section id="sid-51806600_ErraiUI-GWTeventsonWidgets">
<title>GWT events on Widgets</title>
<simpara>Probably the simplest and most common use-case, this approach handles GWT Event classes for Widgets that explicitly handle the given event type. If a Widget does not handle the Event type given in the <literal><phrase role="code">@EventHandler</phrase></literal> method&#8217;s signature, the application will fail to compile and appropriate errors will be displayed.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class WidgetHandlerComponent extends Composite {

   @Inject
   @DataField("b1")
   private Button button;

   @EventHandler("b1")
   public void doSomethingC1(ClickEvent e) {
     // do something
   }
}</programlisting>
</section>
<section id="sid-51806600_ErraiUI-GWTeventsonDOMElements">
<title>GWT events on DOM Elements</title>
<simpara>Errai UI also makes it possible to handle GWT events on native Elements which are specified as a <literal><phrase role="code">@DataField</phrase></literal> in the component class. This is useful when a full GWT Widget is not available for a given Element, or for GWT events that might not normally be available on a given Element type. This could occur, for instance, when clicking on a <literal><phrase role="code">&lt;div&gt;</phrase></literal> , which would normally not have the ability to receive the GWT <literal><phrase role="code">ClickEvent</phrase></literal> , and would otherwise require creating a custom DIV Widget to handle such an event.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class ElementHandlerComponent extends Composite {

   @DataField("div-1")
   private DivElement button = DOM.createDiv();

   @EventHandler("div-1")
   public void doSomethingC1(ClickEvent e) {
     // do something
   }
}</programlisting>
</section>
<section id="sid-51806600_ErraiUI-NativeDOMeventsonElements">
<title>Native DOM events on Elements</title>
<simpara>The last approach is handles the case where native DOM events must be handled, but no such GWT event handler exists for the given event type. Alternatively, it can also be used for situations where Elements in the template should receive events, but no handle to the Element the component class is necessary (aside from the event handling itself.) Native DOM events do not require a corresponding <literal><phrase role="code">@DataField</phrase></literal> be configured in the class; only the HTML <literal><phrase role="code">data-field</phrase></literal> , <literal><phrase role="code">id</phrase></literal> , or <literal><phrase role="code">class</phrase></literal> template attribute is required.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;div&gt;
   &lt;a id="link" href="/page"&gt;this is a hyperlink&lt;/a&gt;
   &lt;div data-field="div"&gt; Some content &lt;/div&gt;
&lt;/div&gt;</programlisting>
<simpara>The <literal><phrase role="code">@SinkNative</phrase></literal> annotation specifies (as a bit mask) which native events the method should handle; this sink behaves the same in Errai UI as it would with <literal><phrase role="code">DOM.sinkEvents(Element e, int bits)</phrase></literal> . Note that a <literal><phrase role="code">@DataField</phrase></literal> reference in the component class is optional.</simpara>
<important>
<simpara>Only one @EventHandler may be specified for a given template element when @SinkNative is used to handle native DOM events.</simpara>
</important>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class QuickHandlerComponent extends Composite {

  @DataField
  private AnchorElement link = DOM.createAnchor().cast();

  @EventHandler("link")
  @SinkNative(Event.ONCLICK | Event.ONMOUSEOVER)
  public void doSomething(Event e) {
    // do something
  }

  @EventHandler("div")
  @SinkNative(Event.ONMOUSEOVER)
  public void doSomethingElse(Event e) {
    // do something else
  }
}</programlisting>
</section>
</section>
<section id="sid-51806600_ErraiUI-DataBinding">
<title>Data Binding</title>
<simpara>A recurring implementation task in rich web development is writing event handler code for updating model objects to reflect input field changes in the user interface. The requirement to update user interface fields in response to changed model values is just as common. These tasks require a significant amount of boilerplate code which can be alleviated by Errai. Errai&#8217;s <link linkend="sid-51282340">data binding module</link> provides the ability to bind model objects to user interface fields, so they will automatically be kept in sync. While the module can be used on its own, it can cut even more boilerplate when used together with Errai UI.</simpara>
<simpara>In the following example, all <literal><phrase role="code">@DataFields</phrase></literal> annotated with <literal><phrase role="code">@Bound</phrase></literal> have their contents bound to properties of the data model (a <literal><phrase role="code">User</phrase></literal> object). The model object is injected and annotated with <literal><phrase role="code">@Model</phrase></literal> , which indicates automatic binding should be carried out. Alternatively, the model object could be provided by an injected <literal><phrase role="code">DataBinder</phrase></literal> instance annotated with <literal><phrase role="code">@AutoBound</phrase></literal> , see <link linkend="sid-51282340_DataBinding-DeclarativeBinding">Declarative Binding</link> for details.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class LoginForm extends Composite {

   @Inject
   @Model
   private User user;

   @Inject
   @Bound
   @DataField
   private TextBox name;

   @Inject
   @Bound
   @DataField
   private PasswordTextBox password;

   @DataField
   private Button submit = new Button();
}</programlisting>
<simpara>Now the user object and the <literal><phrase role="code">username</phrase></literal> and <literal><phrase role="code">password</phrase></literal> fields in the UI are automatically kept in sync. No event handling code needs to be written to update the user object in response to input field changes and no code needs to be written to update the UI fields when the model object changes. So, with the above annotations in place, it will always be true that <literal><phrase role="code">user.getUsername().equals(username.getText())</phrase></literal> and <literal><phrase role="code">user.getPassword().equals(password.getText())</phrase></literal> .</simpara>
<section id="sid-51806600_ErraiUI-Default%2CSimple%2CandChainedPropertyBindings">
<title>Default, Simple, and Chained Property Bindings</title>
<simpara>By default, bindings are determined by matching field names to property names on the model object. In the example above, the field <literal><phrase role="code">name</phrase></literal> was automatically bound to the JavaBeans property <literal><phrase role="code">name</phrase></literal> of the model ( <literal><phrase role="code">user</phrase></literal> object). If the field name does not match the model property name, you can use the <literal><phrase role="code">property</phrase></literal> attribute of the <literal><phrase role="code">@Bound</phrase></literal> annotation to specify the name of the property. The property can be a simple name (for example, "name") or a property chain (for example, <literal><phrase role="code">user.address.streetName</phrase></literal> ). When binding to a property chain, all properties but the last in the chain must refer to @Bindable values.</simpara>
<simpara>The following example illustrates all three scenarios:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Bindable
public class Address {
  private String line1;
  private String line2;
  private String city;
  private String stateProv;
  private String country;

  // getters and setters
}

@Bindable
public class User {
  private String name;
  private String password;
  private Date dob;
  private Address address;
  private List&lt;Role&gt; roles;

  // getters and setters
}

@Templated
public class UserWidget extends Composite {
  @Inject @AutoBound DataBinder&lt;User&gt; user;
  @Inject @Bound TextBox name;
  @Inject @Bound("dob") DatePicker dateOfBirth;
  @Inject @Bound("address.city") TextBox city;
}</programlisting>
<simpara>In <literal><phrase role="code">UserWidget</phrase></literal> above, the <literal><phrase role="code">name</phrase></literal> text box is bound to <literal><phrase role="code">user.name</phrase></literal> using the default name matching; the <literal><phrase role="code">dateOfBirth</phrase></literal> date picker is bound to <literal><phrase role="code">user.dob</phrase></literal> using a simple property name mapping; finally, the <literal><phrase role="code">city</phrase></literal> text box is bound to <literal><phrase role="code">user.address.city</phrase></literal> using a property chain. Note that the <literal><phrase role="code">Address</phrase></literal> class is required to be <literal><phrase role="code">@Bindable</phrase></literal> in this case.</simpara>
</section>
<section id="sid-51806600_ErraiUI-BindingofLists">
<title>Binding of Lists</title>
<simpara>Often you will need to bind a list of model objects so that every object in the list is bound to a corresponding widget. This task can be accomplished using Errai UI&#8217;s <literal><phrase role="code">ListWidget</phrase></literal> class. Here&#8217;s an example of binding a list of users using the <literal><phrase role="code">UserWidget</phrase></literal> class from the previous example. First, we need to enhance <literal><phrase role="code">UserWidget</phrase></literal> to implement <literal><phrase role="code">HasModel</phrase></literal> .</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class UserWidget extends Composite implements HasModel&lt;User&gt; {
  @Inject @AutoBound DataBinder&lt;User&gt; userBinder;
  @Inject @Bound TextBox name;
  @Inject @Bound("dob") DatePicker dateOfBirth;
  @Inject @Bound("address.city") TextBox city;

  public User getModel() {
    userBinder.getModel();
  }

  public void setModel(User user) {
    userBinder.setModel(user);
  }
}</programlisting>
<simpara>Now we can use <literal><phrase role="code">UserWidget</phrase></literal> to display items in a list.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class MyComposite extends Composite {

  @Inject @DataField ListWidget&lt;User, UserWidget&gt; userListWidget;

  @PostConstruct
  public void init() {
    List&lt;User&gt; users = .....
    userListWidget.setItems(users);
  }
}</programlisting>
<simpara>Calling <literal><phrase role="code">setItems</phrase></literal> on the <literal><phrase role="code">userListWidget</phrase></literal> causes an instance of <literal><phrase role="code">UserWidget</phrase></literal> to be displayed for each user in the list. The <literal><phrase role="code">UserWidget</phrase></literal> is then bound to the corresponding user object. By default, the widgets are arranged in a vertical panel. However, <literal><phrase role="code">ListWidget</phrase></literal> can also be subclassed to provide alternative behaviour. In the following example, we use a horizontal panel to display the widgets.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class UserListWidget extends ListWidget&lt;User, UserWidget&gt; {

  public UserList() {
    super(new HorizontalPanel());
  }

  @PostConstruct
  public void init() {
    List&lt;User&gt; users = .....
    setItems(users);
  }

  @Override
  public Class&lt;UserWidget&gt; getItemWidgetType() {
    return UserWidget.class;
  }
}</programlisting>
<section id="sid-51806600_ErraiUI-Bindinglistswith@Bound">
<title>Binding lists with @Bound</title>
<simpara>An instance of <literal><phrase role="code">ListWidget</phrase></literal> can also participate in automatic bindings using <literal><phrase role="code">@Bound</phrase></literal> . In this case, <literal><phrase role="code">setItems</phrase></literal> never needs to be called manually. The bound list property and displayed items will automatically be kept in sync. In the example below a list of user roles is bound to a <literal><phrase role="code">ListWidget</phrase></literal> that displays and manages a <literal><phrase role="code">RoleWidget</phrase></literal> for each role in the list. Every change to the list returned by <literal><phrase role="code">user.getRoles()</phrase></literal> will now trigger a corresponding update in the UI.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class UserDetailView extends Composite {

   @Inject
   @Bound
   @DataField
   private TextBox name;

   @Inject
   @Bound
   @DataField
   private PasswordTextBox password;

   @Inject
   @Bound
   @DataField
   private ListWidget&lt;Role, RoleWidget&gt; roles;

   @DataField
   private Button submit = new Button();

   @Inject @Model
   private User user;
}</programlisting>
</section>
</section>
<section id="sid-51806600_ErraiUI-DataConverters">
<title>Data Converters</title>
<simpara>The <literal><phrase role="code">@Bound</phrase></literal> annotation further allows to specify a converter to use for the binding (see <link linkend="sid-51282340_DataBinding-SpecifyingConverters">Specifying Converters</link> for details). This is how a binding specific converter can be specified on a data field:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Inject
@Bound(converter=MyDateConverter.class)
@DataField
private TextBox date;</programlisting>
<simpara>Errai&#8217;s <literal><phrase role="code">DataBinder</phrase></literal> also allows to register <literal><phrase role="code">PropertyChangeHandlers</phrase></literal> for the cases where keeping the model and UI in sync is not enough and additional logic needs to be executed (see <link linkend="sid-51282340_DataBinding-PropertyChangeHandlers">Property Change Handlers</link> for details).</simpara>
</section>
</section>
<section id="sid-51806600_ErraiUI-NestCompositecomponents">
<title>Nest Composite components</title>
<simpara>Using Composite components to build up a hierarchy of widgets functions exactly the same as when building hierarchies of GWT widgets. The only distinction might be that with Errai UI, <literal><phrase role="code">@Inject</phrase></literal> is preferred to manual instantiation.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class ComponentOne extends Composite {

   @Inject
   @DataField("other-comp")
   private ComponentTwo two;
}</programlisting>
</section>
<section id="sid-51806600_ErraiUI-ExtendCompositecomponents">
<title>Extend Composite components</title>
<simpara>Templating would not be complete without the ability to inherit from parent templates, and Errai UI also makes this possible using simple Java inheritance. The only additional requirement is that Composite components extending from a parent Composite component must also be annotated with @Templated, and the path to the template file must also be specified in the child component&#8217;s annotation. Child components may specify <literal><phrase role="code">@DataField</phrase></literal> references that were omitted in the parent class, and they may also override <literal><phrase role="code">@DataField</phrase></literal> references (by using the same <literal><phrase role="code">data-field</phrase></literal> name) that were already specified in the parent component.</simpara>
<section id="sid-51806600_ErraiUI-Template">
<title>Template</title>
<simpara>Extension templating is particularly useful for creating reusable page layouts with some shared content (navigation menus, side-bars, footers, etc&#8230;,) where certain sections will be filled with unique content for each page that extends from the base template; this is commonly seen when combined with the MVP design pattern traditionally used in GWT applications.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;div class="container"&gt;
   &lt;div id="header"&gt; Default header &lt;/div&gt;
   &lt;div id="content"&gt; Default content &lt;/div&gt;
   &lt;div id="footer"&gt; Default footer &lt;/div&gt;
&lt;/div&gt;</programlisting>
</section>
<section id="sid-51806600_ErraiUI-Parentcomponent">
<title>Parent component</title>
<simpara>This component provides the common features of our page layout, including header and footer, but does not specify any content. The missing @DataField "content" will be provided by the individual page components extending from this parent component.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class PageLayout extends Composite {

   @Inject
   @DataField
   private HeaderComponent header;

   @Inject
   @DataField
   private FooterComponent footer;

   @PostConstruct
   public final void init() {
      // do some setup
   }
}</programlisting>
</section>
<section id="sid-51806600_ErraiUI-Childcomponent">
<title>Child component</title>
<simpara>We are free to fill in the missing "content" @DataField with a Widget of our choosing. Note that it is not required to fill in all omitted @DataField references.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated("PageLayout.html")
public class LoginLayout extends PageLayout {

   @Inject
   @DataField
   private LoginForm content;

}</programlisting>
<simpara>We could also have chosen to override one or more <literal><phrase role="code">@DataField</phrase></literal> references defined in the parent component, simply by specifying a <literal><phrase role="code">@DataField</phrase></literal> with the same name in the child component, as is done with the "footer" data field below.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated("PageLayout.html")
public class LoginLayout extends PageLayout {

   @Inject
   @DataField
   private LoginForm content;

   /* Override footer defined in PageLayout */
   @Inject
   @DataField
   private CustomFooter footer;

}</programlisting>
</section>
</section>
<section id="sid-51806600_ErraiUI-Stylesheetbinding">
<title>Stylesheet binding</title>
<simpara>When developing moderately-complex web applications with Errai, you may find yourself needing to do quite a bit of programmatic style changes. A common case being: showing or enabling controls only if a user has the necessary permissions to use them. One part of the problem is securing those features from being used, and the other part  which is an important usability consideration  is communicating that state to the user.</simpara>
<simpara>Let&#8217;s start with the example case I just described. We have a control that we only want to be visible if the user is an admin. So the first thing we do is create a style binding annotation.</simpara>
<programlisting language="java" linenumbering="unnumbered">@StyleBinding
@Retention(RetentionPolicy.RUNTIME)
public @interface Admin {
}</programlisting>
<simpara>This defines <literal><phrase role="code">Admin</phrase></literal> as a stylebinding now we can use it like this:</simpara>
<programlisting language="java" linenumbering="unnumbered">@EntryPoint
@Templated
public class HelloWorldForm extends Composite {
  @Inject @Admin @DataField Button deleteButton;
  @Inject SessionManager sessionManager;


  @EventHandler("deleteButton")
  private void handleSendClick(ClickEvent event) {
    // do some deleting!
  }

  @Admin
  private void applyAdminStyling(Style style) {
    if (!sessionManager.isAdmin()) {
      style.setVisibility(Style.Visibility.HIDDEN);
    }
  }
}</programlisting>
<simpara>Now before the form is shown to the user the <literal><phrase role="code">applyAdminStyling</phrase></literal> method will be executed where the <literal><phrase role="code">sessionManager</phrase></literal> is queried to see if the user is an admin if not the delete button that is also annotated with <literal><phrase role="code">@Admin</phrase></literal> will be hidden from the view.</simpara>
<simpara>In addition when using this in conjunction with Errai Databinding. Any Errai UI component which uses @AutoBound, will get live updating of the style rules for free, anytime the model changes. Allowing dynamic styling based on user input and other state changes.</simpara>
</section>
<section id="sid-51806600_ErraiUI-Internationalization%28i18n%29">
<title>Internationalization (i18n)</title>
<simpara>User interfaces often need to be available in multiple languages. To get started with Errai&#8217;s internationalization support, simply put the <literal><phrase role="code">@Bundle("bundle.json")</phrase></literal> annotation on your entry point and add an empty <literal><phrase role="code">bundle.json</phrase></literal> file to your classpath (e.g. to src/main/java or src/main/resources). Of course, you can name it differently.</simpara>
<simpara>Errai will scan your HTML templates and process all text elements to generate key/value pairs for translation. It will generate a file called <literal><phrase role="code">errai-bundle-all.json</phrase></literal> and put it in your <literal><phrase role="code">.errai</phrase></literal> directory. You can copy this generated file and use it as a starting point for your custom translation bundles. If the text value is longer than 128 characters the key will get cut off and a hash appended at the end.</simpara>
<simpara>The translation bundle files use the same naming scheme as Java (e.g. <literal><phrase role="code">bundle_nl_BE.json</phrase></literal> for Belgian Dutch and <literal><phrase role="code">bundle_nl.json</phrase></literal> for plain Dutch). Errai will also generate a file called <literal><phrase role="code">errai-bundle-missing.json</phrase></literal> in the <literal><phrase role="code">.errai</phrase></literal> folder containing all template values for which no translations have been defined. You can copy the key/value pairs out of this file to create our own translations:</simpara>
<programlisting language="java" linenumbering="unnumbered">{
"StoresPage.Stores!" : "Stores!",
"WelcomePage.As_you_move_toward_a_more_and_more_declarative_style,_you_allow_the_compiler_and_the_framework_to_catch_more_mistakes_up_front._-734987445" : "As you move toward a more and more declarative style, you allow the compiler and the framework to catch more mistakes up front. Broken links? A thing of the past!"
}</programlisting>
<simpara>If you want to use your own keys instead of these generated ones you can specify them in your templates using the <literal><phrase role="code">data-i18n-key</phrase></literal> attribute:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;html&gt;
&lt;body&gt;
  &lt;div id="content"&gt;
  &lt;p data-i18n-key="welcome"&gt;Welcome to errai-ui i18n.&lt;/p&gt;
&lt;div&gt;
...</programlisting>
<simpara>By adding this attribute in the template you can translate it with the following:</simpara>
<programlisting language="java" linenumbering="unnumbered">{
    "Widget.welcome": "Willkommen bei Errai-ui i18n."
}</programlisting>
<simpara>Because your templates are designer templates and can contain some mock data that doesn&#8217;t need to be translated, Errai has the ability to indicate that with an attribute <literal><phrase role="code">data-role=dummy</phrase></literal> :</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;div id=navbar data-role=dummy&gt;
  &lt;div class="navbar navbar-fixed-top"&gt;
    &lt;div class=navbar-inner&gt;
      &lt;div class=container&gt;
        &lt;span class=brand&gt;Example Navbar&lt;/span&gt;
        &lt;ul class=nav&gt;
          &lt;li&gt;&lt;a&gt;Item&lt;/a&gt;
          &lt;li&gt;&lt;a&gt;Item&lt;/a&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</programlisting>
<simpara>Here the template fills out a navbar with dummy elements, useful for creating a design, adding <literal><phrase role="code">data-role=dummy</phrase></literal> will not only exclude it form being translated it will also strip the children nodes from the template that will be used by the application.</simpara>
<simpara>When you have setup a translation of your application Errai will look at the browser locale and select the locale, if it&#8217;s available, if not it will use the default ( <literal><phrase role="code">bundle.json</phrase></literal> ). If the users of your application need to be able to switch the language manually, Errai offers a pre build component you can easily add to your page: <literal><phrase role="code">LocaleListBox</phrase></literal> will render a Listbox with all available languages. If you want more control of what this language selector looks like there is also a <literal><phrase role="code">LocaleSelector</phrase></literal> that you can use to query and select the locale for example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated
public class NavBar extends Composite {

  @Inject
  private LocaleSelector selector;

  @Inject @DataField @OrderedList
  ListWidget&lt;Locale, LanguageItem&gt; language;

  @AfterInitialization
  public void buildLangaugeList() {
    language.setItems(new ArrayList&lt;Locale&gt;(selector.getSupportedLocales()));
  }

...
// in LanguageItem we add a click handler on a link

  @Inject
  Navigation navigation;

  @Inject
  private LocaleSelector selector;

  link.addClickHandler(new ClickHandler() {
      @Override
      public void onClick(ClickEvent event) {
        selector.select(model.getLocale());
        navigation.goTo(navigation.getCurrentPage().name());
      }
    });</programlisting>
</section>
<section id="sid-51806600_ErraiUI-ExtendedstylingwithLESS">
<title>Extended styling with LESS</title>
<simpara>Errai also supports <ulink url="http://lesscss.org">LESS</ulink> stylesheets. To get started using these you&#8217;ll have to create a LESS stylesheet and place it on the classpath of your project. Errai will convert the LESS stylesheet to css preform optimisations on it and ensure that is get injected into the pages of your application. It will also obfuscate the class selectors and replace the use of those in your templates. To be able to use the selectors in your code you can use:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class MyComponent extends Component {
  @Inject
  private LessStyle lessStyle;

  ...

  @PostCreate
  private void init() {
    textBox.setStyleName(lessStyle.get("input"));
  }
}</programlisting>
<simpara>Finally it will also add any deferred binding properties to the top of your LESS stylesheet, so for example you could use the user.agent in LESS like this:</simpara>
<programlisting language="java" linenumbering="unnumbered">.mixin (@a) when (@a = "safari") {
  background-color: black;
}

.mixin (@a) when (@a = "gecko1_8") {
  background-color: white;
}

.class1 { .mixin(@user_agent) }</programlisting>
<simpara>Because a dot is not allowed in LESS variables it&#8217;s replaced with an underscore, so in the example above class1 will have a black background on Safari and Chrome and white on Firefox. On the top of this LESS stylesheet @user_agent: "safari" will get generated.</simpara>
</section>
</chapter>
<chapter id="sid-54493676">
<title>Errai UI Navigation</title>
<simpara>Starting in version 2.1, Errai offers a system for creating applications that have multiple bookmarkable pages. This navigation system has the following features:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>Declarative, statically-analyzable configuration of pages and links</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Compile time referential safety (i.e. &ldquo;no broken links&rdquo;)</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Generates a storyboard of the application&rsquo;s navigation flow at compile time</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Decentralized configuration</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Create a new page by creating a new annotated class. No need to edit a second file.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Make navigational changes in the natural place in the code.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Integrates cleanly with Errai UI templates, but also works well with other view technologies.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Builds on Errai IoC &amp; CDI</simpara>
      
    </listitem>
  
</itemizedlist>

<section id="sid-54493676_ErraiUINavigation-GettingStarted">
<title>Getting Started</title>
<section id="sid-54493676_ErraiUINavigation-Compiletimedependency">
<title>Compile-time dependency</title>
<simpara>To use Errai UI Navigation, you must include it on the compile-time classpath. If you are using Maven for your build, add these dependencies:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.errai&lt;/groupId&gt;
      &lt;artifactId&gt;errai-navigation&lt;/artifactId&gt;
      &lt;version&gt;${errai.version}&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.errai&lt;/groupId&gt;
      &lt;artifactId&gt;errai-cdi-client&lt;/artifactId&gt;
      &lt;version&gt;${errai.version}&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;</programlisting>
<simpara>If you are not using Maven for dependency management, add <literal><phrase role="code">errai-navigation-</phrase></literal>[code]<literal>version</literal>[code]<literal>.jar</literal> to the compile-time classpath of a project that&#8217;s already set up for Errai UI templating.</simpara>
</section>
<section id="sid-54493676_ErraiUINavigation-GWTModuleDescriptor">
<title>GWT Module Descriptor</title>
<simpara>Once you have Errai UI Navigation on your classpath, ensure your application inherits the GWT module as well. Add this line to your application&#8217;s <literal><phrase role="code">\*.gwt.xml</phrase></literal> file:</simpara>
<programlisting language="xml" linenumbering="unnumbered">   &lt;inherits name="org.jboss.errai.ui.nav.Navigation"/&gt;</programlisting>
</section>
</section>
<section id="sid-54493676_ErraiUINavigation-HowitWorks">
<title>How it Works</title>
<simpara>Errai Navigation has three main parts: the <literal><phrase role="code">@Page</phrase></literal> annotation marks any widget as a page; the <literal><phrase role="code">TransitionTo&lt;P&gt;</phrase></literal> interface is an injectable type that provides a link to another page; and the <literal><phrase role="code">Navigation</phrase></literal> singleton offers control over the navigation system as a whole.</simpara>
<simpara>The <literal><phrase role="code">Navigation</phrase></literal> singleton owns a GWT Panel called the <emphasis>navigation panel</emphasis> . This panel always contains a widget corresponding to the the fragment ID (the part after the # symbol) in the browser&#8217;s location bar. Whenever the fragment ID changes for any reason (for example, because the user pressed the back button, navigated to a bookmarked URL, or simply typed a fragment ID by hand), the widget in the navigation panel is replaced by the widget associated with that fragment ID. Likewise, when the application asks the navigation system to follow a link, the fragment ID in the browser&#8217;s location bar is updated to reflect the new current page.</simpara>
<section id="sid-54493676_ErraiUINavigation-DeclaringaPage">
<title>Declaring a Page</title>
<simpara>To declare a page, annotate any subclass of Widget with the <literal><phrase role="code">@Page</phrase></literal> annotation:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Page
public class ItemListPage extends Composite {
  // Anything goes...
}</programlisting>
<simpara>By default, the name of a page is the simple name of the class that declares it. In the above example, the <literal><phrase role="code">ItemListPage</phrase></literal> will fill the navigation panel whenever the browser&#8217;s location bar ends with <literal><phrase role="code">#ItemListPage</phrase></literal> . If you prefer a different page name, use the <literal><phrase role="code">@Page</phrase></literal> annotation&#8217;s <literal><phrase role="code">path</phrase></literal> attribute:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Page(path="items")
public class ItemListPage extends Composite {
  // Anything goes...
}</programlisting>
<important>
<title>Navigation and Errai UI</title>
<simpara>Any widget can be a page. This includes Errai UI <literal><phrase role="code">@Templated</phrase></literal> classes! Simply annotate any Errai UI templated class with <literal><phrase role="code">@Page</phrase></literal> , and it will become a page that can be navigated to.</simpara>
</important>
<section id="sid-54493676_ErraiUINavigation-TheStartingPage">
<title>The Starting Page</title>
<simpara>Each application must have exactly one <emphasis>starting page</emphasis> . This requirement is enforced at compile time. The starting page is displayed when there is no fragment ID present in the browser&#8217;s location bar.</simpara>
<simpara>Use the <literal><phrase role="code">startingPage</phrase></literal> attribute to declare the starting page, like this:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Page(startingPage=true)
public class WelcomePage extends Composite {
  // Anything goes...
}</programlisting>
<simpara>Pages are looked up as CDI beans, so you can inject other CDI beans into fields or a constructor. Pages can also have <literal><phrase role="code">@PostConstruct</phrase></literal> and <literal><phrase role="code">@PreDestroy</phrase></literal> CDI methods.</simpara>
</section>
<section id="sid-54493676_ErraiUINavigation-PageLifecycle">
<title>Page Lifecycle</title>
<simpara>There are four annotations related to page lifecycle events: <literal><phrase role="code">@PageShowing</phrase></literal> , <literal><phrase role="code">@PageShown</phrase></literal> , <literal><phrase role="code">@PageHiding</phrase></literal> , and <literal><phrase role="code">@PageHidden</phrase></literal> . These annotations designate methods so a page widget can be notified when it is displayed or hidden:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Page
public class ItemPage extends VerticalPanel {

  @PageShowing
  private void preparePage() {
  }

  @PageHiding
  private void unpreparePage() {
  }

  // Anything goes...
}</programlisting>
<simpara>Page Lifecycle:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>The fragment identifier in the URL changes</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The <literal><phrase role="code">@PageHiding</phrase></literal> method on the current (about-to-be-navigated-away-from) page is invoked</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The current page is removed from the browser&#8217;s DOM</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The <literal><phrase role="code">@PageHidden</phrase></literal> method on the just-removed page is invoked</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The navigation system looks up the corresponding <literal><phrase role="code">@Page</phrase></literal> bean in the client-side bean manager (we&#8217;ll call this bean "the new page")</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The navigation system writes to all <literal><phrase role="code">@PageState</phrase></literal> fields in the new page bean (more on this in the next section)</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The <literal><phrase role="code">@PageShowing</phrase></literal> method of the new page is invoked</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The new page widget is added to the DOM (as a direct child of the navigation content panel)</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The <literal><phrase role="code">@PageShown</phrase></literal> method of the new page is invoked.</simpara>
      
    </listitem>
  
</orderedlist>
<simpara>The <literal><phrase role="code">@PageShowing</phrase></literal> and <literal><phrase role="code">@PageShown</phrase></literal> methods are permitted one optional parameter of type <literal><phrase role="code">HistoryToken</phrase></literal> ---more on this in the next section.</simpara>
<simpara>The lifespan of a Page instance is governed by CDI scope: Dependent and implict-scoped page beans are instantiated each time the user navigates to them, whereas Singleton and ApplicationScoped beans are created only once over the lifetime of the application. If a particular page is slow to appear because its UI takes a lot of effort to build, try marking it as a singleton.</simpara>
</section>
<section id="sid-54493676_ErraiUINavigation-PageStateParameters">
<title>Page State Parameters</title>
<simpara>A page widget will often represent a view on on instance of a class of things. For example, there might be an ItemPage that displays a particular item available at a store. In cases like this, it&#8217;s important that the bookmarkable navigation URL includes not only the name of the page but also an identifier for the particular item being displayed.</simpara>
<simpara>This is where page state parameters come in. Consider the following page widget:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Page
public class ItemPage extends VerticalPanel {

  @PageState
  private int itemId;

  // Anything goes...
}</programlisting>
<simpara>This page would be reachable at a URL like <literal><phrase role="code">+ . Before the page was displayed, the Errai UI Navigation framework would write the [code]+int</phrase></literal> value <literal><phrase role="code">4</phrase></literal> into the <literal><phrase role="code">itemId</phrase></literal> field.</simpara>
<simpara>There are three ways to pass state information to a page: by passing a Multimap to <literal><phrase role="code">TransitionTo.go()</phrase></literal> ; by passing a Multimap to <literal><phrase role="code">Navigation.goTo()</phrase></literal> , or by including the state information in the fragment identifier of a hyperlink as illustrated in the previous paragraph (use the <literal><phrase role="code">HistoryToken</phrase></literal> class to construct such a fragment ID properly.)</simpara>
<simpara>A page widget can have any number of <literal><phrase role="code">@PageState</phrase></literal> fields. The fields can be of any primitive or boxed primitive type (except <literal><phrase role="code">char</phrase></literal> or <literal><phrase role="code">Character</phrase></literal> ), <literal><phrase role="code">String</phrase></literal> , or a <literal><phrase role="code">Collection</phrase></literal> , <literal><phrase role="code">List</phrase></literal> , or <literal><phrase role="code">Set</phrase></literal> of the allowable scalar types. Nested collections are not supported.</simpara>
<simpara><literal><phrase role="code">@PageState</phrase></literal> fields can be private, protected, default access, or public. They are always updated by direct field access; never via a setter method. The updates occur just before the <literal><phrase role="code">@PageShowing</phrase></literal> method is invoked.</simpara>
<simpara>In addition to receiving page state information via direct writes to <literal><phrase role="code">@PageState</phrase></literal> fields, you can also receive the whole Multimap in the <literal><phrase role="code">@PageShowing</phrase></literal> and <literal><phrase role="code">@PageShown</phrase></literal> methods through a parameter of type <literal><phrase role="code">HistoryToken</phrase></literal> . Whether or not a lifecycle method has such a parameter, the <literal><phrase role="code">@PageState</phrase></literal> fields will still be written as usual.</simpara>
<simpara>Page state values are represented in the URL much like HTML form parameters: as key=value pairs separated by the ampersand ( <literal><phrase role="code">&amp;</phrase></literal> ) character. Multi-valued page state fields are represented by repeated occurrences of the same key. If a key corresponding to a <literal><phrase role="code">@PageState</phrase></literal> field is absent from the state information passed to the page, the framework writes a default value: <literal><phrase role="code">null</phrase></literal> for scalar Object fields, the JVM default (0 or false) for primitives, and an empty collection for collection-valued fields. To construct and parse state tokens programmatically, use the <literal><phrase role="code">HistoryToken</phrase></literal> class.</simpara>
</section>
</section>
<section id="sid-54493676_ErraiUINavigation-DeclaringaLinkwithTransitionAnchor">
<title>Declaring a Link with TransitionAnchor</title>
<simpara>The easiest way to declare a link between pages is to inject an instance of <literal><phrase role="code">TransitionAnchor&lt;P&gt;</phrase></literal> , where <literal><phrase role="code">P</phrase></literal> is the class of the target page.</simpara>
<simpara>Here is an example declaring an anchor link from the templated welcome page to the item list page. The first code sample would go in WelcomePage.java while the second would go in the WelcomePage.html, the associated html template.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Page(startingPage=true)
@Templated
public class WelcomePage extends Composite {

  @Inject @DataField TransitionAnchor&lt;ItemListPage&gt; itemLink;

}</programlisting>
<programlisting language="xml" linenumbering="unnumbered">&lt;div&gt;
  &lt;a data-field="itemLink"&gt;Go to Item List Page&lt;/a&gt;
&lt;/div&gt;</programlisting>
<simpara>You can inject any number of links into a page. The only restriction is that the target of the link must be a Widget type that is annotated with <literal><phrase role="code">@Page</phrase></literal> . When the user clicks the link Errai will transition to the item list page.</simpara>
</section>
<section id="sid-54493676_ErraiUINavigation-DeclaringaManualLink">
<title>Declaring a Manual Link</title>
<simpara>Sometimes it is necessary to manually transition between pages (such as in response to an event being fired). To declare a manual link from one page to another, inject an instance of <literal><phrase role="code">TransitionTo&lt;P&gt;</phrase></literal> , where <literal><phrase role="code">P</phrase></literal> is the class of the target page.</simpara>
<simpara>This code declares a manual transition from the welcome page to the item list page:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Page(startingPage=true)
public class WelcomePage extends Composite {

  @Inject TransitionTo&lt;ItemListPage&gt; startButtonClicked;

}</programlisting>
<simpara>You do not need to implement the <literal><phrase role="code">TransitionTo</phrase></literal> interface yourself; the framework creates the appropriate instance for you.</simpara>
<simpara>As with <literal><phrase role="code">TransitionAnchor</phrase></literal> , the only restriction is that the target of the link must be a Widget type that is annotated with <literal><phrase role="code">@Page</phrase></literal> .</simpara>
</section>
<section id="sid-54493676_ErraiUINavigation-FollowingaManualLink">
<title>Following a Manual Link</title>
<simpara>To follow a manual link, simply call the <literal><phrase role="code">go()</phrase></literal> method on an injected <literal><phrase role="code">TransitionTo</phrase></literal> object. For example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Page(startingPage=true)
public class WelcomePage extends Composite {

  @Inject TransitionTo&lt;ItemListPage&gt; startButtonClicked;

  public void onStartButtonPressed(ClickEvent e) {
    startButtonClicked.go();
  }
}</programlisting>
</section>
<section id="sid-54493676_ErraiUINavigation-InstallingtheNavigationPanelintotheUserInterface">
<title>Installing the Navigation Panel into the User Interface</title>
<simpara>Beginning in version 2.4, Errai will automatically attach the Navigation Panel to the Root Panel, but it is possible to override this behaviour by simply adding the Navigation Panel to another component manually. The best time to do this is during application startup, for example in the <literal><phrase role="code">@PostConstruct</phrase></literal> method of your <literal><phrase role="code">@EntryPoint</phrase></literal> class. By using the default behaviour you can allow Errai Navigation to control the full contents of the page, or you can opt to keep some parts of the page (headers, footers, and sidebars, for example) away from Errai Navigation by choosing an alternate location for the Navigation Panel.</simpara>
<simpara>The following example reserves space for header and footer content that is not affected by the navigation system:</simpara>
<programlisting language="java" linenumbering="unnumbered">@EntryPoint
public class Bootstrap {

  @Inject
  private Navigation navigation;

  @PostConstruct
  public void clientMain() {
    VerticalPanel vp = new VerticalPanel();
    vp.add(new HeaderWidget());
    vp.add(navigation.getContentPanel());
    vp.add(new FooterWidget());

    RootPanel.get().add(vp);
  }
}</programlisting>
<simpara>This last example demonstrates a simple approach to defining the page structure with an Errai UI template. The final product is identical to the above example, but in this case the overall page structure is declared in an HTML template rather than being defined programmatically in procedural logic:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated
@EntryPoint
public class OverallPageStrucutre extends Composite {

  @Inject
  private Navigation navigation;

  @Inject @DataField
  private HeaderWidget header;

  @Inject @DataField
  private SimplePanel content;

  @Inject @DataField
  private FooterWidget footer;

  @PostConstruct
  public void clientMain() {

    // give over the contents of this.content to the navigation panel
    content.add(navigation.getContentPanel());

    // add this whole templated widget to the root panel
    RootPanel.get().add(this);
  }

}</programlisting>
</section>
<section id="sid-54493676_ErraiUINavigation-OverridingthedefaultNagivatingPaneltype">
<title>Overriding the default Nagivating Panel type</title>
<simpara>By default Errai uses <literal><phrase role="code">com.google.gwt.user.client.ui.SimplePanel</phrase></literal> as a container for navigation panel. Sometimes this is not sufficient and users would prefer using another implementation. For example a <literal><phrase role="code">com.google.gwt.user.client.ui.SimpleLayoutPanel</phrase></literal> that manages child size state.</simpara>
<simpara>To provide your own implementation of the navigation panel you must implement <literal><phrase role="code">org.jboss.errai.ui.nav.client.local.NavigatingContainer</phrase></literal> . For example:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class NavigatingPanel implements NavigatingContainer {

  SimplePanel panel = new SimpleLayoutPanel();

  public void clear() {
    this.panel.clear();
  }

  public Widget asWidget() {
    return panel.asWidget();
  }

  public Widget getWidget() {
    return panel.getWidget();
  }

  public void setWidget(Widget childWidget) {
    panel.add(childWidget);
  }

  public void setWidget(IsWidget childWidget) {
    panel.add(childWidget);
  }

}</programlisting>
<simpara>Then in your GWT module descriptor you need to override the default navigation panel ( <literal><phrase role="code">org.jboss.errai.ui.nav.client.local.NavigatingContainer</phrase></literal> ) by adding:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;replace-with class="com.company.application.client.NavigatingPanel"&gt;
  &lt;when-type-is class="org.jboss.errai.ui.nav.client.local.NavigatingContainer"/&gt;
&lt;/replace-with&gt;</programlisting>
</section>
<section id="sid-54493676_ErraiUINavigation-ViewingtheGeneratedNavigationGraph">
<title>Viewing the Generated Navigation Graph</title>
<simpara>Because the pages and links in an Errai Navigation application are declared structurally, the framework gets a complete picture of the app&#8217;s navigation structure at compile time. This knowledge is saved out during compilation (and at page reload when in Dev Mode) to the file <literal><phrase role="code">.errai/navgraph.gv</phrase></literal> . You can view the navigation graph using any tool that understands the GraphViz (also known as DOT) file format.</simpara>
<simpara>One popular open source tool that can display GraphViz/DOT files is <ulink url="http://www.graphviz.org/">GraphViz</ulink> . Free downloads are available for all major operating systems.</simpara>
<simpara>When rendered, a navigation graph looks like this:</simpara>
<figure>
<title>TODO InformalFigure image title empty</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="author/download/attachments/54493676/example_errai_nav_graph.png"/>
    </imageobject>
    <textobject><phrase>example_errai_nav_graph</phrase></textobject>
  </mediaobject>
</figure>
<simpara>In the rendered graph, the pages are nodes (text surrounded by an ellipse). The starting page is drawn with a heavier stroke. The links are drawn as arrows from one page to another. The labels on these arrows come from the Java field names the TransitionTo objects were injected into.</simpara>
</section>
</section>
</chapter>
<chapter id="sid-65274252">
<title>Errai Cordova (Mobile Support)</title>
<simpara>Starting with version 2.4.0, Errai now supports mobile development. One of the modules that makes this feasible is the Cordova module. It offers a way to integrate with native hardware in an Errai way.</simpara>
<section id="sid-65274252_ErraiCordova%28MobileSupport%29-Getstarted">
<title>Get started</title>
<simpara>Add the following to your application&#8217;s .gwt.xml module file:</simpara>
<section id="sid-65274252_ErraiCordova%28MobileSupport%29-App.gwt.xml">
<title>App.gwt.xml</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;inherits name="org.jboss.errai.ui.Cordova"/&gt;</programlisting>
</section>
</section>
<section id="sid-65274252_ErraiCordova%28MobileSupport%29-Integratewithnativehardware">
<title>Integrate with native hardware</title>
<simpara>When the Cordova module is included you can integrate with native hardware by injecting the native components into your code:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Templated("#main")
public class KitchenSinkClient extends Composite {
  @Inject
  Camera camera;

  @Inject
  @DataField
  Button takePicture;

  @EventHandler("takePicture")
  public void onTakePicktureClicked(ClickEvent event) {
    PictureOptions options = new PictureOptions(25);
    options.setDestinationType(PictureOptions.DESTINATION_TYPE_DATA_URL);
    options.setSourceType(PictureOptions.PICTURE_SOURCE_TYPE_CAMERA);

    camera.getPicture(options, new PictureCallback() {

      @Override
      public void onSuccess(String data) {
        image.setUrl(UriUtils.fromSafeConstant("data:image/jpeg;base64," + data));
      }

      @Override
      public void onFailure(String error) {
        setGeneralErrorMessage("Could not take picture: " + error);
      }
    });
  }</programlisting>
<simpara>The components that are supported come from the <ulink url="https://code.google.com/p/gwt-phonegap/">gwt-phonegap</ulink> project have a look there form more documentation.</simpara>
<simpara>Here are the native hardware components you can inject:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>Camera</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Accelerometer</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Contacts</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Capture (Provides access to the audio, image, and video capture capabilities of the device).</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Compass</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Notification ( <ulink url="http://docs.phonegap.com/en/edge/cordova_notification_notification.md.html#Notification">see documentation on phonegap site</ulink> )</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>File create a native file</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Device Get general information about the device.</simpara>
      
    </listitem>
  
</itemizedlist>

<simpara>So to integrate with these things all we have to do is <literal><phrase role="code">@Inject</phrase></literal> these classes. There are also a couple of CDI events one can observe to be informed about hardware state:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>BackButtonEvent</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>BatteryCriticalEvent</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>BatteryEvent</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>BatteryLowEvent</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>BatteryStatusEvent</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>EndCallButtonEvent</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>MenuButtonEvent</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>OffLineEvent</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>OnlineEvent</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>PauseEvent</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>ResumeEvent</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>SearchButtonEvent</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>StartCallButtonEvent</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>VolumeDownButtonEvent</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>VolumeUpButtonEvent</simpara>
      
    </listitem>
  
</itemizedlist>

<simpara>Example of how to use these events:</simpara>
<programlisting language="java" linenumbering="unnumbered">  private void batteryIsLow(@Observes BatteryLowEvent event) {
    //mission accomplished. we can stop the infinite loop now.
  }</programlisting>
</section>
<section id="sid-65274252_ErraiCordova%28MobileSupport%29-Mavenbuild">
<title>Maven build</title>
<simpara>All that is left to do is build this and put it on a actual device. In order to make this as easy as possible we have a maven plugin that will create a native binary that you can install on a device. It will put the html and javascript of you application in a <ulink url="http://cordova.apache.org/">cordova</ulink> application, because by doing so the client is no longer servered by the server the client will need to know how it can reach the server to do that place the following in your gwt.xml:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;replace-with class="com.company.application.Config"&gt;
   &lt;when-type-is class="org.jboss.errai.bus.client.framework.Configuration" /&gt;
&lt;/replace-with&gt;</programlisting>
<simpara>This class must implement org.jboss.errai.bus.client.framework.Configuration and return the url where the server is configured.</simpara>
<programlisting language="java" linenumbering="unnumbered">import org.jboss.errai.bus.client.framework.Configuration;

public class Config implements Configuration {
    @Override
    public String getRemoteLocation() {
        // you probably want to do something environment specify here instead of something like this:
        return "https://grocery-edewit.rhcloud.com/errai-jpa-demo-grocery-list";
    }
}</programlisting>
<simpara>Now all that is left is to add the plugin to the pom.xml like so:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;build&gt;
 ...
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.jboss.errai&lt;/groupId&gt;
        &lt;artifactId&gt;cordova-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;${errai.version}&lt;/version&gt;
      &lt;/plugin&gt;</programlisting>
<simpara>Now you can execute a native build with the following maven command:</simpara>
<programlisting language="ini" linenumbering="unnumbered">#will build all supported platforms for now only ios and android
mvn cordova:build-project

#only build android
mvn cordova:build-project -Dplatform=android

#start the ios emulator with the deployed application
mvn cordova:emulator -Dplatform=ios</programlisting>
<important>
<simpara>For these to work you&#8217;ll need to have the SDK&#8217;s installed and on your path! In case of android you will additionally have to have ANDROID_HOME environment variable set.</simpara>
</important>
</section>
<section id="sid-65274252_ErraiCordova%28MobileSupport%29-AeroGearWrappers">
<title>AeroGear Wrappers</title>
<simpara>These wrappers allow your Errai client to talk to an AeroGear server. Also have a look at the <ulink url="http://aerogear.org/docs">documentation</ulink> of the AeroGear project.</simpara>
<section id="sid-65274252_ErraiCordova%28MobileSupport%29-Pipes">
<title>Pipes</title>
<simpara>Pipes are for getting data from the server. Right now the only implementation is REST it will use Id to construct urls.</simpara>
<programlisting language="java" linenumbering="unnumbered">  Pipe&lt;Task&gt; pipe = new PipeFactory().createPipe(Task.class, "tasks");

  pipe.save(new Task(123, "new", "2012-01-01"), new AsyncCallback&lt;Task&gt;() {
    @Override
    public void onSuccess(Task result) {
      Window.alert("jipee saved a taks");
    }
    @Override
    public void onFailure(Throwable caught) {
    }
  });</programlisting>
<simpara>This will preform a PUT /tasks URL</simpara>
</section>
<section id="sid-65274252_ErraiCordova%28MobileSupport%29-Stores">
<title>Stores</title>
<simpara>Another concept that comes with AeroGear is Stores. Currently there are 2 Store types supported: Memory and SessionLocal. Memory is just a big javascript array to hold your data. Here is how you create and configure a Store:</simpara>
<programlisting language="java" linenumbering="unnumbered">    Store&lt;User&gt; store = new DataManager().store(User.class);

    store.save(new User(2, "test2"));
    Collection&lt;User&gt; collection = store.readAll();

    User user = store.read(2);</programlisting>
</section>
<section id="sid-65274252_ErraiCordova%28MobileSupport%29-Authentication">
<title>Authentication</title>
<simpara>Pipes can be authenticated by just adding the authenticator into the Pipe and you are good to go.</simpara>
<programlisting language="java" linenumbering="unnumbered">    Authenticator authenticator = new AuthenticationFactory().createAuthenticator("name");
    Pipe&lt;Task&gt; pipe = new PipeFactory().createPipe(Task.class, "tasks", authenticator);

    authenticator.login(username.getText(), password.getText(), new AsyncCallback&lt;String&gt;() {
      @Override
      public void onSuccess(String result) {
        Window.alert("successful login");
      }

      @Override
      public void onFailure(Throwable caught) {
        message.setText("Login failed, please try again");
      }
    });</programlisting>
<simpara>There is also a method called <literal><phrase role="code">enroll()</phrase></literal> for adding new users.</simpara>
</section>
</section>
</chapter>
<chapter id="sid-74908675">
<title>Logging</title>
<simpara>Errai now supports using the <ulink url="http://www.slf4j.org/">slf4j</ulink> logging api on the server and client. This gives you the flexibility of choosing your own logging back-end for your server-side code, while still allowing a uniform logging interface that can be used in shared packages.</simpara>
<section id="sid-74908675_Logging-Whatisslf4j%3F">
<title>What is slf4j?</title>
<simpara>sl4j is logging abstraction. Using the slf4j api, you can add log statements to your code using a fixed api while maintaining the ability to switch the logging implementation at run-time. For example, the slf4j api can be used with java.util.logging (JUL) as the back-end.</simpara>
</section>
<section id="sid-74908675_Logging-ClientSideSetup">
<title>Client-Side Setup</title>
<simpara>The client-side slf4j code uses the  <ulink url="http://www.gwtproject.org/doc/latest/DevGuideLogging.html">GWT Logging</ulink> as the back-end. Using slf4j in client-side code has two steps:</simpara>
<orderedlist numeration="arabic">
  
    <listitem>
      <simpara>Add the errai-common artifact as a maven dependency to your project</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Inherit the gwt module <literal><phrase role="code">org.jboss.errai.common.ErraiCommon</phrase></literal></simpara>
      
    </listitem>
  
</orderedlist>
<section id="sid-74908675_Logging-ErraiClientSideLogHandlers">
<title>Errai Client-Side Log Handlers</title>
<simpara>In the ErraiCommon module, we have disabled the built-in GWT log handlers and provided four handlers of our own:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara><emphasis>ErraiSystemLogHandler</emphasis> : prints log statements to the terminal in Development Mode</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>ErraiConsoleLogHandler</emphasis> : prints statements to the web console in the browser</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>ErraiDevelopmentModeLogHandler</emphasis> : prints statements in the Development Mode window</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>ErraiFirebugLogHandler</emphasis> : prints statements to the console in Firefox These loggers are all enabled by default and set to handle all log levels.</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
<section id="sid-74908675_Logging-ConfiguringErraiClientSideLogHandlers">
<title>Configuring Errai Client-Side Log Handlers</title>
<simpara>Log handler levels can be changed at run-time through Java or Javascript. To do so through Java, use the <literal><phrase role="code">LoggingHandlerConfigurator</phrase></literal> in Errai Common. Here&#8217;s an example:</simpara>
<example>
<title>HandlerLevelAdjuster.java</title>
<programlisting language="java" linenumbering="unnumbered">import org.jboss.errai.common.client.logging.LoggingHandlerConfigurator;
import org.jboss.errai.common.client.logging.handlers.ErraiSystemLogHandler;
import java.util.logging.Level;

public class HandlerLevelAdjuster {

  public static void logAll() {
    LoggingHandlerConfigurator config = LoggingHandlerConfigurator.get();
    ErraiSystemLogHandler handler = config.getHandler(ErraiSystemLogHandler.class);
    handler.setLevel(Level.ALL);
  }

  public static void disableLogging() {
    LoggingHandlerConfigurator config = LoggingHandlerConfigurator.get();
    ErraiSystemLogHandler handler = config.getHandler(ErraiSystemLogHandler.class);
    handler.setLevel(Level.OFF);
  }

}</programlisting>
</example>
<simpara>Each handler has a native Javascript variable associated with its log level:</simpara>
<informaltable frame="all"
    rowsep="1" colsep="1">
  
  <tgroup cols="2">
    
    <colspec colname="col_1" colwidth="50*"/>
    
    <colspec colname="col_2" colwidth="50*"/>
    
    
    <thead>
      
      <row>
        
        <entry align="left" valign="top">Handler</entry>
        
        <entry align="left" valign="top">Variable Name</entry>
        
      </row>
      
    </thead>
    
    <tbody>
      
      <row>
        
        <entry align="left" valign="top"><simpara>ErraiSystemLogHandler</simpara></entry>
        
        <entry align="left" valign="top"><simpara>erraiSystemLogHandlerLevel</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara>ErraiConsoleLogHandler</simpara></entry>
        
        <entry align="left" valign="top"><simpara>erraiConsoleLogHandlerLevel</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara>ErraiDevelopmentModeLogHandler</simpara></entry>
        
        <entry align="left" valign="top"><simpara>erraiDevelopmentModeLogHandlerLevel</simpara></entry>
        
      </row>
      
      <row>
        
        <entry align="left" valign="top"><simpara>ErraiFirebugLogHandler</simpara></entry>
        
        <entry align="left" valign="top"><simpara>erraiFirebugLogHandlerLevel</simpara></entry>
        
      </row>
      
    </tbody>
    
  </tgroup>
</informaltable>
<simpara>Since these are native Javascript variables, they can easily be set in a script tag on your host page:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;script type="text/javascript"&gt;
  erraiSystemLoghandlerLevel = "INFO";
&lt;/script&gt;</programlisting>
<simpara>The possible log levels correspond to those in <literal><phrase role="code">java.util.logging.Level</phrase></literal> .</simpara>
</section>
<section id="sid-74908675_Logging-FormatString">
<title>Format String</title>
<simpara>The Errai log handlers use <literal><phrase role="code">ErraiSimpleFormatter</phrase></literal> to format log output. The format string is similar to that used in by <literal><phrase role="code">java.util.SimpleFormatter</phrase></literal> (for precise differences please see the javadocs for <literal><phrase role="code">ErraiSimpleFormatter</phrase></literal> and <literal><phrase role="code">StringFormat</phrase></literal> ).</simpara>
<simpara>As with handler settings, these can be configured in Java or Javascript. To do so in Java, use <literal><phrase role="code">ErraiSimpleFormmater.setSimpleFormatString(String)</phrase></literal> . In Javascript, just set the variable <literal><phrase role="code">erraiSimpleFormatString</phrase></literal> to the desired value.</simpara>
</section>
</section>
<section id="sid-74908675_Logging-ServerSideSetup">
<title>Server-Side Setup</title>
<simpara>On the server you are free to use any logging back-end that has slf4j bindings (or to make your own). Just make sure to add dependencies for the slf4j-api artifact and the slf4j binding you choose. <emphasis>Note:</emphasis> Some application servers provide their own slf4j bindings (such as JBoss AS), in which case you should add your binding dependency as provided scope.</simpara>
<simpara>To learn more about how to setup slf4j for your server-side code, see <ulink url="http://www.slf4j.org/">their website</ulink> .</simpara>
</section>
<section id="sid-74908675_Logging-ExampleUsage">
<title>Example Usage</title>
<simpara>Here is sample usage of the slf4j code (which with the above setup can be run on the client or server):</simpara>
<example>
<title>LogExample.java</title>
<programlisting language="java" linenumbering="unnumbered">import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import javax.inject.Inject;

public class LogExample {

  public void logStuff() {
    // Get a logger for this class
    @Inject Logger logger;

    // Logging going from most to least detailed
    logger.trace("this is extremely specific!");
    logger.debug("this is still pretty specific");
    logger.info("this is an average log message");
    logger.warn("there might be something fishy here...");
    logger.error("uh oh... abandon ship!", new Exception("I am a logged exception"));
  }
}</programlisting>
</example>
</section>
<section id="sid-74908675_Logging-LoggerNames">
<title>Logger Names</title>
<simpara>By default, the above example with provide a logger with the fully qualified class name of the enclosing class. To inject a logger with an alternate name, use the <literal><phrase role="code">NamedLogger</phrase></literal> annotation:</simpara>
<example>
<title>NamedLogExample.java</title>
<programlisting language="java" linenumbering="unnumbered">import org.slf4j.Logger;
import javax.inject.Inject;
import org.jboss.errai.common.client.api.NamedLogger;

public class NamedLogExample {

  // Get a logger with the name "Logger!"
  @Inject @NamedLogger("Logger!") logger;

  // Get the root logger
  @Inject @NamedLogger rootLogger;

}</programlisting>
</example>
</section>
</chapter>
<chapter id="sid-5931334">
<title>Configuration</title>
<simpara>This section contains information on configuring Errai.</simpara>
<section id="sid-5931354">
<title>ErraiApp.properties</title>
<simpara>ErraiApp.properties acts both as a marker file for JARs that contain Errai-enabled GWT modules, and as a place to put configuration settings for those modules in the rare case that non-default configuration is necessary.</simpara>
<section id="sid-5931354_ErraiApp.properties-AsaMarkerFile">
<title>As a Marker File</title>
<simpara><emphasis>An</emphasis> <literal><phrase role="code">ErraiApp.properties</phrase></literal><emphasis>file must appear at the root of each classpath location that contains an Errai module.</emphasis> The contents of JAR and directory classpath entries that do not contain an <literal><phrase role="code">ErraiApp.properties</phrase></literal> are effectively invisible to Errai&#8217;s classpath scanner.</simpara>
</section>
<section id="sid-5931354_ErraiApp.properties-AsaConfigurationFile">
<title>As a Configuration File</title>
<simpara>ErraiApp.properties is usually left empty, but it can contain configuration settings for both the core of Errai and any of its extensions. Configuration properties defined and used by Errai components have keys that start with " <literal><phrase role="code">errai.</phrase></literal> ". Third party extensions should each choose their own prefix for keys in ErraiApp.properties.</simpara>
<section id="sid-5931354_ErraiApp.properties-ConfigurationMerging">
<title>Configuration Merging</title>
<simpara>In a non-trivial application, there will be several instances of ErraiApp.properties on the classpath (one per JAR file that contains Errai modules, beans, or portable classes).</simpara>
<simpara>Before using the configuration information from ErraiApp.properties, Errai reads the contents of every ErraiApp.properties on the classpath. The configuration information in all these files is merged together to form one set of key=value pairs.</simpara>
<simpara>If the same key appears in more than one ErraiApp.properties file, only one of the values will be associated with that key. The other values will be ignored. In future versions of Errai, this condition may be made into an error. It&#8217;s best to avoid specifying the same configuration key in multiple ErraiApp.properties files.</simpara>
</section>
<section id="sid-5931354_ErraiApp.properties-ErraiMarshallingConfiguration">
<title>Errai Marshalling Configuration</title>

<itemizedlist>
  
    <listitem>
      <simpara><emphasis>errai.marshalling.use_static_marshallers</emphasis> when set to <literal><phrase role="code">false</phrase></literal> , Errai will not use the precompiled server-side marshallers even if the generated <literal><phrase role="code">ServerMarshallingFactoryImpl</phrase></literal> class is found on the classpath. This is useful when using Dev Mode in conjunction with an external server such as JBoss AS 7 or EAP 6.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>errai.marshalling.force_static_marshallers</emphasis> when set to <literal><phrase role="code">true</phrase></literal> , Errai will not use dynamic marshallers. If the generated <literal><phrase role="code">ServerMarshallingFactoryImpl</phrase></literal> cannot be loaded (possibly after an attempt to generate it on-the-fly), the Errai web app will fail to start.</simpara>
      
    </listitem>
  
</itemizedlist>

<simpara>Errai also supports configuring portable types in <literal><phrase role="code">ErraiApp.properties</phrase></literal> as an alternative to the <literal><phrase role="code">@Portable</phrase></literal> annotation. See <link linkend="sid-5931328_Marshalling-ManualMapping">the Errai Marshalling section on Manual Mapping</link> for details.</simpara>
</section>
<section id="sid-5931354_ErraiApp.properties-ErraiIoCConfiguration">
<title>Errai IoC Configuration</title>

<itemizedlist>
  
    <listitem>
      <simpara><emphasis>errai.ioc.QualifyingMetaDataFactory</emphasis> specifies the fully-qualified class name of the QualifyingMetadataFactory implementation to use with Errai IoC.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>errai.ioc.enabled.alternatives</emphasis> specifies a whitespace-separated list of fully-qualified class names for <emphasis>alternative beans</emphasis> . See <link linkend="sid-22872133">Alternatives and Mocks</link> for details.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>errai.ioc.blacklist</emphasis> specifies a whitespace-separated list of classes that should be hidden from Errai IOC and that will be excluded when generating the bean graph and wiring components. Wildcards are supported to exclude all types underneath a package e.g. org.jboss.myapp.exclude.* (all types under the exclude package will be hidden from ERRAI IOC).</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>errai.ioc.whitelist</emphasis> when this property is present all types in your application are hidden from Errai IOC by default. It specifies a whitespace-separated list of classes that should be visible to IOC and that will be included when generating the bean graph and wiring components. Wildcards are supported to include all types underneath a package e.g. org.jboss.myapp.include.* (all types under the include package will be visible to ERRAI IOC).</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
</section>
</section>
<section id="sid-5931338">
<title>Messaging (Errai Bus) Configuration</title>
<section id="sid-5931338_Messaging%28ErraiBus%29Configuration-Disablingremotecommunication">
<title>Disabling remote communication</title>
<simpara>In some cases it might be desirable to prevent the client bus from communicating with the server. One use case for this is when all communication with the server is handled using JAX-RS and the constant long polling requests for message exchange are not needed.</simpara>
<simpara>To turn off remote communication in the client bus the following JavaScript variable can be set in the HTML host page:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;script type="text/javascript"&gt;
  erraiBusRemoteCommunicationEnabled = false;
&lt;/script&gt;</programlisting>
</section>
<section id="sid-5931338_Messaging%28ErraiBus%29Configuration-Configuringanalternativeremoteremotebusendpoint">
<title>Configuring an alternative remote remote bus endpoint</title>
<simpara>By default the remote bus is expected at the GWT web application&#8217;s context path. In case the remote bus is part of a different web application or deployed on a different server, the following configuration can be used in the HTML host page to configure the remote bus endpoint used on the client.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;script type="text/javascript"&gt;
  erraiBusApplicationRoot = "/MyRemoteMessageBusEnpoint";
&lt;/script&gt;</programlisting>
</section>
<section id="sid-5931338_Messaging%28ErraiBus%29Configuration-ErraiService.properties">
<title>ErraiService.properties</title>
<simpara>The ErraiService.properties file contains basic configuration for the bus itself. Unlike ErraiApp.properties, there should be at most one ErraiService.properties file on the classpath of a deployed application. If you do not need to set any properties to their non-default values, this file can be omitted from the deployment entirely.</simpara>
<section id="sid-5931338_Messaging%28ErraiBus%29Configuration-MessageDispatching">
<title>Message Dispatching</title>
<simpara>Dispatchers encapsulate the strategy for taking messages that need to be delivered somewhere and seeing that they are delivered to where they need to go. There are two primary implementations that are provided with Errai, depending on your needs.</simpara>
<simpara id="sid-5931338_Messaging%28ErraiBus%29Configuration-SimpleDispatcher">SimpleDispatcher:</simpara>
<simpara>SimpleDispatcher is basic implementation that provides no asychronous delivery mechanism. Rather, when you configure the Errai to use this implementation, messages are delivered to their endpoints synchronously. The incoming HTTP thread will be held open until the messages are delivered.</simpara>
<simpara>While this sounds like it has almost no advantages, especially in terms of scalablity. Using the SimpleDispatcher can be far preferable when you&#8217;re developing your application, as any errors and stack traces will be far more easily traced and some cloud services may not permit the use of threads in any case.</simpara>
<simpara id="sid-5931338_Messaging%28ErraiBus%29Configuration-AsyncDispatcher">AsyncDispatcher:</simpara>
<simpara>The AsyncDispatcher provides full asynchronous delivery of messages. When this dispatcher is used, HTTP threads will have control immediately returned upon dispatch of the message. This dispatcher provides far more efficient use of resources in high-load applications, and will significantly decrease memory and thread usage overall.</simpara>

<itemizedlist>
  
    <listitem>
      <simpara><emphasis>errai.dispatcher.implementation</emphasis> specifies the dispatcher implementation to be used by the bus. There are two implementations which come with Errai out of the box: the <literal><phrase role="code">SimpleDispatcher</phrase></literal> and the <literal><phrase role="code">AsyncDispatcher</phrase></literal> . See ERRAI:Dispatcher Implementations for more information about the differences between the two.</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
<section id="sid-5931338_Messaging%28ErraiBus%29Configuration-Threading">
<title>Threading</title>

<itemizedlist>
  
    <listitem>
      <simpara><emphasis>errai.async_thread_pool_size</emphasis> specifies the total number of worker threads in the worker pool for handling and delivering messages. Adjusting this value does not have any effect if you are using the SimpleDispatcher.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>errai.async.worker_timeout</emphasis> specifies the total amount of time (in seconds) that a service is given to finish processing an incoming message before the pool interrupts the thread and returns an error. Adjusting this value has no effect if you are using the SimpleDispatcher.</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
<section id="sid-5931338_Messaging%28ErraiBus%29Configuration-Buffering">
<title>Buffering</title>

<itemizedlist>
  
    <listitem>
      <simpara><emphasis>errai.bus.buffer_size</emphasis> The total size of the transmission buffer, in megabytes. If this attribute is specified along with <literal><phrase role="code">errai.bus.buffer_segment_count</phrase></literal> , then the segment count is inferred by the calculation <literal><phrase role="code">buffer_segment_count / buffer_size}. If {{errai.bus.buffer_segment_count</phrase></literal> is also defined, it will be ignored in the presence of this property. Default value: 32.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>errai.bus.buffer_segment_size</emphasis> The transmission buffer segment size in bytes. This is the minimum amount of memory each message will consume while stored within the buffer. Defualt value: 8.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>errai.bus.buffer_segment_count</emphasis> The number of segments in absolute terms. If this attribute is specified in the absence of <literal><phrase role="code">errai.bus.buffer_size</phrase></literal> , the buffer size is inferred by the calculation <literal><phrase role="code">buffer_segment_size / buffer_segment_count</phrase></literal> .</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>errai.bus.buffer_allocation_mode</emphasis> Buffer allocation mode. Allowed values are <literal><phrase role="code">direct</phrase></literal> and <literal><phrase role="code">heap</phrase></literal> . Direct allocation puts buffer memory outside of the JVM heap, while heap allocation uses buffer memory inside the Java heap. For most situations, heap allocation is preferable. However, if the application is data intensive and requires a substantially large buffer, it is preferable to use a direct buffer. From a throughput perspective, current JVM implementations pay about a 20% performance penalty for direct-allocated memory access. However, your application may show better scaling characteristics with direct buffers. Benchmarking under real load conditions is the only way to know the optimal setting for your use case and expected load. Default value: <literal><phrase role="code">direct</phrase></literal> .</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
<section id="sid-5931338_Messaging%28ErraiBus%29Configuration-Security">
<title>Security</title>

<itemizedlist>
  
    <listitem>
      <simpara><emphasis>errai.authentication_adapter</emphasis> specifies the authentication modelAdapter the bus should use for determining whether calls should be serviced based on authentication and security principals.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>errai.require_authentication_for_all</emphasis> indicates whether or not the bus should always require the use of authentication for all requests inbound for the bus. If this is turned on, an authentication model adapter must be defined, and any user must be authenticated before the bus will deliver any messages from the client to any service.</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
<section id="sid-5931338_Messaging%28ErraiBus%29Configuration-Clustering">
<title>Clustering</title>

<itemizedlist>
  
    <listitem>
      <simpara><emphasis>errai.bus.enable_clustering</emphasis> A boolean indicating whether or not Errai&#8217;s server side bus should attempt to orchestrate with its peers. The orchestration mechanism is dependent on the configured clustering provider (e.g. UDP based multicast discovery in case of the default JGroups provider). The default value is <literal><phrase role="code">false</phrase></literal> .</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>errai.bus.clustering_provider</emphasis> The fully qualified class name of the clustering provider implementation. A class that implements <literal><phrase role="code">org.jboss.errai.bus.server.cluster.ClusteringProvider</phrase></literal> . Currently the only build-in provider is the <literal><phrase role="code">org.jboss.errai.bus.server.cluster.jgroups.JGroupsClusteringProvider</phrase></literal> .</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
<section id="sid-5931338_Messaging%28ErraiBus%29Configuration-StartupConfiguration">
<title>Startup Configuration</title>

<itemizedlist>
  
    <listitem>
      <simpara><emphasis>errai.auto_discover_services</emphasis> A boolean indicating whether or not the Errai bootstrapper should automatically scan for services. <emphasis>This property must be set to true if and only if Errai CDI is not on the classpath</emphasis> . The default value is <literal><phrase role="code">false</phrase></literal> .</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><emphasis>errai.auto_load_extensions</emphasis> A boolean indicating whether or not the Errai bootstrapper should automatically scan for extensions. The default value is <literal><phrase role="code">true</phrase></literal> .</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
<section id="sid-5931338_Messaging%28ErraiBus%29Configuration-ExampleConfiguration">
<title>Example Configuration</title>
<programlisting language="ini" linenumbering="unnumbered">##
## Request dispatcher implementation (default is SimpleDispatcher)
##
#errai.dispatcher_implementation=org.jboss.errai.bus.server.SimpleDispatcher
errai.dispatcher_implementation=org.jboss.errai.bus.server.AsyncDispatcher

#
## Worker pool size. This is the number of threads the asynchronous worker pool should provide for
processing
## incoming messages. This option is only valid when using the AsyncDispatcher implementation.
##
errai.async.thread_pool_size=5

##
## Worker timeout (in seconds). This defines the time that a single asychronous process may run,
before the worker pool
## terminates it and reclaims the thread. This option is only valid when using the AsyncDispatcher
implementation.
##
errai.async.worker.timeout=5

##
## Specify the Authentication/Authorization Adapter to use
##
#errai.authentication_adapter=org.jboss.errai.persistence.server.security.HibernateAuthenticationAdapter
#errai.authentication_adapter=org.jboss.errai.bus.server.security.auth.JAASAdapter

##
## This property indicates whether or not authentication is required for all communication with the
bus. Set this
## to 'true' if all access to your application should be secure.
##
#errai.require_authentication_for_all=true</programlisting>
</section>
</section>
<section id="sid-5931338_Messaging%28ErraiBus%29Configuration-ServletConfiguration">
<title>Servlet Configuration</title>
<simpara>Errai has several different implementations for HTTP traffic to and from the bus. We provide a universally-compatible blocking implementation that provides fully synchronous communication to/from the server-side bus. Where this introduces scalability problems, we have implemented many webserver-specific implementations that take advantage of the various proprietary APIs to provide true asynchrony.</simpara>
<simpara>These included implementations are packaged at: <literal><phrase role="code">org.jboss.errai.bus.server.servlet</phrase></literal> .</simpara>
<important>
<title>One is Enough!</title>
<simpara>You should use just one of the options below. Configuring multiple ErraiServlet implementations in the same application will lead to unpredictable behaviour!</simpara>
<simpara>Remember that all Errai demos and archetypes are preconfigured with DefaultBlockingServlet as a servlet. You will need to remove this default setup if you choose to use a different ErraiServlet implementation in your app.</simpara>
</important>
<note>
<title>Rolling your own security? Beware!</title>
<simpara>All of the following examples use a wildcard mapping for <literal><phrase role="code">\*.erraiBus</phrase></literal> with no path prefix. This allows Errai Bus to communicate from any point in your application&#8217;s URI hierarchy, which allows bus communication to work properly no matter where you choose to put your GWT host page.</simpara>
<simpara>For example, all of the following are equivalent from Errai&#8217;s point of view:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>/in.erraiBus</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>/foo/bar/in.erraiBus</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>/long/path/to/get/to.erraiBus</simpara>
      
    </listitem>
  
</itemizedlist>

<simpara>If you rely on your own security rules or a custom security filter to control access to Errai Bus (rather than the security framework within Errai Bus,) ensure you use the same mapping pattern for that <literal><phrase role="code">filter-mapping</phrase></literal> or <literal><phrase role="code">security-constraint</phrase></literal> as you do for the Errai Servlet itself.</simpara>
</note>
<section id="sid-5931338_Messaging%28ErraiBus%29Configuration-DefaultBlockingServlet">
<title>DefaultBlockingServlet</title>
<simpara>This ErraiServlet implementation should work in virtually any servlet container that supports Java Servlets 2.0 or higher. It provides purely synchronous request handling. The one scenario where this servlet will not work is in servers that put restrictions on putting threads into sleep states.</simpara>
<simpara>The default DefaultBlockingServlet which provides the HTTP-protocol gateway between the server bus and the client buses.</simpara>
<simpara>As its name suggests, DefaultBlockingServlet is normally configured as an HTTP Servlet in the <literal><phrase role="code">web.xml</phrase></literal> file:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;servlet&gt;
  &lt;servlet-name&gt;ErraiServlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;org.jboss.errai.bus.server.servlet.DefaultBlockingServlet&lt;/servlet-class&gt;
  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;ErraiServlet&lt;/servlet-name&gt;
  &lt;url-pattern&gt;*.erraiBus&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</programlisting>
</section>
<section id="sid-5931338_Messaging%28ErraiBus%29Configuration-DefaultBlockingServletconfiguredasFilter">
<title>DefaultBlockingServlet configured as Filter</title>
<simpara>Alternatively, the DefaultBlockingServlet can be deployed as a Servlet Filter. This may be necessary in cases where an existing filter is configured in the web application, and that filter interferes with the Errai Bus requests. In this case, configuring DefaultBlockingServlet to handle <literal><phrase role="code">\*.erraiBus</phrase></literal> requests ahead of other filters in web.xml will solve the problem:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;filter&gt;
  &lt;filter-name&gt;ErraiServlet&lt;/filter-name&gt;
  &lt;filter-class&gt;org.jboss.errai.bus.server.servlet.DefaultBlockingServlet&lt;/filter-class&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
  &lt;filter-name&gt;ErraiServlet&lt;/filter-name&gt;
  &lt;url-pattern&gt;*.erraiBus&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</programlisting>
</section>
<section id="sid-5931338_Messaging%28ErraiBus%29Configuration-JettyContinuationsServlet">
<title>JettyContinuationsServlet</title>
<simpara>The Jetty implementation leverages Jetty&#8217;s continuations support, which allows for threadless pausing of port connections. This servlet implementation should work without any special configuration of Jetty.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;servlet&gt;
  &lt;servlet-name&gt;ErraiServlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;org.jboss.errai.bus.server.servlet.JettyContinuationsServlet&lt;/servlet-class&gt;
  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;ErraiServlet&lt;/servlet-name&gt;
  &lt;url-pattern&gt;*.erraiBus&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</programlisting>
</section>
<section id="sid-5931338_Messaging%28ErraiBus%29Configuration-StandardAsyncServlet">
<title>StandardAsyncServlet</title>
<simpara>This implementation leverages asynchronous support in Servlet 3.0 to allow for threadless pausing of port connections. Note that <literal><phrase role="code">&lt;async-supported&gt;true&lt;/async-supported&gt;</phrase></literal> has to be added to the servlet definition in <literal><phrase role="code">web.xml</phrase></literal> .</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;servlet&gt;
  &lt;servlet-name&gt;ErraiServlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;org.jboss.errai.bus.server.servlet.StandardAsyncServlet&lt;/servlet-class&gt;
  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;async-supported&gt;true&lt;/async-supported&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;ErraiServlet&lt;/servlet-name&gt;
  &lt;url-pattern&gt;*.erraiBus&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</programlisting>
</section>
</section>
</section>
</chapter>
<chapter id="sid-32473113">
<title>Troubleshooting &amp; FAQ</title>
<simpara>This section explains the cause of and solution to some common problems that people encounter when building applications with Errai.</simpara>
<simpara>Of course, when lots of people trip over the same problem, it&#8217;s probably because there is a deficiency in the framework! A FAQ list like this is just a band-aid solution. If you have suggestions for permanent fixes to these problems, please get in touch with us: file an issue in our issue tracker, chat with us on IRC, or post a suggestion on our forum.</simpara>
<simpara>But for now, on to the FAQ:</simpara>
<section id="sid-32473113_Troubleshooting%26FAQ-WhydoesitseemthatErraican%27tseemyclassatcompiletime%3F">
<title>Why does it seem that Errai can&#8217;t see my class at compile time?</title>
<simpara>Possible symptoms:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>uncaught exception: java.lang.RuntimeException: No proxy provider found for type: <emphasis>my.fully.qualified.ServiceName</emphasis></simpara>
      
    </listitem>
  
</itemizedlist>

<simpara><emphasis>Answer:</emphasis> Make sure the <xref linkend="sid-5931354"/> file is actually making it into your runtime classpath.</simpara>
<simpara>One common cause of this problem is a &lt;resources&gt; section in pom.xml that includes src/main/java (to expose .java sources to the GWT compiler) that does not also include src/main/resources as a resource path. You must include both explicitly:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;resources&gt;
  &lt;resource&gt;
    &lt;directory&gt;src/main/java&lt;/directory&gt;
  &lt;/resource&gt;
  &lt;resource&gt;
    &lt;directory&gt;src/main/resources&lt;/directory&gt;
  &lt;/resource&gt;
&lt;/resources&gt;</programlisting>
</section>
<section id="sid-32473113_Troubleshooting%26FAQ-WhyamIgetting%22java.lang.ClassFormatError%3AIllegalmethodname%22%3Cinit%3E%24%22inclassorg%2Fxyz%2Fpackage%2FMyClass%22%3F">
<title>Why am I getting "java.lang.ClassFormatError: Illegal method name "&lt;init&gt;$" in class org/xyz/package/MyClass"?</title>
<simpara><emphasis>Answer:</emphasis> This error message means that your project has a (direct or indirect) subclass of JavaScriptObject that lacks a protected no-args constructor. All subtypes of JavaScriptObject (also known as <emphasis>overlay types</emphasis> ) must declare a protected no-args constructor, but the error message could be much clearer. There is an issue filed in the GWT project&#8217;s bug tracker for improving the error message: <ulink url="http://code.google.com/p/google-web-toolkit/issues/detail?id=3383">GWT issue 3383</ulink> .</simpara>
</section>
<section id="sid-32473113_Troubleshooting%26FAQ-I%27mgetting%22java.lang.RuntimeException%3ATherearenoproxyprovidersregisteredyet.%22inmy@PostConstructmethod%21">
<title>I&#8217;m getting "java.lang.RuntimeException: There are no proxy providers registered yet." in my @PostConstruct method!</title>
<simpara><emphasis>Answer:</emphasis> You can&#8217;t invoke RPC methods via <literal><phrase role="code">Caller&lt;?&gt;</phrase></literal> or by other means until after the Errai Bus has finished its initial handshake. Try changing your <literal><phrase role="code">@PostConstruct</phrase></literal> annotation to <literal><phrase role="code">@AfterInitialization</phrase></literal> . This will cause your method to be invoked laterafter the bus handshake has completed.</simpara>
<simpara>If this doesn&#8217;t help, it is also possible that the proxies were never generated in the first place. Check in <literal><phrase role="code">.errai/RpcProxyLoaderImpl.java</phrase></literal> to see if proxy code exists for the <literal><phrase role="code">@Remote</phrase></literal> and/or <literal><phrase role="code">@Path</phrase></literal> interface in question. If not, your <literal><phrase role="code">@Remote</phrase></literal> interfaces were not present on the GWT compiler&#8217;s classpath when your application module was compiled. Double-check your GWT compilation classpath: all <literal><phrase role="code">@Remote</phrase></literal> interfaces must be visible to (in or inherited by) the GWT module that contains the <literal><phrase role="code">Caller&lt;?&gt;</phrase></literal> types. Pay special attention that your <literal><phrase role="code">@Remote</phrase></literal> and <literal><phrase role="code">@Path</phrase></literal> interfaces are not in a package excluded from the GWT module (by default, every subpackage other than <literal><phrase role="code">client</phrase></literal> and <literal><phrase role="code">shared</phrase></literal> is invisible to the GWT compiler).</simpara>
</section>
</chapter>
<chapter id="sid-21758202">
<title>Upgrade Guide</title>
<simpara>This chapter contains important information for migrating to newer versions of Errai. If you experience any problems, don&#8217;t hesitate to get in touch with us. See <link linkend="sid-5833089">Reporting problems</link> .</simpara>
<section id="sid-21758204">
<title>Upgrading from 1.* to 2.0</title>
<simpara>The first issues that will arise after replacing the jars or after changing the version numbers in the <literal><phrase role="code">pom.xml</phrase></literal> are unresolved package imports. This is due to refactorings that became necessary when the project grew. Most of these import problems can be resolved automatically by modern IDEs (Organize Imports). So, this should replace <literal><phrase role="code">org.jboss.errai.bus.client.protocols.*</phrase></literal> with <literal><phrase role="code">org.jboss.errai.common.client.protocols.\*</phrase></literal> for example.</simpara>
<simpara>The following is a list of manual steps that have to be carried out when upgrading:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>@ExposedEntity became @Portable ( <literal><phrase role="code">org.jboss.errai.common.client.api.annotations.Portable</phrase></literal> ). See <xref linkend="sid-5931328"/> for details.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The @Conversational annotation must now target the event objects themselves, not the observer methods of the events. So an <emphasis>event type</emphasis> is either conversational or not; you no longer specify that listeners receive arbitrary events in a conversational context. See the <link linkend="sid-21758054_Events-Conversationalevents">Conversational Events</link> section of the CDI chapter for details.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Errai CDI projects must now use the <literal><phrase role="code">SimpleDispatcher</phrase></literal> instead of the <literal><phrase role="code">AsynDispatcher</phrase></literal> . This has to be configured in <xref linkend="sid-5931338"/> .</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The bootstrap listener (configured in <literal><phrase role="code">WEB-INF/web.xml</phrase></literal> ) for Errai CDI has changed ( <literal><phrase role="code">org.jboss.errai.container.DevModeCDIBootstrap</phrase></literal> is now <literal><phrase role="code">org.jboss.errai.container.CDIServletStateListener</phrase></literal> ).</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>gwt 2.3.0 or newer must be used and replace older versions.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>mvel2 2.1.Beta8 or newer must be used and replace older versions.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>weld 1.1.5.Final or newer must be used and replace older versions.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>slf4j 1.6.1 or newer must be used and replace older versions.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>This step can be skipped if Maven is used to build the project. If the project is NOT built using Maven, the following jar files have to be added manually to project&#8217;s build/class path: errai-common-2.x.jar, errai-marshalling-2.x.jar, errai-codegen-2.x.jar, netty-4.0.0.Alpha1.errai.r1.jar.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>If the project was built using an early version of an Errai archetype the configuration of the maven-gwt-plugin has to be modified to contain the <literal><phrase role="code">&lt;hostedWebapp&gt;path-to-your-standard-webapp-folder&lt;/hostedWebapp&gt;</phrase></literal> . This is usually either <literal><phrase role="code">war</phrase></literal> or <literal><phrase role="code">src/main/webapp</phrase></literal> .</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
<section id="sid-24838246">
<title>Upgrading from 2.0.Beta to 2.0.*.Final</title>
<simpara>The following is a list of manual steps that have to be carried out when upgrading from a 2.0.Beta version to 2.0.CR1 or 2.0.Final:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>Starting with 2.0.CR1 the default for automatic service discovery has been changed in favour of CDI based applications. That means it has to be explicitly turned on for plain bus applications (Errai applications that do not use Errai-CDI). Not doing so will result in <literal><phrase role="code">NoSubscribersToDeliverTo</phrase></literal> exceptions. The snippet below shows how to activate automatic service discovery:
.web.xml</simpara>
      
    </listitem>
  
</itemizedlist>

<informalexample>
<programlisting language="xml" linenumbering="unnumbered">&lt;servlet&gt;
  &lt;servlet-name&gt;ErraiServlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;org.jboss.errai.bus.server.servlet.DefaultBlockingServlet&lt;/servlet-class&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;auto-discover-services&lt;/param-name&gt;
    &lt;param-value&gt;true&lt;/param-value&gt;
  &lt;/init-param&gt;
  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;</programlisting>
</informalexample>

<itemizedlist>
  
    <listitem>
      <simpara>The <literal><phrase role="code">jboss7-support</phrase></literal> module was deleted and is no longer needed as a dependency.</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
<section id="sid-59146804">
<title>Upgrading from Errai 2.2.x to 2.4 or 3.0</title>
<simpara>There are some breaking API changes in the update from Errai 2.2.x to Errai 2.4.x and 3.0.x.</simpara>
<simpara>Here are the steps you&#8217;ll need to take to get your project compiling after you update:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>Starting with Errai 2.3.0, GWT 2.5.0 or higher is required.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Use your IDE to organize imports at the top level. In eclipse, you&#8217;d click in the Project Explorer, press Ctrl-A (select all) and then Ctrl-O (Organize Imports). Other IDEs have similar features.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The <literal><phrase role="code">ErrorCallback</phrase></literal> interface has been made more general so the same type can be shared between Errai modules. This allows you reuse your own generic error handler class for, eg, Errai JAX-RS and ErraiBus callbacks. If you want to use a generic error handler throughout your app, change your <literal><phrase role="code">ErrorCallback</phrase></literal> implementations to <literal><phrase role="code">ErrorCallback&lt;?&gt;</phrase></literal> and change the first argument type of your error() method to Object. Otherwise, if you have use-case-specific error callbacks, implement the interfaces <literal><phrase role="code">RestErrorCallback</phrase></literal> or <literal><phrase role="code">BusErrorCallback</phrase></literal> as appropriate.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara><literal><phrase role="code">IOCBeanManager</phrase></literal> was replaced by two new types <literal><phrase role="code">SyncBeanManager</phrase></literal> and <literal><phrase role="code">AsyncBeanManager</phrase></literal> that need to be used instead. See <xref linkend="sid-21627016"/> for details.</simpara>
      
    </listitem>
  
</itemizedlist>

<simpara>Note: Errai 3 is still changing rapidly, so this section is a work in progress. Please add any additional steps you had to take in upgrading your own codebase.</simpara>
</section>
<section id="sid-77234301">
<title>Upgrading to Errai 3.0</title>
<simpara>Here are the steps you&#8217;ll need to take to get your project running after you update:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>Errai&#8217;s custom jetty launcher (org.jboss.errai.cdi.erver.gwt.JettyLauncher) is no longer needed and has been deleted. Simply remove the corresponding -server parameter from your GWT launch configuration if you still use it.</simpara>
      
    </listitem>
  
    <listitem>
      <simpara>The whole artifact errai-cdi-jetty has been deleted and is no longer required. Delete the JAR file from your project or remove the corresponding dependency in your pom.xml</simpara>
      
    </listitem>
  
</itemizedlist>

</section>
</chapter>
<chapter id="sid-5833087">
<title>Downloads</title>
<simpara>The distribution packages can be downloaded from jboss.org <ulink url="http://jboss.org/errai/Downloads.html">http://jboss.org/errai/Downloads.html</ulink></simpara>
</chapter>
<chapter id="sid-5833088">
<title>Sources</title>
<simpara>Errai is currently managed using Github. You can clone our repositories from <ulink url="http://github.com/errai">http://github.com/errai</ulink> .</simpara>
</chapter>
<chapter id="sid-5833089">
<title>Reporting problems</title>
<simpara>If you run into trouble don&#8217;t hesitate to get in touch with us:</simpara>

<itemizedlist>
  
    <listitem>
      <simpara>JIRA Issue Tracking: <ulink url="https://jira.jboss.org/jira/browse/ERRAI">https://jira.jboss.org/jira/browse/ERRAI</ulink></simpara>
      
    </listitem>
  
    <listitem>
      <simpara>User Forum: <ulink url="http://community.jboss.org/en/errai?view=discussions">http://community.jboss.org/en/errai?view=discussions</ulink></simpara>
      
    </listitem>
  
    <listitem>
      <simpara>Mailing List: <ulink url="http://jboss.org/errai/MailingLists.html">http://jboss.org/errai/MailingLists.html</ulink></simpara>
      
    </listitem>
  
    <listitem>
      <simpara>IRC: <ulink url="irc://irc.freenode.net/errai">irc://irc.freenode.net/errai</ulink></simpara>
      
    </listitem>
  
</itemizedlist>

</chapter>
<chapter id="sid-5833086">
<title>Errai License</title>
<simpara>Errai is distributed under the terms of the Apache License, Version 2.0. See <ulink url="http://www.apache.org/licenses/LICENSE-2.0">the full Apache license text</ulink>.</simpara>
</chapter>
</book>